// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"../node_modules/regenerator-runtime/runtime.js":[function(require,module,exports) {
var global = arguments[3];
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() {
    return this || (typeof self === "object" && self);
  })() || Function("return this")()
);

},{}],"../node_modules/regenerator-runtime/runtime-module.js":[function(require,module,exports) {
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() {
  return this || (typeof self === "object" && self);
})() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = require("./runtime");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}

},{"./runtime":"../node_modules/regenerator-runtime/runtime.js"}],"../node_modules/@babel/runtime/regenerator/index.js":[function(require,module,exports) {
module.exports = require("regenerator-runtime");

},{"regenerator-runtime":"../node_modules/regenerator-runtime/runtime-module.js"}],"../node_modules/@babel/runtime/helpers/asyncToGenerator.js":[function(require,module,exports) {
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;
},{}],"../node_modules/@babel/runtime/helpers/classCallCheck.js":[function(require,module,exports) {
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;
},{}],"../node_modules/@babel/runtime/helpers/createClass.js":[function(require,module,exports) {
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;
},{}],"../node_modules/base64-js/index.js":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"../node_modules/ieee754/index.js":[function(require,module,exports) {
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"../node_modules/isarray/index.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"../node_modules/buffer/index.js":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"../node_modules/base64-js/index.js","ieee754":"../node_modules/ieee754/index.js","isarray":"../node_modules/isarray/index.js","buffer":"../node_modules/buffer/index.js"}],"../lib/browser/bindgen_bg.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__wbindgen_free = exports.__wbindgen_malloc = exports.__wbindgen_global_argument_ptr = exports.encoding_is_corrupt = exports.encoding_decode = exports.encoding_encode = exports.encoding_new = exports.__wbg_encoding_free = exports.memory = exports.booted = void 0;

var import_b = _interopRequireWildcard(require("./bindgen"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

var bytes;
var base64 = "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uAogAEEBEAoLQQAhAEEBIQQMAQsgAigCpAUhASACQfAHaiACQagFaiIEQcQCENYBGiACQdgCaiAEQcQCENYBGkEAIQQLIAJBFGogAkHYAmpBxAIQ1gEaIAQNBiACQdgCaiACQRRqQcQCENYBGiADRQ0CIABBAXMNAiACQagFaigCACIARQ0CIAIoAqQFIABBARAKDAILIAIoAqQFIQEgAkHwB2ogAkGoBWoiBEHEAhDWARogAkHYAmogBEHEAhDWARpBACEECyACQRRqIAJB2AJqQcQCENYBGiAEDQUgAkHYAmogAkEUakHEAhDWARogA0UNACAAQQFzDQAgAkGoBWooAgAiAEUNACACKAKkBSAAQQEQCgsgAkHwB2ogAkHYAmpBxAIQ1gEaIAJBoAVqIAJB8AdqQcQCENYBGkHMAkEEEAkiAEUNASAAIAE2AgQgAEEANgIAIABBCGogAkGgBWpBxAIQ1gEaIAJB0ApqJAAgAA8LIAJBtAVqQQE2AgAgAkECNgLcAiACQgI3AqQFIAJBoLbAADYCoAUgAiACQQhqNgLYAiACIAJB2AJqNgKwBSACQfAHaiACQaAFahCZASACKALwByIAIAIoAvgHEAAhASACKAL0ByICRQ0GIAAgAkEBEAogARAOAAtBzAJBBBCWAQALAkAgAw0AAkAgAigCpAVFDQAgAkGsBWooAgAiAEUNACACQagFaigCACAAQQEQCgsCQCACQcQFaigCACIARQ0AIAJBwAVqKAIAIABBARAKCyACQdAFaigCACIARQ0FIAJBzAVqKAIAIABBARAKIAEQDgALIABFDQQgAkGoBWooAgAiAEUNBCACKAKkBSAAQQEQCiABEA4ACyADDQECQCACKAKkBUUNACACQawFaigCACIARQ0AIAJBqAVqKAIAIABBARAKCwJAIAJBxAVqKAIAIgBFDQAgAkHABWooAgAgAEEBEAoLIAJB0AVqKAIAIgBFDQMgAkHMBWooAgAgAEEBEAogARAOAAsgAw0BAkAgAigCpAVFDQAgAkGsBWooAgAiAEUNACACQagFaigCACAAQQEQCgsCQCACQcQFaigCACIARQ0AIAJBwAVqKAIAIABBARAKCyACQdAFaigCACIARQ0CIAJBzAVqKAIAIABBARAKIAEQDgALIABFDQEgAkGoBWooAgAiAEUNASACKAKk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AiACQcAFajYCyAUgAiACQcgFajYCiAMgAkHgAGogAkH4AmoQmQEgAEEBNgIAIABBDGogAkHgAGpBCGooAgA2AgAgACACKQNgNwIEAkAgAigCDCIARQ0AIAIoAgggAEEBEAoLAkAgAkEIakEUaigCACIARQ0AIAIoAhggAEEBEAoLAkAgAkEsaigCACIARQ0AIAJBKGooAgAgAEEBEAoLAkAgAkE4aigCACIARQ0AIAIoAjQgAEEBEAoLAkAgAkHEAGooAgAiAEUNACACQcAAaigCACAAQQEQCgsCQCABQRBqKAIAIgBFDQAgASgCDCAAQQEQCgsgAUEcaigCACIARQ0BIAEoAhggAEEBEAogAkHQBWokAA8LIAJB0ABqQQhqIgQgAkH8AGopAgA3AwAgAiACKQJ0NwNQIAJB8ABqIAEoAgggASgCBGoiBRAsIAUQJyEFIAJB+AJqQQhqIAQpAwA3AwAgAkH4AmpBGGogASkCCDcDACACQfgCakEgaiABQRBqKQIANwMAIAJB+AJqQShqIAFBGGopAgA3AwAgAkGoA2ogAUEgaikCADcDACACQbADaiABQShqKAIANgIAIAIgAikDUDcD+AIgAiABKQIANwOIAyACQbQDaiACQfAAakGIAhDWARogAEEEaiACQfgCakHEAhDWARogAEEANgIAIABByAJqIAU2AgACQCACKAIMIgFFDQAgAigCCCABQQEQCgsCQCACQRxqKAIAIgFFDQAgAigCGCABQQEQCgsCQCACQSxqKAIAIgFFDQAgAkEoaigCACABQQEQCgsCQCACQThqKAIAIgFFDQAgAigCNCABQQEQCgsgAkHEAGooAgAiAUUNACACQcAAaigCACABQQEQCgsgAkHQBWokAAutAQEDfyMAQTBrIgEkAAJAAkBBA0EBEAkiAkUNACACQSQ6AAIgAkG4gAI7AABBA0EBEAkiA0UNASADQQNBmILAAEEDECMgAUEcakKDgICAMDcCACABQRBqQoOAgIAwNwMAIAFCj4CAgPAHNwIkIAEgAzYCGCABIAI2AgwgAUEENgIIIAFCoICAgMAANwMAIAAgARAVIAFBMGokAA8LQQNBARCWAQALQQNBARCWAQALrQEBA38jAEEwayIBJAACQAJAQQNBARAJIgJFDQAgAkEkOgACIAJBuMQCOwAAQQNBARAJIgNF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AAsgByAGEKABAAsQHAALIApBgAIQngEACyACIAoQngEACyAMQQEQlgEACyAKIAMQngEAC5cHAQh/IwBBwARrIgQkACAEQZACaiABIAIgAxAaAkAgBCgCkAJBAUcNACAAQQE2AgAgACAEQZACakEEciIBKQIANwIEIABBDGogAUEIaigCADYCACAEQcAEaiQADwsgBEGYAmooAgAhAiAEQZACakEUaigCACEDIARBoAJqKAIAIQUgBCgClAIhBgJAAkACQAJAAkACQAJAAkACQAJAAkAgBEGQAmpBGGooAgAiByABQRhqKAIAIAFBFGooAgBqQQF2TQ0AQQ1BARAJIgFFDQEgAUENQYyDwABBDRAjIABBCGpCjYCAgNABNwIAIAAgATYCBCAAQQE2AgAgA0UNCQwICyAEQZwCaigCACEIIAFBxAJqIQkCQAJAAkACQAJAAkAgBw0AIAkgBiAIEClFDQELIARBkAJqIAkgBiAIIAUgBxAqIARBCGogBEGQAmpBhAIQ1gEaIARBBGoiByAEQZkEaiIILwAAOwEAIARBBmoiCSAEQZsEaiIKLQAAOgAAIAQgBCgAlQQ2AgACQCAELQCUBCILQQJHDQAgBEGkAmpBATYCACAEQQY2ArQEIARCATcClAIgBEGYt8AANgKQAiAEIARBuARqNgKwBCAEIARBsARqNgKgAiAEQaAEaiAEQZACahCZASAAQQE2AgAgAEEMaiAEQagEaigCADYCACAAIAQpA6AENwIEIAMNDQwOCyAEQZACaiAEQQhqQYQCENYBGiAIIAcvAQA7AAAgCiAJLQAAOgAAIAQgCzoAlAQgBCAEKAIANgCVBCAEQZACahAkIggoAgAiB0GBAk8NByAHIAFBEGooAgAiAUkNCCABQX9MDQYgAUUNASABQQEQCSIHDQIgAUEBEJYBAAsgCCABQRBqKAIAIgFJDQggAUF/TA0FIAFFDQIgAUEBEAkiBw0DIAFBARCWAQALQQEhBwsgByABIAhBBGogARAjIABBDGogATYCACAAQQhqIAE2AgAgACAHNgIEIABBADYCACADRQ0IDAcLQQEhBwsgByABIAYgARAjIABBDGogATYCACAAQQhqIAE2AgAgACAHNgIEIABBADYCACADDQUMBgtBDUEBEJYBAAsQHAALIAdBgAIQngEACyABIAcQngEACyAB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ACECIAUhCQNAIAIgCU8NAyAOIAJqIAQgAmotAABBf3MgA2o6AAAgCiACRg0BIAJBAWohAiAGKAL4HCIJQYACTQ0ACyAJQYACEJ4BAAsgD0UNAyAGQfAaakEAQYECENUBGiAPQX9qIglBgQJPDQQgBkHwGmogBkGQAmpBBXIgCRDWARogBiAJNgLYFCAGQdgUakEEciAGQfAaakGEAhDWARogBigC+BwiAkGBAk8NBSACRQ0JIAZB+BxqIAJqQQRqIQMgCUF/aiIMDQgMBwsgACAGQYwCENYBQYwCakEANgIAIAZBgB9qJAAPC0GIucAAIAIgCRCdAQALIA9BgAIQngEAC0EBQQAQoAEACyAJQYACEJ4BAAsgAkGAAhCeAQALIAVBgAIQngEAC0EGIRIMAgtBCCESDAELQRMhEgsDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCASDqICBPIBBQb2AQgQAAECA/MBCgsMDfcBDg8REhMU+wEVHvwBHyAxMjM0NTY4OTo7PD1FR0hKS0xNTk9QUlNUVVZXWFmAAlpbXWlqbW9ucHFyhQJzdHV2d3h5eocCe3x9gwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4B8AGPAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYB+QGnAawBrQGuAa8BsAGxAbIBswG0AbUBiQK2AYoCtwG4AbkBugG7AbwBvQG+Ab8BwAHBAcIBwwH6AcUBxgHMAc0BzgHPAdAB0QHSAdMB1AHVAdYB2AHkAeUB5gHnAegBjgLpAY8C6gHsAe0B7wHuAaAC2QHaAdsB1wHcAd0B3gHgAeEB3wHiAeMBjQKMAosCxAHHAcgByQHKAcsB6wGfAp4CnQKcApsC+AGoAakBqgGrAZoCmQKYAvEBkAGRAZIBkwGIAqEChgKCAZcClgKVAmuEAmxeX2BcYWJjZWZkZ2iUApMCUZECf0k+P0B+QYABQoEBQ0SSAv8BN/4B/QEhIiMkJicoKSorLC4wLS+DAiWCAhYXGPQBGfUBGhscHYECRpACCQcHCyAGKALYFCIJQX9qIgxFDasCQQghEgzxAwsgCC0AACICIAJB/wFGakH/AXFBjIXAAGotAAAiDUUNrAJBCSESDPADCyAJQYACSw2sAkEKIRIM7wMLQQAhAkEAIRIM7gMLIAIgCU8NngJBAiESDO0DCyACQQFqIQogBkHYFGogAmoiDkEEaiIPLQAAIgtFDaACQQMhEgzsAwsgDUGMicAAai0AACALQYyJwABqLQAAakGMhcAAai0AACELIAogCUkNoQIMogILQQAhCyAKIAlPDZ8CQQUhEgzqAwsgDyAOQQVqLQAAIAtzOgAAIAogDE8NoQJBoAIhEgzpAwsgCiECIAYoAtgUIglBgAJNDZsCDJoCCyAJQYACSw2nAkENIRIM5wMLQQAhAkEOIRIM5gMLIAIgCU8NlQJBDyESDOUDCyACQQFqIgogCU8NpQJBESESDOQDCyAGQdgUaiACaiICQQRqIAJBBWotAAA6AAAgCiAMTw2cAkESIRIM4wMLIAohAiAGKALYFCIJQYACTQ2hAgygAgsgCEEBaiIIIANHDZwCQRMhEgzhAwsgBkGYBGogBkHYFGpBiAIQ1gEaIAYoApgEIghBgQJPDaICQRQhEgzgAwsgBkHQEmpBAEGAAhDVARogBkHYFGpBAEGBAhDVARpBASEOIAZBAToA2BQgBkH4HGogBkHYFGpBhAIQ1gEaIAZBAToA7BggBkEBNgLoGCAGQegYakEFciICIAZB0BJqQYMCENYBGiAGQQE2AvAaIAZB8BpqQQRyIAZB+BxqQYQCENYBIRMgBkHoGGpBBHIhFCAHIAVrIhVFDaICQRUhEgzfAwsgCCAHIAcgCEkbIgIgB2shFiACQQNqIAdrIRcgBkHoGGpBAnIhAyAGQfgcakEEciEYIAZB2BRqQQRyIRkgBkHYFGpBBHIhGiAGQdgUakEEciEbIAZB6BhqQQRyIRxBACEdQRYhEgzeAwsgHSAWaiICIAhPDaICQRghEgzdAwsgBkGYBGogAmpBBGotAAAhCyAGKALoGCIPQQJJDaMCQZMCIRIM3AMLIA9BgAJLDdYDQZQCIRIM2wMLQQEhCiAPIQIgFyEJQZUCIRIM2gMLIAJBfmogD08N1QNBlwIhEgzZAwsgCUF8aiAITw3VA0GZAiESDNgDCyAKQQFqIQpBACEOIAMgAmotAAAiDEUN1QNBmgIhEgzXAwsgBkGYBGogCWotAAAiDUUN1QNBmwIhEgzWAwsgDUGMicAAai0AACAMQYyJwABqLQAAakGMhcAAai0AACEOQZwCIRIM1QMLIAJBf2ohAiAJQX9qIQkgDiALcyELIAogD0kNmgJBGSESDNQDCyAGKALwGiICQYACTw2bAkEbIRIM0wMLIAZB8BpqIAJqQQRqQQA6AAAgBiAGKALwGkEBaiIJNgLwGiALQf8BcSIORQ2bAkEcIRIM0gMLIAkgD00NmwJBgQIhEgzRAwsgCUGBAk8NwANBggIhEgzQAwsgBkH4HGogCWpBAEKBAiAJrX2nENUBGiAGQfgcaiATIAkQ1gEaIAYgCTYC2BQgGyAGQfgcakGEAhDWASECQYMCIRIMzwMLIAItAAAiCkUNwANBhAIhEgzOAwsgDkGMicAAai0AACAKQYyJwABqLQAAakGMhcAAai0AACEKDMADC0EAIQpBhQIhEgzMAwsgAiAKOgAAIAJBAWohAiAJQX9qIgkNvANBhgIhEgzLAwsgBigC6BghCSAGQfgcaiAGQdgUakGIAhDWARogCUGBAk8NvgNBhwIhEgzKAwsgBkHQEmogCWpBAEKBAiAJrX2nENUBGiAGQdASaiAcIAkQ1gEaIAYgCTYC2BQgGSAGQdASakGEAhDWASECIAlFDb4DQYgCIRIMyQMLIA5BjInAAGotAABB/wFzQYyFwABqLQAAIg9FDb4DQYkCIRIMyAMLIAIhAkGKAiESDMcDCyACLQAAIgpFDb8DQYsCIRIMxgMLIA9BjInAAGotAAAgCkGMicAAai0AAGpBjIXAAGotAAAhCgy/AwtBACEKQYwCIRIMxAMLIAIgCjoAACACQQFqIQIgCUF/aiIJDbsDDLoDCyACQQAgCRDVARpBjQIhEgzCAwsgBkHwGmogBkHYFGpBiAIQ1gEaIAZB6BhqIAZB+BxqQYgCENYBGiAGKALoGCEPQR0hEgzBAwsgD0GBAk8NiwJBHiESDMADCyAGKALwGiIJQYECTw2LAkEfIRIMvwMLIAZB0BJqIAlqQQBCgQIgCa19pxDVARogBkHQEmogEyAJENYBGiAGIAk2AtgUIBogBkHQEmpBhAIQ1gEhAiAJRQ2LAkEgIRIMvgMLIAIhAkEhIRIMvQMLIAItAAAiCkUNiwJBIiESDLwDCyAOQYyJwABqLQAAIApBjInAAGotAABqQYyFwABqLQAAIQoMiwILQQAhCkEjIRIMugMLIAIgCjoAACACQQFqIQIgCUF/aiIJDYcCQSQhEgy5AwsgBkH4HGogBkHYFGpBiAIQ1gEaIAYoAvgcIgJBgQJPDYkCQSUhEgy4AwsgBkHYFGogHCAPIBggAhAlIAZB6BhqIAZB2BRqQYgCENYBGkEmIRIMtwMLIBdBAWohFyAdQQFqIh0gFUkN+gFBJyESDLYDCyAGKALoGCIOQYECTw2HAkEoIRIMtQMLIAZB6BhqIA5qQQRqIQJBACEJIA5BBEkNhwJB8gEhEgy0AwsgBkHoGGpBBHIhD0EAIQlB8wEhEgyzAwsgDyAJaiIKLQAADYkCQfQBIRIMsgMLIApBAWotAAANngNB9gEhEgyxAwsgCkECai0AAA2eA0H4ASESDLADCyAKQQNqLQAADZ4DQfoBIRIMrwMLIAlBBGohCSACIApBBGprQQNLDZoDQfsBIRIMrgMLIAZB6BhqIAlqQQRqIRRBKSESDK0DCyAUIAJHDYECDIACC0EAIQlBKiESDKsDC0ErIRIMqgMLIBQtAAANgQJB8QEhEgypAwsgCUEBaiEJIAIgFEEBaiIURw3+AUEsIRIMqAMLIA4gCUkNgAJBLSESDKcDCyAGQdgUakEAQYECENUBGiAOIAlrIgpBgQJPDYUCQS4hEgymAwsgBkHYFGogBkHoGGogCWpBBGogChDWARogBkH4HGogBkHYFGpBgAIQ1gEaQQIhDyAGQdASakECaiAGQdsWai0AADoAACAGIAYvANkWOwHQEiAGLQDYFiELIAUhAiAKQX9qIgwgBUkNhQJBLyESDKUDCyAMIAVrQQF0IAVqIQJBMCESDKQDCyACIAdLDYQCQTEhEgyjAwsgBkHIEGogBkH4HGpBgAIQ1gEaIAZBuAxqQQJqIAZB0BJqQQJqLQAAOgAAIAYgBi8B0BI7AbgMIAshD0EyIRIMogMLIA9B/wFxQQJHDYMCQe4BIRIMoQMLIABBAjoAhAIgBkGAH2okAA8LIAZBqAZqIAZByBBqQYACENYBGiAGQaQGakECaiILIAZBuAxqQQJqLQAAOgAAIAYgBi8BuAw7AaQGIAYgCjYC2BQgBkHYFGpBBHIiAiAGQagGakGAAhDWARogBkHfFmogCy0AADoAACAGIA86ANwWIAYgBi8BpAY7AN0WIApBAXYiCkUNggJBNCESDJ8DCyAGQdgUaiAOQQNqIAlraiEJQTUhEgyeAwsgAi0AACEOIAIgCS0AADoAACAJIA46AAAgAkEBaiECIAlBf2ohCSAKQX9qIgoNgQJBNiESDJ0DCyAGQfgcaiAGQdgUakGIAhDWARogBigC+BwiHUGBAk8NgQJBNyESDJwDCyAGKAIAIQdBACEIIAZB8BpqQQBBgQIQ1QEaIAZBADYC2BQgBkHYFGpBBHIgBkHwGmpBhAIQ1gEaIAdFDYECQTghEgybAwsgHUUNgQJBOSESDJoDCyAGQfgcakEEciIDIB1qIQtBACEIQQAhDUE6IRIMmQMLIA1B/wFvIgJB/wFqIAIgAkEASBsiAkGABE8NgwJBPCESDJgDCyAGLQD8HCEKIAJBjIXAAGotAAAiDEUNgwJBPSESDJcDC0EBIQ4gAyECQQENhAIMgwILIAktAAAgD3MhCkEARQ2EAkE+IRIMlQMLIAsgAmsgDk0NiAJB4AEhEgyUAwsgAiAOaiIJQQFqIQIgCUUNigJB4QEhEgyTAwtBACEOQQAhDyAKQf8BcSIKRQ35AkHiASESDJIDCyAMQYyJwABqLQAAIApBjInAAGotAABqQYyFwABqLQAAIQ8M+QILIAsgAkYNgwJB5QEhEgyQAwsgAiEJIAJBAWohAiAJDYUCDIQCC0EBIQ4gAyECQQEN+AIM9wILIAItAAAhCkEAIQ4gCSECQQBFDfgCQecBIRIMjQMLIAsgAmsgDk0N/AFB6AEhEgyMAwsgAiAOaiICQQFqIQkgAg2EAgyDAgsgCyACRg37AUHrASESDIoDCyACQQFqIQkgAg37AUE/IRIMiQMLIApB/wFxRQ2CAkHAACESDIgDCyANQQFqIg0gB0kN7wEM8AELIAhBgAJPDewCQd8BIRIMhgMLIAZB2BRqIAhqQQRqIA1Bf3MgB2o6AAAgBiAGKALYFEEBaiIINgLYFCANQQFqIg0gB0kN7wFBwQAhEgyFAwsgCCAdQX9qRw2AAkHDACESDIQDCyAGQegYaiAGQdgUakGEAhDWARogBkHQEmpBAmoiAiAGQdgUakGHAmotAAA6AAAgBiAGLwDdFjsB0BIgBi0A3BYiCUECRw3+AUHCACESDIMDCyAAQQI6AIQCIAZBgB9qJAAPCyAGQagIaiAGQegYakGEAhDWARogBkGoCGpBhwJqIAItAAA6AAAgBiAJOgCsCiAGIAYvAdASOwCtCiAFRQ3+AUHFACESDIEDCyAGKAKoCCECQcYAIRIMgAMLIAJBgAJPDf4BQcgAIRIM/wILIAZBqAhqIAJqQQRqIAQtAAA6AAAgBiAGKAKoCEEBaiICNgKoCCAEQQFqIQQgBUF/aiIFDfwBQckAIRIM/gILIAdBgQJPDf0BQcoAIRIM/QILIAYoApACIgVBgQJPDf0BQcsAIRIM/AILIAYoAqgIIhVBgQJPDf0BQcwAIRIM+wILQQAhAiAGQdgUakEAQYECENUBGiAGIBU2ArAKIAZBsApqQQRyIhQgBkHYFGpBhAIQ1gEhCiAVRQ39AUHNACESDPoCCyAGQbAKakEEciEOIAZBqAhqQQRyIQ8gFSEJQc4AIRIM+QILIAlBgQJPDf0BQc8AIRIM+AILIAIgCU8N/QFB0QAhEgz3AgsgDiACaiAPIAJqLQAAQX9zIAdqOgAAIAYoArAKIQkgAkEBaiIKIQIgFSAKRw36AUHSACESDPYCCyAJQYACSw38AUHTACESDPUCCyAGQbAKaiAJakEEaiEWIAZBuAxqIRgM/AELIA4gCUEBaiIJTw3NAUHwASESDPMCCyAJIA4QoAEACyAOIAlBAmoiCU8NzQEMzAELIA4gCUEDaiIJTw3OAQzNAQtBACEJIAZBuAxqIRggCiEWQdQAIRIM7wILIAZB2BRqQQBBgAIQ1QEaIAZBAToA9BogBkEBNgLwGiAGQfAaakEFciAGQdgUakGDAhDWARogBkEBOgDADiAGQQA7ANASIAlFDfcBQdUAIRIM7gILIAYgBi0AtAoiAiACQf8BRmpB/wFxQYyFwABqLQAAOgDQEiAGQfAaakEEciENIAZB2BRqQQRyIRMgBkGwCmpBBXIhBCAGQfgcakEEciEcQQEhD0HWACESDO0CCyAGQfgcaiAGQcAOakEBIAZB0BJqQQIQJSAGKAL4HCICQYECTw33AUHXACESDOwCCyAGQegYakEAQYECENUBGiAGIA8gAmpBf2o2AtgUIBMgBkHoGGpBhAIQ1gEhFyACRQ33AUHYACESDOsCCyAPRQ33AUHZACESDOoCCyAGQfgcaiACakEEaiEdQQAhDiAcIQNB2gAhEgzpAgsgAy0AACIIRQ33AUHbACESDOgCCyAXIA5qIQxBACECQdwAIRIM5wILQQAhCiANIAJqLQAAIglFDfgBQd0AIRIM5gILIAhBjInAAGotAAAgCUGMicAAai0AAGpBjIXAAGotAAAhCkHeACESDOUCCyAGKALYFCIJQYECTw33AUHfACESDOQCCyAOIAJqIgsgCU8N+AFB4QAhEgzjAgsgDCACaiIJIAktAAAgCnM6AAAgAkEBaiIJIQIgDyAJRw3zAQzyAQtBACECIAYoAtgUIQlB0wEhEgzhAgsgCUGAAksNxQJB1AEhEgzgAgsgDiACaiILIAlPDfMBQdUBIRIM3wILIA8gAkEBaiICRw30AUHiACESDN4CCyAOQQFqIQ4gA0EBaiIDIB1HDesBQeMAIRIM3QILIAZB8BpqIAZB2BRqQYgCENYBGiAEIBZGDfMBQeQAIRIM3AILIAYgBC0AACICIAJB/wFGakH/AXFBjIXAAGotAAA6ANASIARBAWohBCAGKALwGiIPQYACTQ3lAUHlACESDNsCCyAPQYACEJ4BAAsgGCAGQfAaakGIAhDWARogBkHYFGogBWpBAEIAQoECIAWtfSAFQYACSxunENUBIQkgBkHYFGogESAFENYBGiAGQcAOaiAGQdgUakGEAhDWARogBiAFNgLYFCAGQdgUakEEciICIAZBwA5qQYQCENYBGiAFQQF2IgpFDfEBQecAIRIM2QILIAlBA2ohCUHoACESDNgCCyACLQAAIQ4gAiAJLQAAOgAAIAkgDjoAACACQQFqIQIgCUF/aiEJIApBf2oiCg3wAUHpACESDNcCCyAGQegYaiAGQdgUakGIAhDWARogBigC6BgiD0GBAk8N8AFB6gAhEgzWAgsgBigCuAwiAkGBAk8N8AFB6wAhEgzVAgsgBkHYFGpBAEGBAhDVARogBiACQQFqIgQ2AvAaIAZB8BpqQQRyIAZB2BRqQYQCENYBIRYgBEGBAk8N8AFB7AAhEgzUAgsgBkEBOgD0GiAGQfgcakEAQYECENUBGiAGIA8gAmpBf2o2AtgUIAZB2BRqQQRyIAZB+BxqQYQCENYBGiACRQ3wAUHtACESDNMCCyAPRQ3wAUHuACESDNICCyAGQbgMaiACakEEaiEdIAZB6BhqQQRyIQ0gBkHYFGpBBHIhFyAGQbgMakEEciEDQQAhDkHvACESDNECCyADLQAAIghFDfABQfAAIRIM0AILIBcgDmohDEEAIQJB8QAhEgzPAgtBACEKIA0gAmotAAAiCUUN8QFB8gAhEgzOAgsgCEGMicAAai0AACAJQYyJwABqLQAAakGMhcAAai0AACEKQfMAIRIMzQILIAYoAtgUIglBgQJPDfABQfQAIRIMzAILIA4gAmoiCyAJTw3xAUH2ACESDMsCCyAMIAJqIgkgCS0AACAKczoAACACQQFqIgkhAiAPIAlHDewBDOsBC0EAIQIgBigC2BQhCUHLASESDMkCCyAJQYACSw2sAkHMASESDMgCCyAOIAJqIgsgCU8N7AFBzQEhEgzHAgsgDyACQQFqIgJHDe0BQfcAIRIMxgILIA5BAWohDiADQQFqIgMgHUcN5AFB+AAhEgzFAgsgBkH4HGogBkHYFGpBiAIQ1gEaIAYoAvgcIgJBgQJPDewBQfkAIRIMxAILIAZB2BRqIAZB+BxqQQRyIAIgFiAEECYgBkHQEmogBkHYFGpBiAJqQYgCENYBGiAGKALQEiICQYECTw3sAUH6ACESDMMCCyACQQF2IgpFDewBQfsAIRIMwgILIAZB0BJqIAJqQQNqIQIgBkHQEmpBBHIhCUH8ACESDMECCyAJLQAAIQ4gCSACLQAAOgAAIAIgDjoAACAJQQFqIQkgAkF/aiECIApBf2oiCg3rAUH9ACESDMACCyAGQcgQaiAGQdASakGIAhDWARpBACELIAZB6BhqQQBBhQIQ1QEaIAYoArAKIglBgQJPDesBQf4AIRIMvwILIAlFDesBQf8AIRIMvgILQQAhC0GAASESDL0CC0EAIBQtAABB/wFza0H/AW8iAkH/AWogAiACQQBIGyICQYAETw3rAUGCASESDLwCCyALQYACTw3rAUGEASESDLsCCyAUQQFqIRQgBkHoGGogC2pBBGogAkGMhcAAai0AADoAACAGIAYoAugYQQFqIgs2AugYIAlBf2oiCQ3oAUGFASESDLoCCyAGQdgUakEAQYECENUBGiAGIAc2AvAaIAZB8BpqQQRyIAZB2BRqQYQCENYBGiAGQdgUaiAGQcgQakGIAhDWARogBigC2BQiAkGBAk8N6gFBhgEhEgy5AgsgAkEBdiIKRQ3qAUGHASESDLgCCyAGQdgUaiACakEDaiECIAZB2BRqQQRyIQlBiAEhEgy3AgsgCS0AACEOIAkgAi0AADoAACACIA46AAAgCUEBaiEJIAJBf2ohAiAKQX9qIgoN6QFBiQEhEgy2AgsgBkH4HGogBkHYFGpBiAIQ1gEaIAtBgQJPDekBQYoBIRIMtQILIAtFDekBQYsBIRIMtAILIAZB6BhqQQRyIhcgC2ohFCAGQegYakEEciEDIAZB+BxqQQRyIQQgBkHYFGpBBHIhFkEAIQ9BjAEhEgyzAgsgFy0AACECIAZB2BRqQQBBhQIQ1QEaIAJBjInAAGotAABB/wFzQYyFwABqLQAAIghFDeoBQY0BIRIMsgILQQAhAkEAIQlBjgEhEgyxAgsgDyAJRg3rAUGPASESDLACCyADIAlqLQAAIgpFDesBQZABIRIMrwILIApBjInAAGotAAAgCEGMicAAai0AAGpBjIXAAGotAAAhCiACQYACSQ3tAQzuAQtBACEKIAJBgAJPDesBQZIBIRIMrQILIAZB2BRqIAJqQQRqIApBAXM6AAAgBiAGKALYFEEBaiICNgLYFEGTASESDKwCCyALIAlBAWoiCUcN5QEM5AELQQAhAkEAIQlBvwEhEgyqAgsgDyAJRg2MAkHAASESDKkCCyACQf8BSw3lAUHBASESDKgCCyAGQdgUaiACakEEakEBOgAAIAYgBigC2BRBAWoiAjYC2BRBwgEhEgynAgsgCyAJQQFqIglHDecBQZQBIRIMpgILIAJBgQJPDecBQZUBIRIMpQILQQEhCiACRQ3nAUGWASESDKQCCyAWIQlBlwEhEgyjAgsgCkH/AXEhDkEAIQogDkUN5wFBmAEhEgyiAgsgCS0AACIMRQ3nAUGZASESDKECCyAMQYyJwABqLQAAIA5BjInAAGotAABqQYyFwABqLQAAIQpBmgEhEgygAgsgCUEBaiEJIAJBf2oiAg3jAUGbASESDJ8CCyAGKAL4HCICQYECTw3lAUGcASESDJ4CCyACRQ3lAUGdASESDJ0CCyAEIAJqIR0gBi0A/BwhDiAIRQ3lAUGeASESDJwCC0EBIQwgBCECQQEN5gEM5QELIAktAAAgDXMhDkEARQ3mAUGfASESDJoCCyAdIAJrIAxNDeoBQa4BIRIMmQILIAIgDGoiCUEBaiECIAlFDewBQa8BIRIMmAILQQAhDEEAIQ0gDkH/AXEiDkUN9QFBsAEhEgyXAgsgCEGMicAAai0AACAOQYyJwABqLQAAakGMhcAAai0AACENDPUBCyAdIAJGDeUBQbMBIRIMlQILIAIhCSACQQFqIQIgCQ3nAQzmAQtBASEMIAQhAkEBDfQBDPMBCyACLQAAIQ5BACEMIAkhAkEARQ30AUG1ASESDJICCyAdIAJrIAxNDd4BQbYBIRIMkQILIAIgDGoiAkEBaiEJIAIN5gEM5QELIB0gAkYN3QFBuQEhEgyPAgsgAkEBaiEJIAIN3QFBoAEhEgyOAgtBACECIA5B/wFxIglFDeQBQaEBIRIMjQILIBctAABBjInAAGotAAAiDiAOQf8BRmpB/wFxQYyFwABqLQAAIg5FDeQBQaIBIRIMjAILIAlBjInAAGotAAAgDkGMicAAai0AAGpBjIXAAGotAAAiCUUN5AFBowEhEgyLAgsgCUGMicAAai0AAEH/AWogCkH/AXFBjInAAGotAABrQf8BcEGMhcAAai0AACECQaQBIRIMigILIA8gFU8N4wFBpgEhEgyJAgsgByAGQagIaiAPakEEai0AACIJTQ3jAUGoASESDIgCCyAPQQFqIQ8gBkHwGmogCWpBBGogAjoAACAXQQFqIhcgFEcNvgEMvQELQQAhD0GpASESDIYCCyAGQdgUaiAGQQRyIAcgBkHwGmpBBHIgBxAlIAYgDzYC4BYgBkH4HGogBkHYFGpBiAIQ1gEaIAYoAvgcIgJBgQJPDeEBQaoBIRIMhQILIAEgBkH4HGpBBHIgAhApRQ3hAUGsASESDIQCCyAAQQI6AIQCIAZBgB9qJAAPCyABKAIAIQIgBigCACEJIAAgBkH4HGpBiAIQ1gEiCkGMAmogDzYCACAKQYgCaiAJIAJrNgIAIAZBgB9qJAAPC0GQuMAAIAsgCRCdAQALIAlBgAIQngEAC0GYucAAIAIgCRCdAQALIAlBgAIQngEAC0H4uMAAIAJBfmogDxCdAQALQbC4wAAgCUF8aiAIEJ0BAAtBqLnAACACQQFqIAkQnQEAC0GoucAAIAJBAWogCRCdAQALIAlBgAIQngEAC0GQuMAAIAsgCRCdAQALQYC4wAAgAkGAAhCdAQALQbC4wAAgAiAIEJ0BAAtBgLjAACACQYACEJ0BAAsgD0GAAhCeAQALIAlBgAIQngEACyACQYACEJ4BAAtBsLjAACACQYAEEJ0BAAsgD0GAAhCeAQALIAlBgAIQngEACyAJQYACEJ4BAAtBgLjAACAIQYACEJ0BAAtBgLjAACACQYACEJ0BAAsgCUGAAhCeAQALQei4wAAgAiAJEJ0BAAsgAkGAAhCeAQALQbC4wAAgAkGABBCdAQALQYC4wAAgC0GAAhCdAQALIAJBgAIQngEACyACQYACEJ4BAAtBoLjAAEEAQQAQnQEAC0GwuMAAIA8gFRCdAQALQZC4wAAgCSAHEJ0BAAsgCEGAAhCeAQALIApBgAIQngEACyAOQYACEJ4BAAsgHUGAAhCeAQALQaC4wABBAEEAEJ0BAAsgB0GAAhCeAQALIAVBgAIQngEACyAVQYACEJ4BAAsgD0GAAhCeAQALIAJBgAIQngEACyAEQYACEJ4BAAsgAkGAAhCeAQALIAJBgAIQngEACyAJQYACEJ4BAAsgAkGAAhCeAQALIAtBgAIQngEACyACQYACEJ4BAAsgCUGAAhCeAQALQQEhEgzPAQtBASESDM4BC0ELIRIMzQELQQAhEgzMAQtBoQIhEgzLAQtBBCESDMoBC0EFIRIMyQELQQQhEgzIAQtBBiESDMcBC0EGIRIMxgELQQYhEgzFAQtBByESDMQBC0EMIRIMwwELQQshEgzCAQtBCyESDMEBC0EOIRIMwAELQQshEgy/AQtBECESDL4BC0GfAiESDL0BC0GeAiESDLwBC0EWIRIMuwELQRchEgy6AQtBlQIhEgy5AQtBGSESDLgBC0EaIRIMtwELQSYhEgy2AQtBHSESDLUBC0GAAiESDLQBC0H/ASESDLMBC0EkIRIMsgELQSEhEgyxAQtB/gEhEgywAQtBIyESDK8BC0H9ASESDK4BC0H8ASESDK0BC0EpIRIMrAELQSwhEgyrAQtBKiESDKoBC0ErIRIMqQELQSwhEgyoAQtBLCESDKcBC0HwASESDKYBC0EtIRIMpQELQfABIRIMpAELQS0hEgyjAQtB8AEhEgyiAQtBLSESDKEBC0HvASESDKABC0EwIRIMnwELQTIhEgyeAQtBMyESDJ0BC0E2IRIMnAELQTUhEgybAQtB7QEhEgyaAQtBwQAhEgyZAQtB7AEhEgyYAQtBOiESDJcBC0HBACESDJYBC0E6IRIMlQELQTshEgyUAQtB5gEhEgyTAQtB5AEhEgySAQtBPiESDJEBC0HkASESDJABC0E/IRIMjwELQT8hEgyOAQtB6QEhEgyNAQtBPyESDIwBC0E/IRIMiwELQT8hEgyKAQtB4QEhEgyJAQtBPyESDIgBC0E/IRIMhwELQekBIRIMhgELQd0BIRIMhQELQcQAIRIMhAELQcIAIRIMgwELQckAIRIMggELQcYAIRIMgQELQccAIRIMgAELQdwBIRIMfwtB2wEhEgx+C0HaASESDH0LQdkBIRIMfAtBzgAhEgx7C0HYASESDHoLQdAAIRIMeQtB1wEhEgx4C0HUACESDHcLQeYAIRIMdgtB1gAhEgx1C0HWASESDHQLQeMAIRIMcwtB4wAhEgxyC0HaACESDHELQdIBIRIMcAtB4gAhEgxvC0HcACESDG4LQd4AIRIMbQtB0QEhEgxsC0HgACESDGsLQeAAIRIMagtB0wEhEgxpC0HmACESDGgLQekAIRIMZwtB6AAhEgxmC0HQASESDGULQc8BIRIMZAtBzgEhEgxjC0H4ACESDGILQfgAIRIMYQtB7wAhEgxgC0HKASESDF8LQfcAIRIMXgtB8QAhEgxdC0HzACESDFwLQckBIRIMWwtB9QAhEgxaC0H1ACESDFkLQcsBIRIMWAtByAEhEgxXC0HHASESDFYLQf0AIRIMVQtB/AAhEgxUC0HGASESDFMLQYUBIRIMUgtBgAEhEgxRC0GBASESDFALQYMBIRIMTwtBxQEhEgxOC0GJASESDE0LQYgBIRIMTAtBxAEhEgxLC0HDASESDEoLQakBIRIMSQtBjAEhEgxIC0G+ASESDEcLQZQBIRIMRgtBjgEhEgxFC0GTASESDEQLQb0BIRIMQwtBkQEhEgxCC0GRASESDEELQZIBIRIMQAtBkQEhEgw/C0G/ASESDD4LQbwBIRIMPQtBmwEhEgw8C0GXASESDDsLQZoBIRIMOgtBmgEhEgw5C0G7ASESDDgLQboBIRIMNwtBtAEhEgw2C0GyASESDDULQZ8BIRIMNAtBsgEhEgwzC0GgASESDDILQaABIRIMMQtBtwEhEgwwC0GgASESDC8LQaABIRIMLgtBoAEhEgwtC0GvASESDCwLQaABIRIMKwtBoAEhEgwqC0G3ASESDCkLQaQBIRIMKAtBpAEhEgwnC0GkASESDCYLQaUBIRIMJQtBpwEhEgwkC0GtASESDCMLQasBIRIMIgtBsQEhEgwhC0GxASESDCALQbgBIRIMHwtBtQEhEgweC0G4ASESDB0LQcIBIRIMHAtByQEhEgwbC0HRASESDBoLQd4BIRIMGQtB4wEhEgwYC0HjASESDBcLQeoBIRIMFgtB5wEhEgwVC0HqASESDBQLQfMBIRIMEwtB9QEhEgwSC0H3ASESDBELQfkBIRIMEAtBkgIhEgwPC0GDAiESDA4LQZECIRIMDQtBhQIhEgwMC0GQAiESDAsLQY0CIRIMCgtBjwIhEgwJC0GNAiESDAgLQYoCIRIMBwtBjgIhEgwGC0GMAiESDAULQZ0CIRIMBAtBlgIhEgwDC0GYAiESDAILQZwCIRIMAQtBnAIhEgwACwuQBQEJfyAAKAIAIQMCQAJAIAJFDQAgASACaiEEQQAhBUEAIQYDQCAGIANPDQICQAJAAkACQAJAAkAgBkH/AW8iAkH/AWogAiACQQBIGyICQYAETw0AIAEtAAAhBwJAIAJBjIXAAGotAAAiCEUNAEEBIQkgASECQQENAwwCC0EBIQkgASECQQENBAwDC0GwuMAAIAJBgAQQnQEAC0EGIQsMAwtBBCELDAILQQshCwwBC0EKIQsLA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgCw4NAgMEAAEMBQYJBwgKCwsLIAAtAAAgCnMhB0EARQ0PQQQhCwwaCyAEIAJrIAlNDRBBACELDBkLIAIgCWoiAEEBaiECIABFDQ5BASELDBgLQQAhCUEAIQogB0H/AXEiB0UNEUECIQsMFwsgCEGMicAAai0AACAHQYyJwABqLQAAakGMhcAAai0AACEKDBELIAQgAkYNFEEHIQsMFQsgAiEAIAJBAWohAiAADQ0MDAsgAi0AACEHQQAhCSAAIQJBAEUNBUEKIQsMEwsgBCACayAJTQ0OQQghCwwSCyACIAlqIgJBAWohACACDQUMBAsgBCACRg0NQQwhCwwQCyACQQFqIQAgAg0NQQUhCwwPCyAGQQFqIQYgB0H/AXFFDQ9BASEFDBELQQshCwwNC0EFIQsMDAtBCSELDAsLQQYhCwwKC0EFIQsMCQtBBSELDAgLQQUhCwwHC0EBIQsMBgtBAyELDAULQQMhCwwEC0EFIQsMAwtBBSELDAILQQkhCwwBC0EFIQsMAAsLC0EAIQUgA0UNAEGguMAAQQBBABCdAQALIAULXQEBfyMAQaAEayIGJAAgBiABIAIgAyAEIAUQKAJAIAYtAIQCQQJHDQAgAEECOgCEAiAGQaAEaiQADwsgBkGQAmogBkGQAhDWARogACAGQYwCENYBGiAGQaAEaiQACysBAX8jAEEQayICJAAgAiABQf6PwABBDRDKASACEL4BIQEgAkEQaiQAIAELtAQBC38jAEGgBmsiAiQAIAJBkAJqQQBBgAIQ1QEaIAJBAToADCACQQE2AgggAkEIakEFciACQZACakGDAhDWARoCQAJAAkACQAJAAkAgAUUNACACQQhqQQRyIQMgAkGQAmpBBXIhBCACQZACakEEciEFQQAhBgNAIAZB/wFvIgdB/wFqIAcgB0EASBsiB0GABE8NBSACKAIIIghBgQJPDQYgAkGYBGpBAEGBAhDVARogAiAIQQFqNgKQAiAFIAJBmARqQYQCENYBIQkCQCAIRQ0AIAdBjIXAAGotAAAhCkEAIQcDQEEAIQsCQCADIAdqLQAAIgxFDQAgDEGMicAAai0AAEGMhcAAai0AACELCyACKAKQAiIMQYECTw0EIAcgDE8NBiAJIAdqIgwgDC0AACALczoAACAHQQFqIgwhByAIIAxHDQALQQAhBwNAQQAhCwJAIAMgB2otAAAiDEUNAEEAIQsgCkUNACAKQYyJwABqLQAAIAxBjInAAGotAABqQYyFwABqLQAAIQsLIAIoApACIgxBgAJLDQQgB0EBaiIJIAxPDQUgBCAHaiIHIActAAAgC3M6AAAgCSEHIAggCUcNAAsLIAJBCGogAkGQAmpBiAIQ1gEaIAZBAWoiBiABSQ0ACwsgACACQQhqQYgCENYBGiACQaAGaiQADwsgDEGAAhCeAQALIAdBAWohBwtBuLnAACAHIAwQnQEAC0HIucAAIAdBgAQQnQEACyAIQYACEJ4BAAutCAEJfyMAQaAIayIEJAAgBEGQBGpBAEGBAhDVARoCQAJAAkACQAJAIANBgQJPDQAgBEGQBGogAiADENYBGiAEQQRyIARBkARqQYQCENYBIQUgBCADIAEoAgAiBmpBf2oiBzYCAAJAAkAgByADTQ0AIAQtAIQCQf8BcUUNACAHQYECTw0GIAcgA2tFDQEgBCAHakEEaiEIQQEgBmshCSADIQYgBSEHAkADQAJAAkAgBkUNACAIIAdrIAZNDQMgBkEBaiEKIAcgBmoiCw0BDAMLQQEhCiAHIQsgByAIRg0CIAtFDQILQQAhBiALQQA6AAAgByAKaiEHIAlBAWoiCQ0ACwsgASgCACEGDAELIAcgA08NACAEQYQCakEBOgAACyAEQYgCaiABQYgCENYBGiAEQZgGakEAQYECENUBGiAEIAY2ApAEIARBkARqQQRyIARBmAZqQYQCENYBGiAEKAKIAiIKQYECTw0BAkACQAJAAkACQCAKRQ0AAkAgBkGAAksNACAKQX9qIQkgBEGIAmpBBXIhASAEQZAEakEEciEIQQAhByAELQCMAiELA0AgByAGTw0DIAggB2ogC0H/AXFBjInAAGotAAA6AAAgCSAHRg0CIAEgB2ohBiAHQQFqIQcgBi0AACELIAQoApAEIgZBgAJNDQALCyAGQYACEJ4BAAsCQAJAAkACQCADRQ0AAkACQCAEKAKQBCIBQYACTQ0AIAQoAgAiB0GAAksNCCAKQQJPDQFBACELA0AgCyAHTw0IIAtBAWoiCyADSQ0ADAMLCwJAIApBAkkNAEEAIQsDQCAEKAIAIgdBgAJLDQkgCyAHTw0IAkAgBCALaiIJQQRqLQAAIgdFDQAgB0GMicAAai0AACEIQQUhBwNAIAdBfGogAU8NBiAEKAIAIgZBgAJLDQcgCyAHaiIMQXxqIAZPDQggCSAHaiIGIAYtAAAgBEGQBGogB2otAAAgCGpBjIXAAGotAABzOgAAIAdBfWohBiAHQQFqIQcgBiAKSQ0ACwsgC0EBaiILIANJDQAMAwsLQQAhCyAEKAIAIgdBgAJLIQYDQCAGDQggCyAHTw0HIAtBAWoiCyADSQ0ADAILCyAEQQRyIQZBACELA0AgCyAHTw0GIAYgC2otAAANCCALQQFqIgsgA0kNAAsLIAQoAgAiB0GBAk8NCSAHIANJDQogBSACIAMQ1gEaIAAgBEGIAhDWASADNgKIAiAEQaAIaiQADwtB2LnAACAHQXxqIAEQnQEACyAGQYACEJ4BAAtBuLnAACAMQXxqIAYQnQEAC0G4ucAAIAcgBhCdAQALQci5wAAgCyAHEJ0BAAsgB0GAAhCeAQALIAFBgAIQngEACyADQYACEJ4BAAsgCkGAAhCeAQALIAdBgAIQngEACyADIAcQngEACyAHQYACEJ4BAAtxAQF/IwBBEGsiAiQAIAAoAgAhACACIAFBsJXAAEELEMkBIAIgADYCDCACQbuVwABBCCACQQxqQYC8wAAQtAEaIAIgAEEEajYCDCACQcOVwABBBCACQQxqQZC8wAAQtAEaIAIQvAEhACACQRBqJAAgAAsLACAAKAIAIAEQMAuBAQEBfyMAQRBrIgIkAAJAAkACQAJAIAAtAAAiAEEBRg0AIABBAkYNASAAQQNHDQIgAiABQZWVwABBBxDKAQwDCyACIAFBpJXAAEEGEMoBDAILIAIgAUGclcAAQQgQygEMAQsgAiABQaqVwABBBhDKAQsgAhC+ASEAIAJBEGokACAACwsAIAAoAgAgARAyC58CAQJ/IwBBEGsiAiQAAkACQAJAAkACQAJAAkACQCAALQAAQX9qIgNBBksNAAJAIAMOBwACAwQFBgcACyACIAFB/pXAAEEIEMoBDAcLIAIgAUGGlsAAQQcQygEMBgsgAiABQfWVwABBCRDKASACIABBAWo2AgwgAiACQQxqQaC8wAAQvQEaDAULIAIgAUHplcAAQQwQygEMBAsgAiABQd+VwABBChDKAQwDCyACIAFB1pXAAEEJEMoBIAIgAEEBajYCDCACIAJBDGpBoLzAABC9ARoMAgsgAiABQdCVwABBBhDKAQwBCyACIAFBx5XAAEEJEMoBIAIgAEEBajYCDCACIAJBDGpBoLzAABC9ARoLIAIQvgEhACACQRBqJAAgAAsCAAu8CAIGfwJ+AkAgAkEFbiIFQQF2IgZFDQBBACEHIAEhCCADIQkDQCAJIAAgCC0AACIKai0AADoAACAJQQFqIAAgCEEBajEAAEIIhiAKrYQiC6dBBXZB/wFxai0AADoAACAJQQJqIAAgCEECajEAAEIQhiALhCILpyIKQQp2Qf8BcWotAAA6AAAgCUEDaiAAIApBD3ZB/wFxai0AADoAACAJQQRqIAAgCEEDajEAAEIYhiALhCILp0EUdkH/AXFqLQAAOgAAIAlBBWogACAIQQRqMQAAQiCGIgwgC4QiC0IZiKdB/wFxai0AADoAACAJQQZqIAAgC0IeiKdB/wFxai0AADoAACAJQQdqIAAgDEIjiKdqLQAAOgAAIAlBCGogACAIQQVqLQAAIgpqLQAAOgAAIAlBCWogACAIQQZqMQAAQgiGIAqthCILp0EFdkH/AXFqLQAAOgAAIAlBCmogACAIQQdqMQAAQhCGIAuEIgunIgpBCnZB/wFxai0AADoAACAJQQtqIAAgCkEPdkH/AXFqLQAAOgAAIAlBDGogACAIQQhqMQAAQhiGIAuEIgunQRR2Qf8BcWotAAA6AAAgCUENaiAAIAhBCWoxAABCIIYiDCALhCILQhmIp0H/AXFqLQAAOgAAIAlBDmogACALQh6Ip0H/AXFqLQAAOgAAIAlBD2ogACAMQiOIp2otAAA6AAAgCEEKaiEIIAlBEGohCSAHQQFqIgcgBkkNAAsLAkAgBUH+////A3EiByAFTw0AIAEgAkEKbiIJQQpsaiEIIAMgCUEEdGohCQNAIAkgACAILQAAIgpqLQAAOgAAIAlBAWogACAIQQFqMQAAQgiGIAqthCILp0EFdkH/AXFqLQAAOgAAIAlBAmogACAIQQJqMQAAQhCGIAuEIgunIgpBCnZB/wFxai0AADoAACAJQQNqIAAgCkEPdkH/AXFqLQAAOgAAIAlBBGogACAIQQNqMQAAQhiGIAuEIgunQRR2Qf8BcWotAAA6AAAgCUEFaiAAIAhBBGoxAABCIIYiDCALhCILQhmIp0H/AXFqLQAAOgAAIAlBBmogACALQh6Ip0H/AXFqLQAAOgAAIAlBB2ogACAMQiOIp2otAAA6AAAgCEEFaiEIIAlBCGohCSAHQQFqIgcgBUkNAAsLAkACQCAFQQVsIgkgAksNACAFQQN0IgYgBEsNASAEIAZrIQcCQAJAAkAgAiAJayIKRQ0AIAEgCWohBUIAIQtBACEJQQAhCANAIAUgCGoxAAAgCUE4ca2GIAuEIQsgCUEIaiEJIAhBAWoiCCAKSQ0ACyAHDQEMAgtCACELIAdFDQELIAMgBmohCkEAIQlBACEIA0AgCiAIaiAAIAsgCUE/ca2Ip0H/AXFqLQAAOgAAIAlBBWohCSAIQQFqIgggB0kNAAsLDwsgCSACEKABAAsgBiAEEKABAAvlAwIGfwF+IAJBA24hBQJAIAJBA0kNAEEAIQYgAyEHIAEhCANAIAcgACAILQAAIglqLQAAOgAAIAdBBmogACAIQQJqLQAAIgpBAnZqLQAAOgAAIAdBAWogACAIQQFqMQAAQgiGIAmthCILpyIJQQN2Qf8BcWotAAA6AAAgB0ECaiAAIAlBBnZB/wFxai0AADoAACAHQQNqIAAgCkEQdK0gC4SnIglBCXZB/wFxai0AADoAACAHQQRqIAAgCUEMdkH/AXFqLQAAOgAAIAdBBWogACAJQQ92Qf8BcWotAAA6AAAgB0EHaiAAIApBBXZqLQAAOgAAIAdBCGohByAIQQNqIQggBkEBaiIGIAVJDQALCwJAAkAgBUEDbCIHIAJLDQAgBUEDdCIFIARLDQEgBCAFayEKAkACQAJAIAIgB2siCUUNACABIAdqIQZCACELQQAhB0EAIQgDQCAGIAhqMQAAIAdBOHGthiALhCELIAdBCGohByAIQQFqIgggCUkNAAsgCg0BDAILQgAhCyAKRQ0BCyADIAVqIQlBACEHQQAhCANAIAkgCGogACALIAdBP3GtiKdB/wFxai0AADoAACAHQQNqIQcgCEEBaiIIIApJDQALCw8LIAcgAhCgAQALIAUgBBCgAQAL5QMCBn8BfiACQQNuIQUCQCACQQNJDQBBACEGIAMhByABIQgDQCAHIAAgCC0AACIJQQV2ai0AADoAACAHQQFqIAAgCUECdmotAAA6AAAgB0ECaiAAIAhBAWoxAABCCIYgCa1CEIaEIgunIglBD3ZB/wFxai0AADoAACAHQQNqIAAgCUEMdkH/AXFqLQAAOgAAIAdBBGogACAJQQl2Qf8BcWotAAA6AAAgB0EFaiAAIAsgCEECai0AACIJrYSnIgpBBnZB/wFxai0AADoAACAHQQZqIAAgCkEDdkH/AXFqLQAAOgAAIAdBB2ogACAJai0AADoAACAHQQhqIQcgCEEDaiEIIAZBAWoiBiAFSQ0ACwsCQAJAIAVBA2wiByACSw0AIAVBA3QiBSAESw0BIAQgBWshCQJAAkACQCACIAdrIgZFDQAgASAHaiEKQQAhB0IAIQtBECEIA0AgCiAHajEAACAIQThxrYYgC4QhCyAIQXhqIQggB0EBaiIHIAZJDQALIAkNAQwCC0IAIQsgCUUNAQsgAyAFaiEGQQAhB0EVIQgDQCAGIAdqIAAgCyAIQT9xrYinQf8BcWotAAA6AAAgCEF9aiEIIAdBAWoiByAJSQ0ACwsPCyAHIAIQoAEACyAFIAQQoAEAC8MIAgZ/An4CQCACQQVuIgVBAXYiBkUNAEEAIQcgASEIIAMhCQNAIAkgACAILQAAIgpBA3ZqLQAAOgAAIAlBAWogACAIQQFqMQAAQhiGIAqtQiCGhCILQh6Ip0H/AXFqLQAAOgAAIAlBAmogACALQhmIp0H/AXFqLQAAOgAAIAlBA2ogACAIQQJqMQAAQhCGIAuEIgunQRR2Qf8BcWotAAA6AAAgCUEEaiAAIAhBA2oxAABCCIYgC4QiC6ciCkEPdkH/AXFqLQAAOgAAIAlBBWogACAKQQp2Qf8BcWotAAA6AAAgCUEGaiAAIAsgCEEEajEAAISnIgpBBXZB/wFxai0AADoAACAJQQdqIAAgCkH/AXFqLQAAOgAAIAlBCGogACAIQQVqLQAAIgpBA3ZqLQAAOgAAIAlBCWogACAIQQZqMQAAQhiGIAqtQiCGhCILQh6Ip0H/AXFqLQAAOgAAIAlBCmogACALQhmIp0H/AXFqLQAAOgAAIAlBC2ogACAIQQdqMQAAQhCGIAuEIgunQRR2Qf8BcWotAAA6AAAgCUEMaiAAIAhBCGoxAABCCIYgC4QiC6ciCkEPdkH/AXFqLQAAOgAAIAhBCWoxAAAhDCAJQQ1qIAAgCkEKdkH/AXFqLQAAOgAAIAlBDmogACALIAyEpyIKQQV2Qf8BcWotAAA6AAAgCUEPaiAAIApB/wFxai0AADoAACAIQQpqIQggCUEQaiEJIAdBAWoiByAGSQ0ACwsCQCAFQf7///8DcSIHIAVPDQAgASACQQpuIglBCmxqIQggAyAJQQR0aiEJA0AgCSAAIAgtAAAiCkEDdmotAAA6AAAgCUEBaiAAIAhBAWoxAABCGIYgCq1CIIaEIgtCHoinQf8BcWotAAA6AAAgCUECaiAAIAtCGYinQf8BcWotAAA6AAAgCUEDaiAAIAhBAmoxAABCEIYgC4QiC6dBFHZB/wFxai0AADoAACAJQQRqIAAgCEEDajEAAEIIhiALhCILpyIKQQ92Qf8BcWotAAA6AAAgCUEFaiAAIApBCnZB/wFxai0AADoAACAJQQZqIAAgCyAIQQRqMQAAhKciCkEFdkH/AXFqLQAAOgAAIAlBB2ogACAKQf8BcWotAAA6AAAgCEEFaiEIIAlBCGohCSAHQQFqIgcgBUkNAAsLAkACQCAFQQVsIgkgAksNACAFQQN0IgYgBEsNASAEIAZrIQcCQAJAAkAgAiAJayIKRQ0AIAEgCWohBUEAIQlCACELQSAhCANAIAUgCWoxAAAgCEE4ca2GIAuEIQsgCEF4aiEIIAlBAWoiCSAKSQ0ACyAHDQEMAgtCACELIAdFDQELIAMgBmohCkEAIQlBIyEIA0AgCiAJaiAAIAsgCEE/ca2Ip0H/AXFqLQAAOgAAIAhBe2ohCCAJQQFqIgkgB0kNAAsLDwsgCSACEKABAAsgBiAEEKABAAu5BwIIfwF+AkAgAkEDbiIFQQJ2IgZFDQBBACEHIAEhCCADIQkDQCAJIAAgCC0AACIKai0AADoAACAJQQRqIAAgCEEDai0AACILai0AADoAACAJQQNqIAAgCEECai0AACIMQQJ2ai0AADoAACAJQQFqIAAgCEEBajEAAEIIhiINIAqthKdBBnZB/wFxai0AADoAACAJQQJqIAAgDEEQdK0gDYSnQQx2Qf8BcWotAAA6AAAgCEEFai0AACEKIAlBBWogACAIQQRqMQAAQgiGIg0gC62Ep0EGdkH/AXFqLQAAOgAAIAlBBmogACAKQRB0rSANhKdBDHZB/wFxai0AADoAACAJQQdqIAAgCkECdmotAAA6AAAgCUEIaiAAIAhBBmotAAAiCmotAAA6AAAgCUELaiAAIAhBCGotAAAiC0ECdmotAAA6AAAgCUEJaiAAIAhBB2oxAABCCIYiDSAKrYSnQQZ2Qf8BcWotAAA6AAAgCUEKaiAAIAtBEHStIA2Ep0EMdkH/AXFqLQAAOgAAIAhBC2otAAAhCiAIQQpqMQAAIQ0gCUEMaiAAIAhBCWotAAAiC2otAAA6AAAgCUENaiAAIA1CCIYiDSALrYSnQQZ2Qf8BcWotAAA6AAAgCUEOaiAAIApBEHStIA2Ep0EMdkH/AXFqLQAAOgAAIAlBD2ogACAKQQJ2ai0AADoAACAIQQxqIQggCUEQaiEJIAdBAWoiByAGSQ0ACwsCQCAFQfz///8HcSIKIAVPDQAgASACQQxuIglBDGxqIQggAyAJQQR0aiEJA0AgCSAAIAgtAAAiB2otAAA6AAAgCUEDaiAAIAhBAmotAAAiC0ECdmotAAA6AAAgCUEBaiAAIAhBAWoxAABCCIYiDSAHrYSnQQZ2Qf8BcWotAAA6AAAgCUECaiAAIAtBEHStIA2Ep0EMdkH/AXFqLQAAOgAAIAhBA2ohCCAJQQRqIQkgCkEBaiIKIAVJDQALCwJAAkAgBUEDbCIJIAJLDQAgBUECdCIMIARLDQEgBCAMayEKAkACQAJAIAIgCWsiB0UNACABIAlqIQtCACENQQAhCUEAIQgDQCALIAhqMQAAIAlBOHGthiANhCENIAlBCGohCSAIQQFqIgggB0kNAAsgCg0BDAILQgAhDSAKRQ0BCyADIAxqIQdBACEJQQAhCANAIAcgCGogACANIAlBPnGtiKdB/wFxai0AADoAACAJQQZqIQkgCEEBaiIIIApJDQALCw8LIAkgAhCgAQALIAwgBBCgAQALuQcCCH8BfgJAIAJBA24iBUECdiIGRQ0AQQAhByABIQggAyEJA0AgCSAAIAgtAAAiCkECdmotAAA6AAAgCUEDaiAAIAhBAmotAAAiC2otAAA6AAAgCUEEaiAAIAhBA2otAAAiDEECdmotAAA6AAAgCUEBaiAAIAhBAWoxAABCCIYiDSAKQRB0rYSnQQx2Qf8BcWotAAA6AAAgCUECaiAAIA0gC62Ep0EGdkH/AXFqLQAAOgAAIAhBBWotAAAhCiAJQQVqIAAgCEEEajEAAEIIhiINIAxBEHSthKdBDHZB/wFxai0AADoAACAJQQZqIAAgDSAKrYSnQQZ2Qf8BcWotAAA6AAAgCUEHaiAAIApqLQAAOgAAIAlBC2ogACAIQQhqLQAAIgpqLQAAOgAAIAlBCGogACAIQQZqLQAAIgtBAnZqLQAAOgAAIAlBCmogACAIQQdqMQAAQgiGIg0gCq2Ep0EGdkH/AXFqLQAAOgAAIAlBCWogACANIAtBEHSthKdBDHZB/wFxai0AADoAACAIQQtqLQAAIQogCEEKajEAACENIAlBDGogACAIQQlqLQAAIgtBAnZqLQAAOgAAIAlBDWogACANQgiGIg0gC0EQdK2Ep0EMdkH/AXFqLQAAOgAAIAlBDmogACANIAqthKdBBnZB/wFxai0AADoAACAJQQ9qIAAgCmotAAA6AAAgCEEMaiEIIAlBEGohCSAHQQFqIgcgBkkNAAsLAkAgBUH8////B3EiCiAFTw0AIAEgAkEMbiIJQQxsaiEIIAMgCUEEdGohCQNAIAkgACAILQAAIgdBAnZqLQAAOgAAIAlBA2ogACAIQQJqLQAAIgtqLQAAOgAAIAlBAWogACAIQQFqMQAAQgiGIg0gB0EQdK2Ep0EMdkH/AXFqLQAAOgAAIAlBAmogACANIAuthKdBBnZB/wFxai0AADoAACAIQQNqIQggCUEEaiEJIApBAWoiCiAFSQ0ACwsCQAJAIAVBA2wiCSACSw0AIAVBAnQiDCAESw0BIAQgDGshCgJAAkACQCACIAlrIgdFDQAgASAJaiELQQAhCUIAIQ1BECEIA0AgCyAJajEAACAIQThxrYYgDYQhDSAIQXhqIQggCUEBaiIJIAdJDQALIAoNAQwCC0IAIQ0gCkUNAQsgAyAMaiEHQQAhCUESIQgDQCAHIAlqIAAgDSAIQT5xrYinQf8BcWotAAA6AAAgCEF6aiEIIAlBAWoiCSAKSQ0ACwsPCyAJIAIQoAEACyAMIAQQoAEAC+UDAgd/An4jAEEQayIGJAACQAJAAkACQAJAAkAgA0EBdiIHRQ0AQQAhCEEAIQkDQCABIAIgCGoiCi0AAGotAAAiC0EPSw0CQQEhDCABIApBAWotAABqLQAAIgpBEE8NAyAEIAlqIAtBBHQgCnI6AAAgCEECaiEIIAlBAWoiCSAHSQ0ACwsgByAFSw0EAkACQAJAIAMgA0F+cSIMayIKRQ0AIAIgDGohC0EAIQhCACENQQQhCQNAIAEgCyAIai0AAGoxAAAiDkIPVg0GIA4gCUE8ca2GIA2EIQ0gCUF8aiEJIAhBAWoiCCAKSQ0ACyAFIAdrIgkNAQwCC0IAIQ0gBSAHayIJRQ0BCyAEIAdqIQhBACEBA0AgCCANIAFBOHGtiDwAACABQXhqIQEgCEEBaiEIIAlBf2oiCQ0ACwsgAEEANgIAIAAgBTYCBCAGQRBqJAAPC0EAIQwLIAwgCHIhCAwBCyAMIAhqIQgLIAZBCmpBAmoiASAGQQ1qQQJqLQAAOgAAIAYgBi8ADTsBCiAAQRBqQQE6AAAgAEEMaiAINgIAIABBCGogCEEBdjYCACAAIAhBfnE2AgQgAEEBNgIAIAAgBi8BCjsAESAAQRNqIAEtAAA6AAAgBkEQaiQADwsgByAFEKABAAuXBgIHfwN+IwBBEGsiByQAAkACQAJAAkACQAJAIARBAnYiCEUNAEEAIQkgBSEKQQAhCwNAIAIgAyAJaiIMLQAAajEAACIOQj9WDQJBASENIAIgDEEBai0AAGoxAAAiD0LAAFoNA0ECIQ0gAiAMQQJqLQAAajEAACIQQj9WDQNBAyENIAIgDEEDai0AAGotAAAiDEE/Sw0DIApBAmogDCAQQgaGIhCncjoAACAKQQFqIBAgD0IMhiIPhEIIiDwAACAKIA8gDkIShoRCEIg8AAAgCUEEaiEJIApBA2ohCiALQQFqIgsgCEkNAAsLIAhBA2wiCyAGSw0DAkACQAJAAkAgBCAEQXxxIghrIglFDQAgAyAIaiENQQAhCkIAIQ5BEiEMA0AgAiANIApqLQAAajEAACIPQj9WDQQgDyAMQT5xrYYgDoQhDiAMQXpqIQwgCkEBaiIKIAlJDQALIAYgC2siCQ0BDAILQgAhDiAGIAtrIglFDQELIAUgC2ohCkEQIQwDQCAKIA4gDEE4ca2IPAAAIAxBeGohDCAKQQFqIQogCUF/aiIJDQALCwJAIAFFDQAgBEEGbCIMQQZxRQ0AIARBf2ohCiAERQ0GIAIgAyAKai0AAGotAABBfyAMQQZxdEF/c3FFDQAgB0EKakECaiICIAdBDWpBAmotAAA6AAAgByAHLwANOwEKIABBEGpBAjoAACAAQQxqIAo2AgAgAEEIaiAKQQJ2QQNsNgIAIAAgCkF8cTYCBCAAQQE2AgAgACAHLwEKOwARIABBE2ogAi0AADoAACAHQRBqJAAPCyAAQQA2AgAgACAGNgIEIAdBEGokAA8LIAggCmohAgwCC0EAIQ0LIA0gCXIhAgsgB0EEakECaiIKIAdBB2pBAmotAAA6AAAgByAHLwAHOwEEIABBEGpBAToAACAAQQxqIAI2AgAgAEEIaiACQQJ2QQNsNgIAIAAgAkF8cTYCBCAAQQE2AgAgACAHLwEEOwARIABBE2ogCi0AADoAACAHQRBqJAAPCyALIAYQoAEAC0GgusAAIApBABCdAQAL5QMCB38CfiMAQRBrIgYkAAJAAkACQAJAAkACQCADQQF2IgdFDQBBACEIQQAhCQNAIAEgAiAIaiIKLQAAai0AACILQQ9LDQJBASEMIAEgCkEBai0AAGotAAAiCkEQTw0DIAQgCWogCkEEdCALcjoAACAIQQJqIQggCUEBaiIJIAdJDQALCyAHIAVLDQQCQAJAAkAgAyADQX5xIgxrIgpFDQAgAiAMaiELQgAhDUEAIQlBACEIA0AgASALIAhqLQAAajEAACIOQg9WDQYgDiAJQTxxrYYgDYQhDSAJQQRqIQkgCEEBaiIIIApJDQALIAUgB2siCQ0BDAILQgAhDSAFIAdrIglFDQELIAQgB2ohCEEAIQEDQCAIIA0gAUE4ca2IPAAAIAFBCGohASAIQQFqIQggCUF/aiIJDQALCyAAQQA2AgAgACAFNgIEIAZBEGokAA8LQQAhDAsgDCAIciEIDAELIAwgCGohCAsgBkEKakECaiIBIAZBDWpBAmotAAA6AAAgBiAGLwANOwEKIABBEGpBAToAACAAQQxqIAg2AgAgAEEIaiAIQQF2NgIAIAAgCEF+cTYCBCAAQQE2AgAgACAGLwEKOwARIABBE2ogAS0AADoAACAGQRBqJAAPCyAHIAUQoAEAC5oHAgd/CH4jAEEQayIHJAACQAJAAkACQAJAAkAgBEEDdiIIRQ0AQQAhCSAFIQpBACELA0AgAiADIAlqIgwtAABqMQAAIg5CB1YNAkEBIQ0gAiAMQQFqLQAAajEAACIPQghaDQNBAiENIAIgDEECai0AAGoxAAAiEEIHVg0DQQMhDSACIAxBA2otAABqMQAAIhFCB1YNA0EEIQ0gAiAMQQRqLQAAajEAACISQgdWDQNBBSENIAIgDEEFai0AAGoxAAAiE0IHVg0DQQYhDSACIAxBBmotAABqMQAAIhRCB1YNA0EHIQ0gAiAMQQdqLQAAajEAACIVQgdWDQMgCiAQQgaGIA9CA4YgDoSEIg48AAAgCkEBaiATQg+GIBJCDIYgEUIJhiAOhISEIg5CCIg8AAAgCkECaiAVQhWGIBRCEoYgDoSEQhCIPAAAIAlBCGohCSAKQQNqIQogC0EBaiILIAhJDQALCyAIQQNsIgsgBksNAwJAAkACQAJAIAQgBEF4cSIIayIKRQ0AIAMgCGohCUIAIQ5BACENQQAhDANAIAIgCSAMai0AAGoxAAAiD0IHVg0EIA8gDUE/ca2GIA6EIQ4gDUEDaiENIAxBAWoiDCAKSQ0ACyAGIAtrIgoNAQwCC0IAIQ4gBiALayIKRQ0BCyAFIAtqIQxBACENA0AgDCAOIA1BOHGtiDwAACANQQhqIQ0gDEEBaiEMIApBf2oiCg0ACwsCQCABRQ0AIARBA2wiDUEHcUUNACAEQX9qIQwgBEUNBiACIAMgDGotAABqLQAAQX8gDUEHcXRBf3NBAyANa0EHcXRxRQ0AIAdBCmpBAmoiAiAHQQ1qQQJqLQAAOgAAIAcgBy8ADTsBCiAAQRBqQQI6AAAgAEEMaiAMNgIAIABBCGogDEEDdkEDbDYCACAAIAxBeHE2AgQgAEEBNgIAIAAgBy8BCjsAESAAQRNqIAItAAA6AAAgB0EQaiQADwsgAEEANgIAIAAgBjYCBCAHQRBqJAAPCyAIIAxqIQIMAgtBACENCyANIAlyIQILIAdBBGpBAmoiDCAHQQdqQQJqLQAAOgAAIAcgBy8ABzsBBCAAQRBqQQE6AAAgAEEMaiACNgIAIABBCGogAkEDdkEDbDYCACAAIAJBeHE2AgQgAEEBNgIAIAAgBy8BBDsAESAAQRNqIAwtAAA6AAAgB0EQaiQADwsgCyAGEKABAAtBoLrAACAMQQAQnQEAC6AGAgh/A34jAEEQayIHJAACQAJAAkACQAJAAkAgBEECdiIIRQ0AQQAhCSAFIQpBACELA0AgAiADIAlqIgwtAABqLQAAIg1BP0sNAkEBIQ4gAiAMQQFqLQAAajEAACIPQsAAWg0DQQIhDiACIAxBAmotAABqMQAAIhBCP1YNA0EDIQ4gAiAMQQNqLQAAajEAACIRQj9WDQMgCkECaiARQhKGIBBCDIYiEIRCEIg8AAAgCkEBaiAQIA9CBoYiD4RCCIg8AAAgCiANIA+ncjoAACAJQQRqIQkgCkEDaiEKIAtBAWoiCyAISQ0ACwsgCEEDbCILIAZLDQMCQAJAAkACQCAEIARBfHEiDWsiCUUNACADIA1qIQ5CACEPQQAhDEEAIQoDQCACIA4gCmotAABqMQAAIhBCP1YNBCAQIAxBPnGthiAPhCEPIAxBBmohDCAKQQFqIgogCUkNAAsgBiALayIJDQEMAgtCACEPIAYgC2siCUUNAQsgBSALaiEKQQAhDANAIAogDyAMQThxrYg8AAAgDEEIaiEMIApBAWohCiAJQX9qIgkNAAsLAkAgAUUNACAEQQZsIgxBBnFFDQAgBEF/aiEKIARFDQYgAiADIApqLQAAai0AAEF/IAxBBnF0QX9zQQYgDGtBBnF0cUUNACAHQQpqQQJqIgIgB0ENakECai0AADoAACAHIAcvAA07AQogAEEQakECOgAAIABBDGogCjYCACAAQQhqIApBAnZBA2w2AgAgACAKQXxxNgIEIABBATYCACAAIAcvAQo7ABEgAEETaiACLQAAOgAAIAdBEGokAA8LIABBADYCACAAIAY2AgQgB0EQaiQADwsgDSAKaiECDAILQQAhDgsgDiAJciECCyAHQQRqQQJqIgogB0EHakECai0AADoAACAHIAcvAAc7AQQgAEEQakEBOgAAIABBDGogAjYCACAAQQhqIAJBAnZBA2w2AgAgACACQXxxNgIEIABBATYCACAAIAcvAQQ7ABEgAEETaiAKLQAAOgAAIAdBEGokAA8LIAsgBhCgAQALQaC6wAAgCkEAEJ0BAAuwBwIHfwd+IwBBEGsiByQAAkACQAJAAkACQAJAIARBA3YiCEUNAEEAIQkgBSEKQQAhCwNAIAIgAyAJaiIMLQAAajEAACIOQh9WDQJBASENIAIgDEEBai0AAGoxAAAiD0IgWg0DQQIhDSACIAxBAmotAABqMQAAIhBCH1YNA0EDIQ0gAiAMQQNqLQAAajEAACIRQh9WDQNBBCENIAIgDEEEai0AAGoxAAAiEkIfVg0DQQUhDSACIAxBBWotAABqMQAAIhNCH1YNA0EGIQ0gAiAMQQZqLQAAajEAACIUQh9WDQNBByENIAIgDEEHai0AAGotAAAiDEEfSw0DIApBBGogDCAUQgWGIhSncjoAACAKIBBCGYYgD0IehiAOQiOGhIQiDkIgiDwAACAKQQFqIBFCFIYgDoQiDkIYiDwAACAKQQJqIBNCCoYgEkIPhiAOhIQiDkIQiDwAACAKQQNqIBQgDoRCCIg8AAAgCUEIaiEJIApBBWohCiALQQFqIgsgCEkNAAsLIAhBBWwiCyAGSw0DAkACQAJAAkAgBCAEQXhxIghrIgpFDQAgAyAIaiEJQQAhDEIAIQ5BIyENA0AgAiAJIAxqLQAAajEAACIPQh9WDQQgDyANQT9xrYYgDoQhDiANQXtqIQ0gDEEBaiIMIApJDQALIAYgC2siCg0BDAILQgAhDiAGIAtrIgpFDQELIAUgC2ohDEEgIQ0DQCAMIA4gDUE4ca2IPAAAIA1BeGohDSAMQQFqIQwgCkF/aiIKDQALCwJAIAFFDQAgBEEFbCINQQdxRQ0AIARBf2ohDCAERQ0GIAIgAyAMai0AAGotAABBfyANQQdxdEF/c3FFDQAgB0EKakECaiICIAdBDWpBAmotAAA6AAAgByAHLwANOwEKIABBEGpBAjoAACAAQQxqIAw2AgAgAEEIaiAMQQN2QQVsNgIAIAAgDEF4cTYCBCAAQQE2AgAgACAHLwEKOwARIABBE2ogAi0AADoAACAHQRBqJAAPCyAAQQA2AgAgACAGNgIEIAdBEGokAA8LIAggDGohAgwCC0EAIQ0LIA0gCXIhAgsgB0EEakECaiIMIAdBB2pBAmotAAA6AAAgByAHLwAHOwEEIABBEGpBAToAACAAQQxqIAI2AgAgAEEIaiACQQN2QQVsNgIAIAAgAkF4cTYCBCAAQQE2AgAgACAHLwEEOwARIABBE2ogDC0AADoAACAHQRBqJAAPCyALIAYQoAEAC0GgusAAIAxBABCdAQALkgcCB38HfiMAQRBrIgckAAJAAkACQAJAAkACQCAEQQN2IghFDQBBACEJIAUhCkEAIQsDQCACIAMgCWoiDC0AAGoxAAAiDkIHVg0CQQEhDSACIAxBAWotAABqMQAAIg9CCFoNA0ECIQ0gAiAMQQJqLQAAajEAACIQQgdWDQNBAyENIAIgDEEDai0AAGoxAAAiEUIHVg0DQQQhDSACIAxBBGotAABqMQAAIhJCB1YNA0EFIQ0gAiAMQQVqLQAAajEAACITQgdWDQNBBiENIAIgDEEGai0AAGoxAAAiFEIHVg0DQQchDSACIAxBB2otAABqLQAAIgxBB0sNAyAKIBJCCYYgEUIMhiAQQg+GIA9CEoYgDkIVhoSEhIQiDkIQiDwAACAKQQFqIBRCA4YgE0IGhiAOhIQiDkIIiDwAACAKQQJqIAwgDqdyOgAAIAlBCGohCSAKQQNqIQogC0EBaiILIAhJDQALCyAIQQNsIgsgBksNAwJAAkACQAJAIAQgBEF4cSIIayIKRQ0AIAMgCGohCUEAIQxCACEOQRUhDQNAIAIgCSAMai0AAGoxAAAiD0IHVg0EIA8gDUE/ca2GIA6EIQ4gDUF9aiENIAxBAWoiDCAKSQ0ACyAGIAtrIgoNAQwCC0IAIQ4gBiALayIKRQ0BCyAFIAtqIQxBECENA0AgDCAOIA1BOHGtiDwAACANQXhqIQ0gDEEBaiEMIApBf2oiCg0ACwsCQCABRQ0AIARBA2wiDUEHcUUNACAEQX9qIQwgBEUNBiACIAMgDGotAABqLQAAQX8gDUEHcXRBf3NxRQ0AIAdBCmpBAmoiAiAHQQ1qQQJqLQAAOgAAIAcgBy8ADTsBCiAAQRBqQQI6AAAgAEEMaiAMNgIAIABBCGogDEEDdkEDbDYCACAAIAxBeHE2AgQgAEEBNgIAIAAgBy8BCjsAESAAQRNqIAItAAA6AAAgB0EQaiQADwsgAEEANgIAIAAgBjYCBCAHQRBqJAAPCyAIIAxqIQIMAgtBACENCyANIAlyIQILIAdBBGpBAmoiDCAHQQdqQQJqLQAAOgAAIAcgBy8ABzsBBCAAQRBqQQE6AAAgAEEMaiACNgIAIABBCGogAkEDdkEDbDYCACAAIAJBeHE2AgQgAEEBNgIAIAAgBy8BBDsAESAAQRNqIAwtAAA6AAAgB0EQaiQADwsgCyAGEKABAAtBoLrAACAMQQAQnQEAC6MEAgl/An4jAEEQayIGJAACQAJAAkACQAJAIANBAnYiB0UNAEEAIQhBACEJA0AgASACIAhqIgotAABqLQAAIgtBA0sNAkEBIQwgASAKQQFqLQAAai0AACINQQRPDQNBAiEMIAEgCkECai0AAGotAAAiDkEDSw0DQQMhDCABIApBA2otAABqLQAAIgpBA0sNAyAEIAlqIA5BAnQgDUEEdCALQQZ0cnIgCnI6AAAgCEEEaiEIIAlBAWoiCSAHSQ0ACwsgByAFSw0DAkACQAJAAkAgAyADQXxxIgtrIgxFDQAgAiALaiEJQQAhCkIAIQ9BBiEIA0AgASAJIApqLQAAajEAACIQQgNWDQQgECAIQT5xrYYgD4QhDyAIQX5qIQggCkEBaiIKIAxJDQALIAUgB2siCA0BDAILQgAhDyAFIAdrIghFDQELIAQgB2ohAUEAIQoDQCABIA8gCkE4ca2IPAAAIApBeGohCiABQQFqIQEgCEF/aiIIDQALCyAAQQA2AgAgACAFNgIEIAZBEGokAA8LIAsgCmohAQwCC0EAIQwLIAwgCHIhAQsgBkEKakECaiIKIAZBDWpBAmotAAA6AAAgBiAGLwANOwEKIABBEGpBAToAACAAQQxqIAE2AgAgAEEIaiABQQJ2NgIAIAAgAUF8cTYCBCAAQQE2AgAgACAGLwEKOwARIABBE2ogCi0AADoAACAGQRBqJAAPCyAHIAUQoAEAC6MEAgl/An4jAEEQayIGJAACQAJAAkACQAJAIANBAnYiB0UNAEEAIQhBACEJA0AgASACIAhqIgotAABqLQAAIgtBA0sNAkEBIQwgASAKQQFqLQAAai0AACINQQRPDQNBAiEMIAEgCkECai0AAGotAAAiDkEDSw0DQQMhDCABIApBA2otAABqLQAAIgpBA0sNAyAEIAlqIApBBnQgDkEEdCANQQJ0IAtycnI6AAAgCEEEaiEIIAlBAWoiCSAHSQ0ACwsgByAFSw0DAkACQAJAAkAgAyADQXxxIgtrIgxFDQAgAiALaiEJQgAhD0EAIQhBACEKA0AgASAJIApqLQAAajEAACIQQgNWDQQgECAIQT5xrYYgD4QhDyAIQQJqIQggCkEBaiIKIAxJDQALIAUgB2siCA0BDAILQgAhDyAFIAdrIghFDQELIAQgB2ohAUEAIQoDQCABIA8gCkE4ca2IPAAAIApBCGohCiABQQFqIQEgCEF/aiIIDQALCyAAQQA2AgAgACAFNgIEIAZBEGokAA8LIAsgCmohAQwCC0EAIQwLIAwgCHIhAQsgBkEKakECaiIKIAZBDWpBAmotAAA6AAAgBiAGLwANOwEKIABBEGpBAToAACAAQQxqIAE2AgAgAEEIaiABQQJ2NgIAIAAgAUF8cTYCBCAAQQE2AgAgACAGLwEKOwARIABBE2ogCi0AADoAACAGQRBqJAAPCyAHIAUQoAEAC5gFAg1/An4jAEEQayIGJAACQAJAAkACQAJAIANBA3YiB0UNAEEAIQhBACEJA0AgASACIAhqIgotAABqLQAAIgtBAUsNAkEBIQwgASAKQQFqLQAAai0AACINQQJPDQNBAiEMIAEgCkECai0AAGotAAAiDkEBSw0DQQMhDCABIApBA2otAABqLQAAIg9BAUsNA0EEIQwgASAKQQRqLQAAai0AACIQQQFLDQNBBSEMIAEgCkEFai0AAGotAAAiEUEBSw0DQQYhDCABIApBBmotAABqLQAAIhJBAUsNA0EHIQwgASAKQQdqLQAAai0AACIKQQFLDQMgBCAJaiAKQQd0IBJBBnQgEUEFdCAQQQR0IA9BA3QgDkECdCANQQF0IAtycnJycnJyOgAAIAhBCGohCCAJQQFqIgkgB0kNAAsLIAcgBUsNAwJAAkACQAJAIAMgA0F4cSILayIIRQ0AIAIgC2ohCUEAIQpCACETA0AgASAJIApqLQAAajEAACIUQgFWDQQgFCAKQT9xrYYgE4QhEyAKQQFqIgwhCiAMIAhJDQALIAUgB2siDA0BDAILQgAhEyAFIAdrIgxFDQELIAQgB2ohAUEAIQoDQCABIBMgCkE4ca2IPAAAIApBCGohCiABQQFqIQEgDEF/aiIMDQALCyAAQQA2AgAgACAFNgIEIAZBEGokAA8LIAsgCmohAQwCC0EAIQwLIAwgCHIhAQsgBkEKakECaiIKIAZBDWpBAmotAAA6AAAgBiAGLwANOwEKIABBEGpBAToAACAAQQxqIAE2AgAgAEEIaiABQQN2NgIAIAAgAUF4cTYCBCAAQQE2AgAgACAGLwEKOwARIABBE2ogCi0AADoAACAGQRBqJAAPCyAHIAUQoAEAC7gHAgd/CH4jAEEQayIHJAACQAJAAkACQAJAAkAgBEEDdiIIRQ0AQQAhCSAFIQpBACELA0AgAiADIAlqIgwtAABqMQAAIg5CH1YNAkEBIQ0gAiAMQQFqLQAAajEAACIPQiBaDQNBAiENIAIgDEECai0AAGoxAAAiEEIfVg0DQQMhDSACIAxBA2otAABqMQAAIhFCH1YNA0EEIQ0gAiAMQQRqLQAAajEAACISQh9WDQNBBSENIAIgDEEFai0AAGoxAAAiE0IfVg0DQQYhDSACIAxBBmotAABqMQAAIhRCH1YNA0EHIQ0gAiAMQQdqLQAAajEAACIVQh9WDQMgCiAPQgWGIA6EIg48AAAgCkEBaiARQg+GIBBCCoYgDoSEIg5CCIg8AAAgCkECaiASQhSGIA6EIg5CEIg8AAAgCkEDaiAUQh6GIBNCGYYgDoSEIg5CGIg8AAAgCkEEaiAVQiOGIA6EQiCIPAAAIAlBCGohCSAKQQVqIQogC0EBaiILIAhJDQALCyAIQQVsIgsgBksNAwJAAkACQAJAIAQgBEF4cSIIayIKRQ0AIAMgCGohCUIAIQ5BACENQQAhDANAIAIgCSAMai0AAGoxAAAiD0IfVg0EIA8gDUE/ca2GIA6EIQ4gDUEFaiENIAxBAWoiDCAKSQ0ACyAGIAtrIgoNAQwCC0IAIQ4gBiALayIKRQ0BCyAFIAtqIQxBACENA0AgDCAOIA1BOHGtiDwAACANQQhqIQ0gDEEBaiEMIApBf2oiCg0ACwsCQCABRQ0AIARBBWwiDUEHcUUNACAEQX9qIQwgBEUNBiACIAMgDGotAABqLQAAQX8gDUEHcXRBf3NBBSANa0EHcXRxRQ0AIAdBCmpBAmoiAiAHQQ1qQQJqLQAAOgAAIAcgBy8ADTsBCiAAQRBqQQI6AAAgAEEMaiAMNgIAIABBCGogDEEDdkEFbDYCACAAIAxBeHE2AgQgAEEBNgIAIAAgBy8BCjsAESAAQRNqIAItAAA6AAAgB0EQaiQADwsgAEEANgIAIAAgBjYCBCAHQRBqJAAPCyAIIAxqIQIMAgtBACENCyANIAlyIQILIAdBBGpBAmoiDCAHQQdqQQJqLQAAOgAAIAcgBy8ABzsBBCAAQRBqQQE6AAAgAEEMaiACNgIAIABBCGogAkEDdkEFbDYCACAAIAJBeHE2AgQgAEEBNgIAIAAgBy8BBDsAESAAQRNqIAwtAAA6AAAgB0EQaiQADwsgCyAGEKABAAtBoLrAACAMQQAQnQEAC58FAg1/An4jAEEQayIGJAACQAJAAkACQAJAIANBA3YiB0UNAEEAIQhBACEJA0AgASACIAhqIgotAABqLQAAIgtBAUsNAkEBIQwgASAKQQFqLQAAai0AACINQQJPDQNBAiEMIAEgCkECai0AAGotAAAiDkEBSw0DQQMhDCABIApBA2otAABqLQAAIg9BAUsNA0EEIQwgASAKQQRqLQAAai0AACIQQQFLDQNBBSEMIAEgCkEFai0AAGotAAAiEUEBSw0DQQYhDCABIApBBmotAABqLQAAIhJBAUsNA0EHIQwgASAKQQdqLQAAai0AACIKQQFLDQMgBCAJaiASQQF0IBFBAnQgEEEDdCAPQQR0IA5BBXQgDUEGdCALQQd0cnJycnJyIApyOgAAIAhBCGohCCAJQQFqIgkgB0kNAAsLIAcgBUsNAwJAAkACQAJAIAMgA0F4cSILayIIRQ0AIAIgC2ohCUEAIQpCACETQQchDANAIAEgCSAKai0AAGoxAAAiFEIBVg0EIBQgDEE/ca2GIBOEIRMgDEF/aiEMIApBAWoiCiAISQ0ACyAFIAdrIgwNAQwCC0IAIRMgBSAHayIMRQ0BCyAEIAdqIQFBACEKA0AgASATIApBOHGtiDwAACAKQXhqIQogAUEBaiEBIAxBf2oiDA0ACwsgAEEANgIAIAAgBTYCBCAGQRBqJAAPCyALIApqIQEMAgtBACEMCyAMIAhyIQELIAZBCmpBAmoiCiAGQQ1qQQJqLQAAOgAAIAYgBi8ADTsBCiAAQRBqQQE6AAAgAEEMaiABNgIAIABBCGogAUEDdjYCACAAIAFBeHE2AgQgAEEBNgIAIAAgBi8BCjsAESAAQRNqIAotAAA6AAAgBkEQaiQADwsgByAFEKABAAubBwELfyMAQSBrIgckAAJAAkAgBEUNACADQQNqIQggBiEJQQAhCkEAIQsCQAJAAkACQAJAAkACQANAAkACQAJAAkACQCAJIAtJDQAgCSAGSw0BIAdBCGogASACIAMgCmogBCAKayAFIAtqIAkgC2sQPSAHKAIIQQFHDQ4gBygCDCAKaiIMQQhqIQogDEF4Tw0CIAogBEsNAyAHQQhqQQhqKAIAIAtqIQ0gCCAMaiELIAMgDGohDkEAIQ8CQAJAAkACQAJAA0AgCyEQIAIgDiAPaiILQQdqLQAAai0AAEGCAUcNASACIAtBBmotAABqLQAAQYIBRw0DIAIgC0EFai0AAGotAABBggFHDQQgAiALQQRqIhEtAABqLQAAQYIBRw0FIBBBfGohCyAPQXxqIQ8gESAOa0EDSw0AC0EAIA9rIQsgD0F4Rg0BA0AgAiAQLQAAai0AAEGCAUcNAiAQQX9qIRAgC0EBaiILQQhHDQAMAgsLQQAgD2shCwtBCCALayIPRQ0JDAcLQQhBASAPa2siDw0GDAgLQQhBAiAPa2siDw0FDAcLQQhBAyAPa2siDw0EDAYLIAsgCRCgAQALIAkgBhCeAQALIAwgChCgAQALIAogBBCeAQALIA9BA2wiC0EHcSIQQQJLDQEgEEEDTw0DIA8gDGoiECAPSQ0EIBAgBEsNBSALQQN2IhAgDWoiCyAQSQ0GIAsgBksNByAHQQhqIAEgAiAOIA8gBSANaiAQED0gBygCCEEBRg0CIAkgEGpBfWohCSAKIARJDQAMCQsLIAdBBGpBAmoiAiAHQQhqQQJqLQAAOgAAIAcgBy8ACDsBBCAAQRBqQQM6AAAgAEEMaiAPIAxqNgIAIABBCGogDTYCACAAIAw2AgQgAEEBNgIAIAAgBy8BBDsAESAAQRNqIAItAAA6AAAgB0EgaiQADwsgB0EIakEMaigCACECIAdBCGpBEGotAAAhCyAHQQJqIg8gB0EEakECai0AADoAACAHIAcvAAQ7AQAgAEEQaiALOgAAIABBDGogAiAMajYCACAAQQhqIA02AgAgACAMNgIEIABBATYCACAAIAcvAQA7ABEgAEETaiAPLQAAOgAAIAdBIGokAA8LQc6RwABBKyAPIBBBA25rQQAQXwALIAwgEBCgAQALIBAgBBCeAQALIA0gCxCgAQALIAsgBhCeAQALIAYhCQsgAEEANgIAIAAgCTYCBCAHQSBqJAALrwUBCn8jAEEgayIGJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCADRQ0AQQAhByAGQRBqIQggBSEJQQAhCgNAIAkgCkkNBSAJIAVLDQYgBkEIaiABIAIgB2ogAyAHayAEIApqIAkgCmsQOiAGKAIIQQFHDQIgBigCDCAHaiILQQJqIQcgC0F+Tw0HIAcgA0sNCCAIKAIAIQxBAiENAkAgASACIAtqIg4tAAFqLQAAQYIBRw0AIAEgDi0AAGotAABBggFHIQ0LIAwgCmohDyANQQFxIA1Fcg0DIA1BAnEiCiANRw0JIA0gC2oiCiANSQ0KIAogA0sNCyANQQF2IgwgD2oiCiAMSQ0MIAogBUsNDSAGQQhqIAEgDiANIAQgD2ogDBA6IAYoAghBAUYNBCAJIAxqQX9qIQkgByADSQ0ADAILCyAFIQkLIABBADYCACAAIAk2AgQgBkEgaiQADwsgBkEEakECaiIKIAZBCGpBAmotAAA6AAAgBiAGLwAIOwEEIABBEGpBAzoAACAAQQxqIA0gC2o2AgAgAEEIaiAPNgIAIAAgCzYCBCAAQQE2AgAgACAGLwEEOwARIABBE2ogCi0AADoAACAGQSBqJAAPCyAGQQhqQQxqKAIAIQ0gBkEIakEQai0AACEKIAZBAmoiByAGQQRqQQJqLQAAOgAAIAYgBi8ABDsBACAAQRBqIAo6AAAgAEEMaiANIAtqNgIAIABBCGogDzYCACAAIAs2AgQgAEEBNgIAIAAgBi8BADsAESAAQRNqIActAAA6AAAgBkEgaiQADwsgCiAJEKABAAsgCSAFEJ4BAAsgCyAHEKABAAsgByADEJ4BAAtBzpHAAEErIApBABBfAAsgCyAKEKABAAsgCiADEJ4BAAsgDyAKEKABAAsgCiAFEJ4BAAuMBwELfyMAQSBrIgYkAAJAAkAgA0UNACACQQNqIQcgBSEIQQAhCUEAIQoCQAJAAkACQAJAAkACQANAAkACQAJAAkACQCAIIApJDQAgCCAFSw0BIAZBCGogASACIAlqIAMgCWsgBCAKaiAIIAprEEMgBigCCEEBRw0OIAYoAgwgCWoiC0EIaiEJIAtBeE8NAiAJIANLDQMgBkEIakEIaigCACAKaiEMIAcgC2ohDSACIAtqIQ5BACEKAkACQAJAAkACQANAIA0hDyABIA4gCmoiDUEHai0AAGotAABBggFHDQEgASANQQZqLQAAai0AAEGCAUcNAyABIA1BBWotAABqLQAAQYIBRw0EIAEgDUEEaiIQLQAAai0AAEGCAUcNBSAPQXxqIQ0gCkF8aiEKIBAgDmtBA0sNAAtBACAKayENIApBeEYNAQNAIAEgDy0AAGotAABBggFHDQIgD0F/aiEPIA1BAWoiDUEIRw0ADAILC0EAIAprIQ0LQQggDWsiDUUNCQwHC0EIQQEgCmtrIg0NBgwIC0EIQQIgCmtrIg0NBQwHC0EIQQMgCmtrIg0NBAwGCyAKIAgQoAEACyAIIAUQngEACyALIAkQoAEACyAJIAMQngEACyANQQdxDQEgDUF4cSIKIA1HDQMgDSALaiIKIA1JDQQgCiADSw0FIA1BA3YiDyAMaiIKIA9JDQYgCiAFSw0HIAZBCGogASAOIA0gBCAMaiAPEEMgBigCCEEBRg0CIAggD2pBf2ohCCAJIANJDQAMCQsLIAZBBGpBAmoiASAGQQhqQQJqLQAAOgAAIAYgBi8ACDsBBCAAQRBqQQM6AAAgAEEMaiANIAtqNgIAIABBCGogDDYCACAAIAs2AgQgAEEBNgIAIAAgBi8BBDsAESAAQRNqIAEtAAA6AAAgBkEgaiQADwsgBkEIakEMaigCACEBIAZBCGpBEGotAAAhDSAGQQJqIgogBkEEakECai0AADoAACAGIAYvAAQ7AQAgAEEQaiANOgAAIABBDGogASALajYCACAAQQhqIAw2AgAgACALNgIEIABBATYCACAAIAYvAQA7ABEgAEETaiAKLQAAOgAAIAZBIGokAA8LQc6RwABBKyAKQQAQXwALIAsgChCgAQALIAogAxCeAQALIAwgChCgAQALIAogBRCeAQALIAUhCAsgAEEANgIAIAAgCDYCBCAGQSBqJAALjwcBDH8jAEEgayIGJAACQAJAIANFDQAgAkF/aiEHIAZBEGohCCAFIQlBACEKQQAhCwJAAkACQAJAAkACQAJAA0ACQAJAAkACQAJAIAkgC0kNACAJIAVLDQEgBkEIaiABIAIgCmogAyAKayAEIAtqIAkgC2sQQiAGKAIIQQFHDQ4gBigCDCAKaiIMQQRqIQogDEF8Tw0CIAogA0sNAyAIKAIAIAtqIQ0gByAMaiEOIAIgDGohD0EAIQsCQAJAAkACQAJAA0AgDiEQIAEgDyALaiIRQQNqLQAAai0AAEGCAUcNASABIBFBAmotAABqLQAAQYIBRw0DIAEgEUEBai0AAGotAABBggFHDQQgASARLQAAai0AAEGCAUcNBSAQQXxqIQ4gC0F8aiELIBEgD2tBA0sNAAtBACALayERIAtBfEYNAQNAIAEgEC0AAGotAABBggFHDQIgEEF/aiEQIBFBAWoiEUEERw0ADAILC0EAIAtrIRELQQQgEWsiEUUNCQwHC0EEQQEgC2trIhENBgwIC0EEQQIgC2trIhENBQwHC0EEQQMgC2trIhENBAwGCyALIAkQoAEACyAJIAUQngEACyAMIAoQoAEACyAKIAMQngEACyARQQNxDQEgEUF8cSILIBFHDQMgESAMaiILIBFJDQQgCyADSw0FIBFBAnZB/////wFxIhAgDWoiCyAQSQ0GIAsgBUsNByAGQQhqIAEgDyARIAQgDWogEBBCIAYoAghBAUYNAiAJIBBqQX9qIQkgCiADSQ0ADAkLCyAGQQRqQQJqIgEgBkEIakECai0AADoAACAGIAYvAAg7AQQgAEEQakEDOgAAIABBDGogESAMajYCACAAQQhqIA02AgAgACAMNgIEIABBATYCACAAIAYvAQQ7ABEgAEETaiABLQAAOgAAIAZBIGokAA8LIAZBCGpBDGooAgAhESAGQQhqQRBqLQAAIQEgBkECaiILIAZBBGpBAmotAAA6AAAgBiAGLwAEOwEAIABBEGogAToAACAAQQxqIBEgDGo2AgAgAEEIaiANNgIAIAAgDDYCBCAAQQE2AgAgACAGLwEAOwARIABBE2ogCy0AADoAACAGQSBqJAAPC0HOkcAAQSsgC0EAEF8ACyAMIAsQoAEACyALIAMQngEACyANIAsQoAEACyALIAUQngEACyAFIQkLIABBADYCACAAIAk2AgQgBkEgaiQAC4wHAQt/IwBBIGsiBiQAAkACQCADRQ0AIAJBA2ohByAFIQhBACEJQQAhCgJAAkACQAJAAkACQAJAA0ACQAJAAkACQAJAIAggCkkNACAIIAVLDQEgBkEIaiABIAIgCWogAyAJayAEIApqIAggCmsQRSAGKAIIQQFHDQ4gBigCDCAJaiILQQhqIQkgC0F4Tw0CIAkgA0sNAyAGQQhqQQhqKAIAIApqIQwgByALaiENIAIgC2ohDkEAIQoCQAJAAkACQAJAA0AgDSEPIAEgDiAKaiINQQdqLQAAai0AAEGCAUcNASABIA1BBmotAABqLQAAQYIBRw0DIAEgDUEFai0AAGotAABBggFHDQQgASANQQRqIhAtAABqLQAAQYIBRw0FIA9BfGohDSAKQXxqIQogECAOa0EDSw0AC0EAIAprIQ0gCkF4Rg0BA0AgASAPLQAAai0AAEGCAUcNAiAPQX9qIQ8gDUEBaiINQQhHDQAMAgsLQQAgCmshDQtBCCANayINRQ0JDAcLQQhBASAKa2siDQ0GDAgLQQhBAiAKa2siDQ0FDAcLQQhBAyAKa2siDQ0EDAYLIAogCBCgAQALIAggBRCeAQALIAsgCRCgAQALIAkgAxCeAQALIA1BB3ENASANQXhxIgogDUcNAyANIAtqIgogDUkNBCAKIANLDQUgDUEDdiIPIAxqIgogD0kNBiAKIAVLDQcgBkEIaiABIA4gDSAEIAxqIA8QRSAGKAIIQQFGDQIgCCAPakF/aiEIIAkgA0kNAAwJCwsgBkEEakECaiIBIAZBCGpBAmotAAA6AAAgBiAGLwAIOwEEIABBEGpBAzoAACAAQQxqIA0gC2o2AgAgAEEIaiAMNgIAIAAgCzYCBCAAQQE2AgAgACAGLwEEOwARIABBE2ogAS0AADoAACAGQSBqJAAPCyAGQQhqQQxqKAIAIQEgBkEIakEQai0AACENIAZBAmoiCiAGQQRqQQJqLQAAOgAAIAYgBi8ABDsBACAAQRBqIA06AAAgAEEMaiABIAtqNgIAIABBCGogDDYCACAAIAs2AgQgAEEBNgIAIAAgBi8BADsAESAAQRNqIAotAAA6AAAgBkEgaiQADwtBzpHAAEErIApBABBfAAsgCyAKEKABAAsgCiADEJ4BAAsgDCAKEKABAAsgCiAFEJ4BAAsgBSEICyAAQQA2AgAgACAINgIEIAZBIGokAAv3BgEMfyMAQSBrIgckAAJAAkAgBEUNACADQX9qIQggB0EQaiEJIAYhCkEAIQtBACEMAkACQAJAAkACQAJAA0ACQAJAAkACQAJAIAogDEkNACAKIAZLDQEgB0EIaiABIAIgAyALaiAEIAtrIAUgDGogCiAMaxA+IAcoAghBAUcNDSAHKAIMIAtqIg1BBGohCyANQXxPDQIgCyAESw0DIAkoAgAgDGohDiAIIA1qIQ8gAyANaiEQQQAhEQJAAkACQAJAAkADQCAPIRIgAiAQIBFqIgxBA2otAABqLQAAQYIBRw0BIAIgDEECai0AAGotAABBggFHDQMgAiAMQQFqLQAAai0AAEGCAUcNBCACIAwtAABqLQAAQYIBRw0FIBJBfGohDyARQXxqIREgDCAQa0EDSw0AC0EAIBFrIQwgEUF8Rg0BA0AgAiASLQAAai0AAEGCAUcNAiASQX9qIRIgDEEBaiIMQQRHDQAMAgsLQQAgEWshDAtBBCAMayIRRQ0JDAcLQQRBASARa2siEQ0GDAgLQQRBAiARa2siEQ0FDAcLQQRBAyARa2siEQ0EDAYLIAwgChCgAQALIAogBhCeAQALIA0gCxCgAQALIAsgBBCeAQALIBFBBmwiDEEGcUEGRg0BIBEgDWoiEiARSQ0DIBIgBEsNBCAMQQN2IhIgDmoiDCASSQ0FIAwgBksNBiAHQQhqIAEgAiAQIBEgBSAOaiASED4gBygCCEEBRg0CIAogEmpBfWohCiALIARJDQAMCAsLIAdBBGpBAmoiDCAHQQhqQQJqLQAAOgAAIAcgBy8ACDsBBCAAQRBqQQM6AAAgAEEMaiARIA1qNgIAIABBCGogDjYCACAAIA02AgQgAEEBNgIAIAAgBy8BBDsAESAAQRNqIAwtAAA6AAAgB0EgaiQADwsgB0EIakEMaigCACEMIAdBCGpBEGotAAAhAiAHQQJqIhEgB0EEakECai0AADoAACAHIAcvAAQ7AQAgAEEQaiACOgAAIABBDGogDCANajYCACAAQQhqIA42AgAgACANNgIEIABBATYCACAAIAcvAQA7ABEgAEETaiARLQAAOgAAIAdBIGokAA8LIA0gEhCgAQALIBIgBBCeAQALIA4gDBCgAQALIAwgBhCeAQALIAYhCgsgAEEANgIAIAAgCjYCBCAHQSBqJAAL9wYBDH8jAEEgayIHJAACQAJAIARFDQAgA0F/aiEIIAdBEGohCSAGIQpBACELQQAhDAJAAkACQAJAAkACQANAAkACQAJAAkACQCAKIAxJDQAgCiAGSw0BIAdBCGogASACIAMgC2ogBCALayAFIAxqIAogDGsQOyAHKAIIQQFHDQ0gBygCDCALaiINQQRqIQsgDUF8Tw0CIAsgBEsNAyAJKAIAIAxqIQ4gCCANaiEPIAMgDWohEEEAIRECQAJAAkACQAJAA0AgDyESIAIgECARaiIMQQNqLQAAai0AAEGCAUcNASACIAxBAmotAABqLQAAQYIBRw0DIAIgDEEBai0AAGotAABBggFHDQQgAiAMLQAAai0AAEGCAUcNBSASQXxqIQ8gEUF8aiERIAwgEGtBA0sNAAtBACARayEMIBFBfEYNAQNAIAIgEi0AAGotAABBggFHDQIgEkF/aiESIAxBAWoiDEEERw0ADAILC0EAIBFrIQwLQQQgDGsiEUUNCQwHC0EEQQEgEWtrIhENBgwIC0EEQQIgEWtrIhENBQwHC0EEQQMgEWtrIhENBAwGCyAMIAoQoAEACyAKIAYQngEACyANIAsQoAEACyALIAQQngEACyARQQZsIgxBBnFBBkYNASARIA1qIhIgEUkNAyASIARLDQQgDEEDdiISIA5qIgwgEkkNBSAMIAZLDQYgB0EIaiABIAIgECARIAUgDmogEhA7IAcoAghBAUYNAiAKIBJqQX1qIQogCyAESQ0ADAgLCyAHQQRqQQJqIgwgB0EIakECai0AADoAACAHIAcvAAg7AQQgAEEQakEDOgAAIABBDGogESANajYCACAAQQhqIA42AgAgACANNgIEIABBATYCACAAIAcvAQQ7ABEgAEETaiAMLQAAOgAAIAdBIGokAA8LIAdBCGpBDGooAgAhDCAHQQhqQRBqLQAAIQIgB0ECaiIRIAdBBGpBAmotAAA6AAAgByAHLwAEOwEAIABBEGogAjoAACAAQQxqIAwgDWo2AgAgAEEIaiAONgIAIAAgDTYCBCAAQQE2AgAgACAHLwEAOwARIABBE2ogES0AADoAACAHQSBqJAAPCyANIBIQoAEACyASIAQQngEACyAOIAwQoAEACyAMIAYQngEACyAGIQoLIABBADYCACAAIAo2AgQgB0EgaiQAC48HAQx/IwBBIGsiBiQAAkACQCADRQ0AIAJBf2ohByAGQRBqIQggBSEJQQAhCkEAIQsCQAJAAkACQAJAAkACQANAAkACQAJAAkACQCAJIAtJDQAgCSAFSw0BIAZBCGogASACIApqIAMgCmsgBCALaiAJIAtrEEEgBigCCEEBRw0OIAYoAgwgCmoiDEEEaiEKIAxBfE8NAiAKIANLDQMgCCgCACALaiENIAcgDGohDiACIAxqIQ9BACELAkACQAJAAkACQANAIA4hECABIA8gC2oiEUEDai0AAGotAABBggFHDQEgASARQQJqLQAAai0AAEGCAUcNAyABIBFBAWotAABq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ajYCCAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAGIARHDQAgAEEMaiAAQQhqIAAoAgBBAUYbKAIAIgZBgQRNDQEgACgCBCIALQCBBCIHQQdxQX9qIghBBUsNAgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAgOBgAEAgMBBQALIAAsAIAEIQkgB0EIcQ0IIAlBAEgNESAGQYQETw0dIAJBA3QiByAESw0zAkAgAkUNACADQQdqIQYDQCAGQXlqIAAgAS0AACIIai0AADoAACAGQXpqIAAgCEEBdmotAAA6AAAgBkF7aiAAIAhBAnZqLQAAOgAAIAZBfGogACAIQQN2ai0AADoAACAGQX1qIAAgCEEEdmotAAA6AAAgBkF+aiAAIAhBBXZqLQAAOgAAIAZBf2ogACAIQQZ2ai0AADoAACAGIAAgCEEHdmotAAA6AAAgAUEBaiEBIAZBCGohBiACQX9qIgINAAsLIAcgBE8NLwNAIAMgB2ogCToAACAHQQFqIgcgBEkNAAwwCwsgACwAgAQhCCAHQQhxDQQgCEEASA0KIAZBhARPDRYgAkEDdEEEckEFbiIGIARLDTMgACABIAIgAyAGEDQgBiAETw0uA0AgAyAGaiAIOgAAIAZBAWoiBiAESQ0ADC8LCyAALACABCEIIAdBCHENBCAIQQBIDQsgBkGEBE8NFyACQQN0QQJyQQNuIgYgBEsNMyAAIAEgAiADIAYQNSAGIARPDS0DQCADIAZqIAg6AAAgBkEBaiIGIARJDQAMLgsLIAAsAIAEIQkgB0EIcQ0EIAlBAEgNDCAGQYQETw0YIAJBAXQiCkH+////A3EiCCAESw0zAkAgAkUNACADIQYDQCAGIAAgAS0AACIHai0AADoAACAGQQFqIAAgB0EEdmotAAA6AAAgAUEBaiEBIAZBAmohBiACQX9qIgINAAsLIAggCkkNNAJAIAggCmsiBkUNACADIApqIAAtAAAgBhDVARoLIAggBE8NLANAIAMgCGogCToAACAIQQFqIgggBEkNAAwtCwsgACwAgAQhCSAHQQhxDQUgCUEASA0OIAZBhARPDRogAkECdCIKQfz///8HcSIHIARLDTQCQCACRQ0AIAMhBgNAIAYgACABLQAAIghqLQAAOgAAIAZBAWogACAIQQJ2ai0AADoAACAGQQJqIAAgCEEEdmotAAA6AAAgBkEDaiAAIAhBBnZqLQAAOgAAIAFBAWohASAGQQRqIQYgAkF/aiICDQALCyAHIApJDTUCQCAHIAprIgZFDQAgAyAKaiAALQAAIAYQ1QEaCyAHIARPDSsDQCADIAdqIAk6AAAgB0EBaiIHIARJDQAMLAsLIAAsAIAEIQggB0EIcQ0FIAhBAEgNECAGQYQETw0cIAJBA3RBBHJBBm4iBiAESw01IAAgASACIAMgBhA4IAYgBE8NKgNAIAMgBmogCDoAACAGQQFqIgYgBEkNAAwrCwsgCEEASA0GIAZBhARPDRIgAkEDdEEEckEFbiIGIARLDTUgACABIAIgAyAGEDcgBiAETw0pA0AgAyAGaiAIOgAAIAZBAWoiBiAESQ0ADCoLCyAIQQBIDQcgBkGEBE8NEyACQQN0QQJyQQNuIgYgBEsNNSAAIAEgAiADIAYQNiAGIARPDSgDQCADIAZqIAg6AAAgBkEBaiIGIARJDQAMKQsLIAlBAEgNCCAGQYQETw0UIAJBAXQiCkH+////A3EiCCAESw01AkAgAkUNACADIQYDQCAGQQFqIAAgAS0AACIHai0AADoAACAGIAAgB0EEdmotAAA6AAAgAUEBaiEBIAZBAmohBiACQX9qIgINAAsLIAggCkkNNgJAIAggCmsiBkUNACADIApqIAAtAAAgBhDVARoLIAggBE8NJwNAIAMgCGogCToAACAIQQFqIgggBEkNAAwoCwsgCUEASA0KIAZBhARPDRYgAkEDdCIHIARLDTYCQCACRQ0AIANBB2ohBgNAIAYgACABLQAAIghqLQAAOgAAIAZBeWogACAIQQd2ai0AADoAACAGQXpqIAAgCEEGdmotAAA6AAAgBkF7aiAAIAhBBXZqLQAAOgAAIAZBfGogACAIQQR2ai0AADoAACAGQX1qIAAgCEEDdmotAAA6AAAgBkF+aiAAIAhBAnZqLQAAOgAAIAZBf2ogACAIQQF2ai0AADoAACABQQFqIQEgBkEIaiEGIAJBf2oiAg0ACwsgByAETw0mA0AgAyAHaiAJOgAAIAdBAWoiByAESQ0ADCcLCyAJQQBIDQogBkGEBE8NFiACQQJ0IgpB/P///wdxIgcgBEsNNgJAIAJFDQAgAyEGA0AgBkEDaiAAIAEtAAAiCGotAAA6AAAgBiAAIAhBBnZqLQAAOgAAIAZBAWogACAIQQR2ai0AADoAACAGQQJqIAAgCEECdmotAAA6AAAgAUEBaiEBIAZBBGohBiACQX9qIgINAAsLIAcgCkkNNwJAIAcgCmsiBkUNACADIApqIAAtAAAgBhDVARoLIAcgBE8NJQNAIAMgB2ogCToAACAHQQFqIgcgBEkNAAwmCwsgCEEASA0LIAZBhARPDRcgAkEDdEEEckEGbiIGIARLDTcgACABIAIgAyAGEDkgBiAETw0kA0AgAyAGaiAIOgAAIAZBAWoiBiAESQ0ADCULCyAGQYQETw0XIAAgASACIAMgBBA0IAVB4ABqJAAPCyAGQYQETw0XIAAgASACIAMgBBA3IAVB4ABqJAAPCyAGQYQETw0XIAAgASACIAMgBBA1IAVB4ABqJAAPCyAGQYQETw0XIAAgASACIAMgBBA2IAVB4ABqJAAPCyAGQYQETw0XAkAgAkUNACACIQggAyEGA0AgBiAAIAEtAAAiB2otAAA6AAAgBkEBaiAAIAdBBHZqLQAAOgAAIAFBAWohASAGQQJqIQYgCEF/aiIIDQALCyACQQF0IgYgBEsNPyAEIAZrIghFDR8gAyAGaiAALQAAIAgQ1QEaIAVB4ABqJAAPCyAGQYQETw0XAkAgAkUNACACIQggAyEGA0AgBkEBaiAAIAEtAAAiB2otAAA6AAAgBiAAIAdBBHZqLQAAOgAAIAFBAWohASAGQQJqIQYgCEF/aiIIDQALCyACQQF0IgYgBEsNPyAEIAZrIghFDR4gAyAGaiAALQAAIAgQ1QEaIAVB4ABqJAAPCyAGQYQETw0XAkAgAkUNACADQQdqIQYgAiEHA0AgBkF5aiAAIAEtAAAiCGotAAA6AAAgBkF6aiAAIAhBAXZqLQAAOgAAIAZBe2ogACAIQQJ2ai0AADoAACAGQXxqIAAgCEEDdmotAAA6AAAgBkF9aiAAIAhBBHZqLQAAOgAAIAZBfmogACAIQQV2ai0AADoAACAGQX9qIAAgCEEGdmotAAA6AAAgBiAAIAhBB3ZqLQAAOgAAIAFBAWohASAGQQhqIQYgB0F/aiIHDQALCyACQQN0IgYgBEsNPyAEIAZrIghFDR0gAyAGaiAALQAAIAgQ1QEaIAVB4ABqJAAPCyAGQYQETw0XAkAgAkUNACACIQcgAyEGA0AgBiAAIAEtAAAiCGotAAA6AAAgBkEBaiAAIAhBAnZqLQAAOgAAIAZBAmogACAIQQR2ai0AADoAACAGQQNqIAAgCEEGdmotAAA6AAAgAUEBaiEBIAZBBGohBiAHQX9qIgcNAAsLIAJBAnQiBiAESw0/IAQgBmsiCEUNHCADIAZqIAAtAAAgCBDVARogBUHgAGokAA8LIAZBhARPDRcCQCACRQ0AIANBB2ohBiACIQcDQCAGIAAgAS0AACIIai0AADoAACAGQXlqIAAgCEEHdmotAAA6AAAgBkF6aiAAIAhBBnZqLQAAOgAAIAZBe2ogACAIQQV2ai0AADoAACAGQXxqIAAgCEEEdmotAAA6AAAgBkF9aiAAIAhBA3ZqLQAAOgAAIAZBfmogACAIQQJ2ai0AADoAACAGQX9qIAAgCEEBdmotAAA6AAAgAUEBaiEBIAZBCGohBiAHQX9qIgcNAAsLIAJBA3QiBiAESw0/IAQgBmsiCEUNGyADIAZqIAAtAAAgCBDVARogBUHgAGokAA8LIAZBhARPDRcCQCACRQ0AIAIhByADIQYDQCAGQQNqIAAgAS0AACIIai0AADoAACAGIAAgCEEGdmotAAA6AAAgBkEBaiAAIAhBBHZqLQAAOgAAIAZBAmogACAIQQJ2ai0AADoAACABQQFqIQEgBkEEaiEGIAdBf2oiBw0ACwsgAkECdCIGIARLDT8gBCAGayIIRQ0aIAMgBmogAC0AACAIENUBGiAFQeAAaiQADwsgBkGEBE8NFyAAIAEgAiADIAQQOCAFQeAAaiQADwsgBkGEBE8NFyAAIAEgAiADIAQQOSAFQeAAaiQADwsgAC0AggQiB0EDdiIJRQ0rIAdB+AFxIgogBkH9e2oiC2ohDCAAQYMEaiENIAIgCUEFbCIJbiEOAkAgCSACSw0AIAwgCkkNSkEAIQ8gAyEGIAEhBwNAIAAgByAJIAYgChA0IAYgCmogDSALENYBGiAGIAxqIQYgByAJaiEHIA9BAWoiDyAOSQ0ACwsgDiAJbCIJIAJPDRcgAiAJayIPQQRqQQVuQQN0IgcgDiAMbCICaiIKIAdJDUogCiAESw1LIA9BA3RBBHJBBW4iBiAHSw1MIAAgASAJaiAPIAMgAmoiCSAGEDQCQCAGIAdPDQADQCAJIAZqIAg6AAAgBkEBaiIGIAdJDQALCyAFIAQgCmsiADYCICAFIAs2AiQgBSAFQSBqNgIoIAUgBUEkajYCLCAAIAtHDU0gAyAKaiANIAsQ1gEaIAVB4ABqJAAPCyAALQCCBCIHQQN2IglFDSsgB0H4AXEiCiAGQf17aiILaiEMIABBgwRqIQ0gAiAJQQVsIgluIQ4CQCAJIAJLDQAgDCAKSQ1OQQAhDyADIQYgASEHA0AgACAHIAkgBiAKEDcgBiAKaiANIAsQ1gEaIAYgDGohBiAHIAlqIQcgD0EBaiIPIA5JDQALCyAOIAlsIgkgAk8NFiACIAlrIg9BBGpBBW5BA3QiByAOIAxsIgJqIgogB0kNTiAKIARLDU8gD0EDdEEEckEFbiIGIAdLDVAgACABIAlqIA8gAyACaiIJIAYQNwJAIAYgB08NAANAIAkgBmogCDoAACAGQQFqIgYgB0kNAAsLIAUgBCAKayIANgIgIAUgCzYCJCAFIAVBIGo2AiggBSAFQSRqNgIsIAAgC0cNUSADIApqIA0gCxDWARogBUHgAGokAA8LIAAtAIIEIgdBA3YiCUUNKyAHQfgBcSIKIAZB/XtqIgtqIQwgAEGDBGohDSACIAlBA2wiCW4hDgJAIAkgAksNACAMIApJDVJBACEPIAMhBiABIQcDQCAAIAcgCSAGIAoQNSAGIApqIA0gCxDWARogBiAMaiEGIAcgCWohByAPQQFqIg8gDkkNAAsLIA4gCWwiCSACTw0VIAIgCWsiD0ECakEDbkEDdCIHIA4gDGwiAmoiCiAHSQ1SIAogBEsNUyAPQQN0QQJyQQNuIgYgB0sNVCAAIAEgCWogDyADIAJqIgkgBhA1AkAgBiAHTw0AA0AgCSAGaiAIOgAAIAZBAWoiBiAHSQ0ACwsgBSAEIAprIgA2AiAgBSALNgIkIAUgBUEgajYCKCAFIAVBJGo2AiwgACALRw1VIAMgCmogDSALENYBGiAFQeAAaiQADwsgAC0AggQiB0EDdiIJRQ0rIAdB+AFxIgogBkH9e2oiC2ohDCAAQYMEaiENIAIgCUEDbCIJbiEOAkAgCSACSw0AIAwgCkkNVkEAIQ8gAyEGIAEhBwNAIAAgByAJIAYgChA2IAYgCmogDSALENYBGiAGIAxqIQYgByAJaiEHIA9BAWoiDyAOSQ0ACwsgDiAJbCIJIAJPDRQgAiAJayIPQQJqQQNuQQN0IgcgDiAMbCICaiIKIAdJDVYgCiAESw1XIA9BA3RBAnJBA24iBiAHSw1YIAAgASAJaiAPIAMgAmoiCSAGEDYCQCAGIAdPDQADQCAJIAZqIAg6AAAgBkEBaiIGIAdJDQALCyAFIAQgCmsiADYCICAFIAs2AiQgBSAFQSBqNgIoIAUgBUEkajYCLCAAIAtHDVkgAyAKaiANIAsQ1gEaIAVB4ABqJAAPCyAALQCCBCIIQQF2Ig5FDSsgCEH+AXEiECAGQf17aiIRaiEMIABBgwRqIRIgAiAObiETAkAgDiACSw0AIAwgEEkNWiADQQFqIQpBACEPIAEhCwNAIAMgDyAMbGohDSAOIQcgCyEIIAohBgNAIAZBf2ogACAILQAAIglqLQAAOgAAIAYgACAJQQR2ai0AADoAACAIQQFqIQggBkECaiEGIAdBf2oiBw0ACyANIBBqIBIgERDWARogCyAOaiELIAogDGohCiAPQQFqIg8gE0kNAAsLIBMgDmwiBiACTw0TIAIgBmsiCUEBdCIPIBMgDGwiCGoiAiAPSQ1aIAIgBEsNWyAPQf7///8DcSELIAMgCGohCgJAIAlFDQAgASAGaiEBQQAhBgNAIAogBkEBdGoiCCAAIAEgBmotAAAiB2otAAA6AAAgCCAAIAdBBHZqLQAAOgABIAZBAWoiBiAJRw0ACwsgCyAPSQ1cAkAgCyAPayIGRQ0AIAogD2ogAC0AACAGENUBGgsgBSAEIAJrIgA2AiAgBSARNgIkIAUgBUEgajYCKCAFIAVBJGo2AiwgACARRw1dIAMgAmogEiARENYBGiAFQeAAaiQADwsgAC0AggQiCEEBdiIORQ0rIAhB/gFxIhAgBkH9e2oiEWohDCAAQYMEaiESIAIgDm4hEwJAIA4gAksNACAMIBBJDV4gA0EBaiEKQQAhDyABIQsDQCADIA8gDGxqIQ0gDiEHIAshCCAKIQYDQCAGIAAgCC0AACIJai0AADoAACAGQX9qIAAgCUEEdmotAAA6AAAgCEEBaiEIIAZBAmohBiAHQX9qIgcNAAsgDSAQaiASIBEQ1gEaIAsgDmohCyAKIAxqIQogD0EBaiIPIBNJDQALCyATIA5sIgYgAk8NEiACIAZrIglBAXQiDyATIAxsIghqIgIgD0kNXiACIARLDV8gD0H+////A3EhCyADIAhqIQoCQCAJRQ0AIAEgBmohAUEAIQYDQCAKIAZBAXRqIgggACABIAZqLQAAIgdqLQAAOgABIAggACAHQQR2ai0AADoAACAGQQFqIgYgCUcNAAsLIAsgD0kNYAJAIAsgD2siBkUNACAKIA9qIAAtAAAgBhDVARoLIAUgBCACayIANgIgIAUgETYCJCAFIAVBIGo2AiggBSAFQSRqNgIsIAAgEUcNYSADIAJqIBIgERDWARogBUHgAGokAA8LIAAtAIIEIghBA3YiEUUNKyAIQfgBcSIPIAZB/XtqIhNqIQwgAEGDBGohEiACIBFuIRACQCARIAJLDQAgDCAPSQ1iQQAhCyADIQogASEOA0AgAyALIAxsaiENQQAhByAOIQkDQCAKIAdqIgYgACAJLQAAIghqLQAAOgAAIAZBAWogACAIQQF2ai0AADoAACAGQQJqIAAgCEECdmotAAA6AAAgBkEDaiAAIAhBA3ZqLQAAOgAAIAZBBGogACAIQQR2ai0AADoAACAGQQVqIAAgCEEFdmotAAA6AAAgBkEGaiAAIAhBBnZqLQAAOgAAIAZBB2ogACAIQQd2ai0AADoAACAJQQFqIQkgDyAHQQhqIgdHDQALIA0gD2ogEiATENYBGiAKIAxqIQogDiARaiEOIAtBAWoiCyAQSQ0ACwsgECARbCIGIAJPDREgAiAGayIJQQN0IgggECAMbCIHaiIPIAhJDWIgDyAESw1jAkAgCUUNACABIAZqIQEgAyAHaiEKQQAhBwNAIAogB0EDdGoiBiAAIAEgB2otAAAiCGotAAA6AAAgBiAAIAhBAXZqLQAAOgABIAYgACAIQQJ2ai0AADoAAiAGIAAgCEEDdmotAAA6AAMgBiAAIAhBBHZqLQAAOgAEIAYgACAIQQV2ai0AADoABSAGIAAgCEEGdmotAAA6AAYgBiAAIAhBB3ZqLQAAOgAHIAdBAWoiByAJRw0ACwsgBSAEIA9rIgA2AiAgBSATNgIkIAUgBUEgajYCKCAFIAVBJGo2AiwgACATRw1kIAMgD2ogEiATENYBGiAFQeAAaiQADwsgAC0AggQiCEECdiIORQ0rIAhB/AFxIhAgBkH9e2oiEWohDCAAQYMEaiESIAIgDm4hEwJAIA4gAksNACAMIBBJDWUgA0EDaiEKQQAhDyABIQsDQCADIA8gDGxqIQ0gDiEJIAshByAKIQYDQCAGQX1qIAAgBy0AACIIai0AADoAACAGQX5qIAAgCEECdmotAAA6AAAgBkF/aiAAIAhBBHZqLQAAOgAAIAYgACAIQQZ2ai0AADoAACAHQQFqIQcgBkEEaiEGIAlBf2oiCQ0ACyANIBBqIBIgERDWARogCyAOaiELIAogDGohCiAPQQFqIg8gE0kNAAsLIBMgDmwiBiACTw0QIAIgBmsiCUECdCIPIBMgDGwiCGoiAiAPSQ1lIAIgBEsNZiAPQfz///8HcSELIAMgCGohCgJAIAlFDQAgASAGaiEBQQAhBgNAIAogBkECdGoiCCAAIAEgBmotAAAiB2otAAA6AAAgCCAAIAdBAnZqLQAAOgABIAggACAHQQR2ai0AADoAAiAIIAAgB0EGdmotAAA6AAMgBkEBaiIGIAlHDQALCyALIA9JDWcCQCALIA9rIgZFDQAgCiAPaiAALQAAIAYQ1QEaCyAFIAQgAmsiADYCICAFIBE2AiQgBSAFQSBqNgIoIAUgBUEkajYCLCAAIBFHDWggAyACaiASIBEQ1gEaIAVB4ABqJAAPCyAALQCCBCIIQQN2IhFFDSsgCEH4AXEiDyAGQf17aiITaiEMIABBgwRqIRIgAiARbiEQAkAgESACSw0AIAwgD0kNaUEAIQsgAyEKIAEhDgNAIAMgCyAMbGohDUEAIQcgDiEJA0AgCiAHaiIGQQdqIAAgCS0AACIIai0AADoAACAGIAAgCEEHdmotAAA6AAAgBkEBaiAAIAhBBnZqLQAAOgAAIAZBAmogACAIQQV2ai0AADoAACAGQQNqIAAgCEEEdmotAAA6AAAgBkEEaiAAIAhBA3ZqLQAAOgAAIAZBBWogACAIQQJ2ai0AADoAACAGQQZqIAAgCEEBdmotAAA6AAAgCUEBaiEJIA8gB0EIaiIHRw0ACyANIA9qIBIgExDWARogCiAMaiEKIA4gEWohDiALQQFqIgsgEEkNAAsLIBAgEWwiBiACTw0PIAIgBmsiCUEDdCIIIBAgDGwiB2oiDyAISQ1pIA8gBEsNagJAIAlFDQAgASAGaiEBIAMgB2ohCkEAIQcDQCAKIAdBA3RqIgYgACABIAdqLQAAIghqLQAAOgAHIAYgACAIQQd2ai0AADoAACAGIAAgCEEGdmotAAA6AAEgBiAAIAhBBXZqLQAAOgACIAYgACAIQQR2ai0AADoAAyAGIAAgCEEDdmotAAA6AAQgBiAAIAhBAnZqLQAAOgAFIAYgACAIQQF2ai0AADoABiAHQQFqIgcgCUcNAAsLIAUgBCAPayIANgIgIAUgEzYCJCAFIAVBIGo2AiggBSAFQSRqNgIsIAAgE0cNayADIA9qIBIgExDWARogBUHgAGokAA8LIAAtAIIEIghBAnYiDkUNKyAIQfwBcSIQIAZB/XtqIhFqIQwgAEGDBGohEiACIA5uIRMCQCAOIAJLDQAgDCAQSQ1sIANBA2ohCkEAIQ8gASELA0AgAyAPIAxsaiENIA4hCSALIQcgCiEGA0AgBiAAIActAAAiCGotAAA6AAAgBkF9aiAAIAhBBnZqLQAAOgAAIAZBfmogACAIQQR2ai0AADoAACAGQX9qIAAgCEECdmotAAA6AAAgB0EBaiEHIAZBBGohBiAJQX9qIgkNAAsgDSAQaiASIBEQ1gEaIAsgDmohCyAKIAxqIQogD0EBaiIPIBNJDQALCyATIA5sIgYgAk8NDiACIAZrIglBAnQiDyATIAxsIghqIgIgD0kNbCACIARLDW0gD0H8////B3EhCyADIAhqIQoCQCAJRQ0AIAEgBmohAUEAIQYDQCAKIAZBAnRqIgggACABIAZqLQAAIgdqLQAAOgADIAggACAHQQZ2ai0AADoAACAIIAAgB0EEdmotAAA6AAEgCCAAIAdBAnZqLQAAOgACIAZBAWoiBiAJRw0ACwsgCyAPSQ1uAkAgCyAPayIGRQ0AIAogD2ogAC0AACAGENUBGgsgBSAEIAJrIgA2AiAgBSARNgIkIAUgBUEgajYCKCAFIAVBJGo2AiwgACARRw1vIAMgAmogEiARENYBGiAFQeAAaiQADwsgAC0AggQiB0ECdiIJRQ0rIAdB/AFxIgogBkH9e2oiC2ohDCAAQYMEaiENIAIgCUEDbCIJbiEOAkAgCSACSw0AIAwgCkkNcEEAIQ8gAyEGIAEhBwNAIAAgByAJIAYgChA4IAYgCmogDSALENYBGiAGIAxqIQYgByAJaiEHIA9BAWoiDyAOSQ0ACwsgDiAJbCIJIAJPDQ0gAiAJayIPQQJqQQNuQQJ0IgcgDiAMbCICaiIKIAdJDXAgCiAESw1xIA9BA3RBBHJBBm4iBiAHSw1yIAAgASAJaiAPIAMgAmoiCSAGEDgCQCAGIAdPDQADQCAJIAZqIAg6AAAgBkEBaiIGIAdJDQALCyAFIAQgCmsiADYCICAFIAs2AiQgBSAFQSBqNgIoIAUgBUEkajYCLCAAIAtHDXMgAyAKaiANIAsQ1gEaIAVB4ABqJAAPCyAALQCCBCIHQQJ2IglFDSsgB0H8AXEiCiAGQf17aiILaiEMIABBgwRqIQ0gAiAJQQNsIgluIQ4CQCAJIAJLDQAgDCAKSQ10QQAhDyADIQYgASEHA0AgACAHIAkgBiAKEDkgBiAKaiANIAsQ1gEaIAYgDGohBiAHIAlqIQcgD0EBaiIPIA5JDQALCyAOIAlsIgkgAk8NDCACIAlrIg9BAmpBA25BAnQiByAOIAxsIgJqIgogB0kNdCAKIARLDXUgD0EDdEEEckEGbiIGIAdLDXYgACABIAlqIA8gAyACaiIJIAYQOQJAIAYgB08NAANAIAkgBmogCDoAACAGQQFqIgYgB0kNAAsLIAUgBCAKayIANgIgIAUgCzYCJCAFIAVBIGo2AiggBSAFQSRqNgIsIAAgC0cNdyADIApqIA0gCxDWARogBUHgAGokAA8LIAAtAIIEIghBA3YiB0UNMSAIQfgBcSIJIAZB/XtqIg9qIQ4gAEGDBGohDCACIAdBBWwiB24hCwJAIAcgAksNACAOIAlJDXhBACEKIAMhBiABIQgDQCAAIAggByAGIAkQNCAGIAlqIAwgDxDWARogBiAOaiEGIAggB2ohCCAKQQFqIgogC0kNAAsLIAsgB2wiBiACTw0LIAIgBmsiCUEDdEEEckEFbiIHIAsgDmwiCmoiCCAHSQ14IAggBEsNeSAAIAEgBmogCSADIApqIAcQNCAFIAQgCGsiADYCICAFIA82AiQgBSAFQSBqNgIoIAUgBUEkajYCLCAAIA9HDXogAyAIaiAMIA8Q1gEaIAVB4ABqJAAPCyAALQCCBCIIQQN2IgdFDTEgCEH4AXEiCSAGQf17aiIPaiEOIABBgwRqIQwgAiAHQQVsIgduIQsCQCAHIAJLDQAgDiAJSQ17QQAhCiADIQYgASEIA0AgACAIIAcgBiAJEDcgBiAJaiAMIA8Q1gEaIAYgDmohBiAIIAdqIQggCkEBaiIKIAtJDQALCyALIAdsIgYgAk8NCiACIAZrIglBA3RBBHJBBW4iByALIA5sIgpqIgggB0kNeyAIIARLDXwgACABIAZqIAkgAyAKaiAHEDcgBSAEIAhrIgA2AiAgBSAPNgIkIAUgBUEgajYCKCAFIAVBJGo2AiwgACAPRw19IAMgCGogDCAPENYBGiAFQeAAaiQADwsgAC0AggQiCEEDdiIHRQ0xIAhB+AFxIgkgBkH9e2oiD2ohDiAAQYMEaiEMIAIgB0EDbCIHbiELAkAgByACSw0AIA4gCUkNfkEAIQogAyEGIAEhCANAIAAgCCAHIAYgCRA1IAYgCWogDCAPENYBGiAGIA5qIQYgCCAHaiEIIApBAWoiCiALSQ0ACwsgCyAHbCIGIAJPDQkgAiAGayIJQQN0QQJyQQNuIgcgCyAObCIKaiIIIAdJDX4gCCAESw1/IAAgASAGaiAJIAMgCmogBxA1IAUgBCAIayIANgIgIAUgDzYCJCAFIAVBIGo2AiggBSAFQSRqNgIsIAAgD0cNgAEgAyAIaiAMIA8Q1gEaIAVB4ABqJAAPCyAALQCCBCIIQQN2IgdFDTEgCEH4AXEiCSAGQf17aiIPaiEOIABBgwRqIQwgAiAHQQNsIgduIQsCQCAHIAJLDQAgDiAJSQ2BAUEAIQogAyEGIAEhCANAIAAgCCAHIAYgCRA2IAYgCWogDCAPENYBGiAGIA5qIQYgCCAHaiEIIApBAWoiCiALSQ0ACwsgCyAHbCIGIAJPDQggAiAGayIJQQN0QQJyQQNuIgcgCyAObCIKaiIIIAdJDYEBIAggBEsNggEgACABIAZqIAkgAyAKaiAHEDYgBSAEIAhrIgA2AiAgBSAPNgIkIAUgBUEgajYCKCAFIAVBJGo2AiwgACAPRw2DASADIAhqIAwgDxDWARogBUHgAGokAA8LIAAtAIIEIghBAXYiDkUNMSAIQf4BcSIQIAZB/XtqIhFqIQwgAEGDBGohEiACIA5uIRMCQCAOIAJLDQAgDCAQSQ2EASADQQFqIQpBACEPIAEhCwNAIAMgDyAMbGohDSAOIQcgCyEIIAohBgNAIAZBf2ogACAILQAAIglqLQAAOgAAIAYgACAJQQR2ai0AADoAACAIQQFqIQggBkECaiEGIAdBf2oiBw0ACyANIBBqIBIgERDWARogCyAOaiELIAogDGohCiAPQQFqIg8gE0kNAAsLIBMgDmwiBiACTw0HIAIgBmsiCUEBdCILQf7///8DcSIPIBMgDGwiCGoiAiAPSQ2EASACIARLDYUBIAMgCGohCgJAIAlFDQAgASAGaiEBQQAhBgNAIAogBkEBdGoiCCAAIAEgBmotAAAiB2otAAA6AAAgCCAAIAdBBHZqLQAAOgABIAZBAWoiBiAJRw0ACwsgDyALSQ2GAQJAIA8gC2siBkUNACAKIAtqIAAtAAAgBhDVARoLIAUgBCACayIANgIgIAUgETYCJCAFIAVBIGo2AiggBSAFQSRqNgIsIAAgEUcNhwEgAyACaiASIBEQ1gEaIAVB4ABqJAAPCyAALQCCBCIIQQF2Ig5FDTEgCEH+AXEiECAGQf17aiIRaiEMIABBgwRqIRIgAiAObiETAkAgDiACSw0AIAwgEEkNiAEgA0EBaiEKQQAhDyABIQsDQCADIA8gDGxqIQ0gDiEHIAshCCAKIQYDQCAGIAAgCC0AACIJai0AADoAACAGQX9qIAAgCUEEdmotAAA6AAAgCEEBaiEIIAZBAmohBiAHQX9qIgcNAAsgDSAQaiASIBEQ1gEaIAsgDmohCyAKIAxqIQogD0EBaiIPIBNJDQALCyATIA5sIgYgAk8NBiACIAZrIglBAXQiC0H+////A3EiDyATIAxsIghqIgIgD0kNiAEgAiAESw2JASADIAhqIQoCQCAJRQ0AIAEgBmohAUEAIQYDQCAKIAZBAXRqIgggACABIAZqLQAAIgdqLQAAOgABIAggACAHQQR2ai0AADoAACAGQQFqIgYgCUcNAAsLIA8gC0kNigECQCAPIAtrIgZFDQAgCiALaiAALQAAIAYQ1QEaCyAFIAQgAmsiADYCICAFIBE2AiQgBSAFQSBqNgIoIAUgBUEkajYCLCAAIBFHDYsBIAMgAmogEiARENYBGiAFQeAAaiQADwsgAC0AggQiCEEDdiIRRQ0xIAhB+AFxIg8gBkH9e2oiE2ohDCAAQYMEaiESIAIgEW4hEAJAIBEgAksNACAMIA9JDYwBQQAhCyADIQogASEOA0AgAyALIAxsaiENQQAhByAOIQkDQCAKIAdqIgYgACAJLQAAIghqLQAAOgAAIAZBAWogACAIQQF2ai0AADoAACAGQQJqIAAgCEECdmotAAA6AAAgBkEDaiAAIAhBA3ZqLQAAOgAAIAZBBGogACAIQQR2ai0AADoAACAGQQVqIAAgCEEFdmotAAA6AAAgBkEGaiAAIAhBBnZqLQAAOgAAIAZBB2ogACAIQQd2ai0AADoAACAJQQFqIQkgDyAHQQhqIgdHDQALIA0gD2ogEiATENYBGiAKIAxqIQogDiARaiEOIAtBAWoiCyAQSQ0ACwsgECARbCIGIAJPDQUgAiAGayIJQQN0IgggECAMbCIHaiIPIAhJDYwBIA8gBEsNjQECQCAJRQ0AIAEgBmohASADIAdqIQpBACEHA0AgCiAHQQN0aiIGIAAgASAHai0AACIIai0AADoAACAGIAAgCEEBdmotAAA6AAEgBiAAIAhBAnZqLQAAOgACIAYgACAIQQN2ai0AADoAAyAGIAAgCEEEdmotAAA6AAQgBiAAIAhBBXZqLQAAOgAFIAYgACAIQQZ2ai0AADoABiAGIAAgCEEHdmotAAA6AAcgB0EBaiIHIAlHDQALCyAFIAQgD2siADYCICAFIBM2AiQgBSAFQSBqNgIoIAUgBUEkajYCLCAAIBNHDY4BIAMgD2ogEiATENYBGiAFQeAAaiQADwsgAC0AggQiCEECdiIORQ0xIAhB/AFxIhAgBkH9e2oiEWohDCAAQYMEaiESIAIgDm4hEwJAIA4gAksNACAMIBBJDY8BIANBA2ohCkEAIQ8gASELA0AgAyAPIAxsaiENIA4hCSALIQcgCiEGA0AgBkF9aiAAIActAAAiCGotAAA6AAAgBkF+aiAAIAhBAnZqLQAAOgAAIAZBf2ogACAIQQR2ai0AADoAACAGIAAgCEEGdmotAAA6AAAgB0EBaiEHIAZBBGohBiAJQX9qIgkNAAsgDSAQaiASIBEQ1gEaIAsgDmohCyAKIAxqIQogD0EBaiIPIBNJDQALCyATIA5sIgYgAk8NBCACIAZrIglBAnQiC0H8////B3EiDyATIAxsIghqIgIgD0kNjwEgAiAESw2QASADIAhqIQoCQCAJRQ0AIAEgBmohAUEAIQYDQCAKIAZBAnRqIgggACABIAZqLQAAIgdqLQAAOgAAIAggACAHQQJ2ai0AADoAASAIIAAgB0EEdmotAAA6AAIgCCAAIAdBBnZqLQAAOgADIAZBAWoiBiAJRw0ACwsgDyALSQ2RAQJAIA8gC2siBkUNACAKIAtqIAAtAAAgBhDVARoLIAUgBCACayIANgIgIAUgETYCJCAFIAVBIGo2AiggBSAFQSRqNgIsIAAgEUcNkgEgAyACaiASIBEQ1gEaIAVB4ABqJAAPCyAALQCCBCIIQQN2IhFFDTEgCEH4AXEiDyAGQf17aiITaiEMIABBgwRqIRIgAiARbiEQAkAgESACSw0AIAwgD0kNkwFBACELIAMhCiABIQ4DQCADIAsgDGxqIQ1BACEHIA4hCQNAIAogB2oiBkEHaiAAIAktAAAiCGotAAA6AAAgBiAAIAhBB3ZqLQAAOgAAIAZBAWogACAIQQZ2ai0AADoAACAGQQJqIAAgCEEFdmotAAA6AAAgBkEDaiAAIAhBBHZqLQAAOgAAIAZBBGogACAIQQN2ai0AADoAACAGQQVqIAAgCEECdmotAAA6AAAgBkEGaiAAIAhBAXZqLQAAOgAAIAlBAWohCSAPIAdBCGoiB0cNAAsgDSAPaiASIBMQ1gEaIAogDGohCiAOIBFqIQ4gC0EBaiILIBBJDQALCyAQIBFsIgYgAk8NAyACIAZrIglBA3QiCCAQIAxsIgdqIg8gCEkNkwEgDyAESw2UAQJAIAlFDQAgASAGaiEBIAMgB2ohCkEAIQcDQCAKIAdBA3RqIgYgACABIAdqLQAAIghqLQAAOgAHIAYgACAIQQd2ai0AADoAACAGIAAgCEEGdmotAAA6AAEgBiAAIAhBBXZqLQAAOgACIAYgACAIQQR2ai0AADoAAyAGIAAgCEEDdmotAAA6AAQgBiAAIAhBAnZqLQAAOgAFIAYgACAIQQF2ai0AADoABiAHQQFqIgcgCUcNAAsLIAUgBCAPayIANgIgIAUgEzYCJCAFIAVBIGo2AiggBSAFQSRqNgIsIAAgE0cNlQEgAyAPaiASIBMQ1gEaIAVB4ABqJAAPCyAALQCCBCIIQQJ2Ig5FDTEgCEH8AXEiECAGQf17aiIRaiEMIABBgwRqIRIgAiAObiETAkAgDiACSw0AIAwgEEkNlgEgA0EDaiEKQQAhDyABIQsDQCADIA8gDGxqIQ0gDiEJIAshByAKIQYDQCAGIAAgBy0AACIIai0AADoAACAGQX1qIAAgCEEGdmotAAA6AAAgBkF+aiAAIAhBBHZqLQAAOgAAIAZBf2ogACAIQQJ2ai0AADoAACAHQQFqIQcgBkEEaiEGIAlBf2oiCQ0ACyANIBBqIBIgERDWARogCyAOaiELIAogDGohCiAPQQFqIg8gE0kNAAsLIBMgDmwiBiACTw0CIAIgBmsiCUECdCILQfz///8HcSIPIBMgDGwiCGoiAiAPSQ2WASACIARLDZcBIAMgCGohCgJAIAlFDQAgASAGaiEBQQAhBgNAIAogBkECdGoiCCAAIAEgBmotAAAiB2otAAA6AAMgCCAAIAdBBnZqLQAAOgAAIAggACAHQQR2ai0AADoAASAIIAAgB0ECdmotAAA6AAIgBkEBaiIGIAlHDQALCyAPIAtJDZgBAkAgDyALayIGRQ0AIAogC2ogAC0AACAGENUBGgsgBSAEIAJrIgA2AiAgBSARNgIkIAUgBUEgajYCKCAFIAVBJGo2AiwgACARRw2ZASADIAJqIBIgERDWARogBUHgAGokAA8LIAAtAIIEIghBAnYiB0UNMSAIQfwBcSIJIAZB/XtqIg9qIQ4gAEGDBGohDCACIAdBA2wiB24hCwJAIAcgAksNACAOIAlJDZoBQQAhCiADIQYgASEIA0AgACAIIAcgBiAJEDggBiAJaiAMIA8Q1gEaIAYgDmohBiAIIAdqIQggCkEBaiIKIAtJDQALCyALIAdsIgYgAk8NASACIAZrIglBA3RBBHJBBm4iByALIA5sIgpqIgggB0kNmgEgCCAESw2bASAAIAEgBmogCSADIApqIAcQOCAFIAQgCGsiADYCICAFIA82AiQgBSAFQSBqNgIoIAUgBUEkajYCLCAAIA9HDZwBIAMgCGogDCAPENYBGiAFQeAAaiQADwsgAC0AggQiCEECdiIHRQ0xIAhB/AFxIgkgBkH9e2oiD2ohDiAAQYMEaiEMIAIgB0EDbCIHbiELAkAgByACSw0AIA4gCUkNnQFBACEKIAMhBiABIQgDQCAAIAggByAGIAkQOSAGIAlqIAwgDxDWARogBiAOaiEGIAggB2ohCCAKQQFqIgogC0kNAAsLIAsgB2wiBiACTw0AIAIgBmsiCUEDdEEEckEGbiIHIAsgDmwiCmoiCCAHSQ2dASAIIARLDZ4BIAAgASAGaiAJIAMgCmogBxA5IAUgBCAIayIANgIgIAUgDzYCJCAFIAVBIGo2AiggBSAFQSRqNgIsIAAgD0cNnwEgAyAIaiAMIA8Q1gEaCyAFQeAAaiQADwsgBUE8akENNgIAIAVB3ABqQQI2AgAgBUENNgI0IAVCAzcCTCAFQZi7wAA2AkggBSAFQQhqNgI4IAUgBUEsajYCMCAFIAVBMGo2AlggBUHIAGpBsLvAABBvAAtB+LrAAEGBBCAGEJ0BAAtBzJTAAEEOQcC7wAAQZQALIAcgBBCeAQALIAYgBBCeAQALIAYgBBCeAQALIAggBBCeAQALIAogCBCgAQALIAcgBBCeAQALIAogBxCgAQALIAYgBBCeAQALIAYgBBCeAQALIAYgBBCeAQALIAggBBCeAQALIAogCBCgAQALIAcgBBCeAQALIAcgBBCeAQALIAogBxCgAQALIAYgBBCeAQALQbC6wAAQnwEAC0GwusAAEJ8BAAtBsLrAABCfAQALQbC6wAAQnwEAC0GwusAAEJ8BAAtBsLrAABCfAQALQbC6wAAQnwEAC0GwusAAEJ8BAAtBsLrAABCfAQALQbC6wAAQnwEAC0GwusAAEJ8BAAtBsLrAABCfAQALIAYgBBCgAQALIAYgBBCgAQALIAYgBBCgAQALIAYgBBCgAQALIAYgBBCgAQALIAYgBBCgAQALQbC6wAAQnwEAC0GwusAAEJ8BAAtBsLrAABCfAQALQbC6wAAQnwEAC0GwusAAEJ8BAAtBsLrAABCfAQALQbC6wAAQnwEAC0GwusAAEJ8BAAtBsLrAABCfAQALQbC6wAAQnwEAC0GwusAAEJ8BAAtBsLrAABCfAQALIAogDBCeAQALIAIgChCgAQALIAogBBCeAQALIAYgBxCeAQALIAVByABqQRRqQQA2AgAgBUEIakEUakELNgIAIAVBFGpBDTYCACAFQTBqQRRqQQM2AgAgBUGsl8AANgJYIAVCATcCTCAFQZi9wAA2AkggBUENNgIMIAVCAzcCNCAFQYC9wAA2AjAgBSAFQcgAajYCGCAFIAVBLGo2AhAgBSAFQShqNgIIIAUgBUEIajYCQCAFQTBqQaC9wAAQoQEACyAKIAwQngEACyACIAoQoAEACyAKIAQQngEACyAGIAcQngEACyAFQcgAakEUakEANgIAIAVBCGpBFGpBCzYCACAFQRRqQQ02AgAgBUEwakEUakEDNgIAIAVBrJfAADYCWCAFQgE3AkwgBUGYvcAANgJIIAVBDTYCDCAFQgM3AjQgBUGAvcAANgIwIAUgBUHIAGo2AhggBSAFQSxqNgIQIAUgBUEoajYCCCAFIAVBCGo2AkAgBUEwakGgvcAAEKEBAAsgCiAMEJ4BAAsgAiAKEKABAAsgCiAEEJ4BAAsgBiAHEJ4BAAsgBUHIAGpBFGpBADYCACAFQQhqQRRqQQs2AgAgBUEUakENNgIAIAVBMGpBFGpBAzYCACAFQayXwAA2AlggBUIBNwJMIAVBmL3AADYCSCAFQQ02AgwgBUIDNwI0IAVBgL3AADYCMCAFIAVByABqNgIYIAUgBUEsajYCECAFIAVBKGo2AgggBSAFQQhqNgJAIAVBMGpBoL3AABChAQALIAogDBCeAQALIAIgChCgAQALIAogBBCeAQALIAYgBxCeAQALIAVByABqQRRqQQA2AgAgBUEIakEUakELNgIAIAVBFGpBDTYCACAFQTBqQRRqQQM2AgAgBUGsl8AANgJYIAVCATcCTCAFQZi9wAA2AkggBUENNgIMIAVCAzcCNCAFQYC9wAA2AjAgBSAFQcgAajYCGCAFIAVBLGo2AhAgBSAFQShqNgIIIAUgBUEIajYCQCAFQTBqQaC9wAAQoQEACyAQIAwQngEACyAIIAIQoAEACyACIAQQngEACyAPIAsQoAEACyAFQcgAakEUakEANgIAIAVBCGpBFGpBCzYCACAFQRRqQQ02AgAgBUEwakEUakEDNgIAIAVBrJfAADYCWCAFQgE3AkwgBUGYvcAANgJIIAVBDTYCDCAFQgM3AjQgBUGAvcAANgIwIAUgBUHIAGo2AhggBSAFQSxqNgIQIAUgBUEoajYCCCAFIAVBCGo2AkAgBUEwakGgvcAAEKEBAAsgECAMEJ4BAAsgCCACEKABAAsgAiAEEJ4BAAsgDyALEKABAAsgBUHIAGpBFGpBADYCACAFQQhqQRRqQQs2AgAgBUEUakENNgIAIAVBMGpBFGpBAzYCACAFQayXwAA2AlggBUIBNwJMIAVBmL3AADYCSCAFQQ02AgwgBUIDNwI0IAVBgL3AADYCMCAFIAVByABqNgIYIAUgBUEsajYCECAFIAVBKGo2AgggBSAFQQhqNgJAIAVBMGpBoL3AABChAQALIA8gDBCeAQALIAcgDxCgAQALIA8gBBCeAQALIAVByABqQRRqQQA2AgAgBUEIakEUakELNgIAIAVBFGpBDTYCACAFQTBqQRRqQQM2AgAgBUGsl8AANgJYIAVCATcCTCAFQZi9wAA2AkggBUENNgIMIAVCAzcCNCAFQYC9wAA2AjAgBSAFQcgAajYCGCAFIAVBLGo2AhAgBSAFQShqNgIIIAUgBUEIajYCQCAFQTBqQaC9wAAQoQEACyAQIAwQngEACyAIIAIQoAEACyACIAQQngEACyAPIAsQoAEACyAFQcgAakEUakEANgIAIAVBCGpBFGpBCzYCACAFQRRqQQ02AgAgBUEwakEUakEDNgIAIAVBrJfAADYCWCAFQgE3AkwgBUGYvcAANgJIIAVBDTYCDCAFQgM3AjQgBUGAvcAANgIwIAUgBUHIAGo2AhggBSAFQSxqNgIQIAUgBUEoajYCCCAFIAVBCGo2AkAgBUEwakGgvcAAEKEBAAsgDyAMEJ4BAAsgByAPEKABAAsgDyAEEJ4BAAsgBUHIAGpBFGpBADYCACAFQQhqQRRqQQs2AgAgBUEUakENNgIAIAVBMGpBFGpBAzYCACAFQayXwAA2AlggBUIBNwJMIAVBmL3AADYCSCAFQQ02AgwgBUIDNwI0IAVBgL3AADYCMCAFIAVByABqNgIYIAUgBUEsajYCECAFIAVBKGo2AgggBSAFQQhqNgJAIAVBMGpBoL3AABChAQALIBAgDBCeAQALIAggAhCgAQALIAIgBBCeAQALIA8gCxCgAQALIAVByABqQRRqQQA2AgAgBUEIakEUakELNgIAIAVBFGpBDTYCACAFQTBqQRRqQQM2AgAgBUGsl8AANgJYIAVCATcCTCAFQZi9wAA2AkggBUENNgIMIAVCAzcCNCAFQYC9wAA2AjAgBSAFQcgAajYCGCAFIAVBLGo2AhAgBSAFQShqNgIIIAUgBUEIajYCQCAFQTBqQaC9wAAQoQEACyAKIAwQngEACyACIAoQoAEACyAKIAQQngEACyAGIAcQngEACyAFQcgAakEUakEANgIAIAVBCGpBFGpBCzYCACAFQRRqQQ02AgAgBUEwakEUakEDNgIAIAVBrJfAADYCWCAFQgE3AkwgBUGYvcAANgJIIAVBDTYCDCAFQgM3AjQgBUGAvcAANgIwIAUgBUHIAGo2AhggBSAFQSxqNgIQIAUgBUEoajYCCCAFIAVBCGo2AkAgBUEwakGgvcAAEKEBAAsgCiAMEJ4BAAsgAiAKEKABAAsgCiAEEJ4BAAsgBiAHEJ4BAAsgBUHIAGpBFGpBADYCACAFQQhqQRRqQQs2AgAgBUEUakENNgIAIAVBMGpBFGpBAzYCACAFQayXwAA2AlggBUIBNwJMIAVBmL3AADYCSCAFQQ02AgwgBUIDNwI0IAVBgL3AADYCMCAFIAVByABqNgIYIAUgBUEsajYCECAFIAVBKGo2AgggBSAFQQhqNgJAIAVBMGpBoL3AABChAQALIAkgDhCeAQALIAogCBCgAQALIAggBBCeAQALIAVByABqQRRqQQA2AgAgBUEIakEUakELNgIAIAVBFGpBDTYCACAFQTBqQRRqQQM2AgAgBUGsl8AANgJYIAVCATcCTCAFQZi9wAA2AkggBUENNgIMIAVCAzcCNCAFQYC9wAA2AjAgBSAFQcgAajYCGCAFIAVBLGo2AhAgBSAFQShqNgIIIAUgBUEIajYCQCAFQTBqQaC9wAAQoQEACyAJIA4QngEACyAKIAgQoAEACyAIIAQQngEACyAFQcgAakEUakEANgIAIAVBCGpBFGpBCzYCACAFQRRqQQ02AgAgBUEwakEUakEDNgIAIAVBrJfAADYCWCAFQgE3AkwgBUGYvcAANgJIIAVBDTYCDCAFQgM3AjQgBUGAvcAANgIwIAUgBUHIAGo2AhggBSAFQSxqNgIQIAUgBUEoajYCCCAFIAVBCGo2AkAgBUEwakGgvcAAEKEBAAsgCSAOEJ4BAAsgCiAIEKABAAsgCCAEEJ4BAAsgBUHIAGpBFGpBADYCACAFQQhqQRRqQQs2AgAgBUEUakENNgIAIAVBMGpBFGpBAzYCACAFQayXwAA2AlggBUIBNwJMIAVBmL3AADYCSCAFQQ02AgwgBUIDNwI0IAVBgL3AADYCMCAFIAVByABqNgIYIAUgBUEsajYCECAFIAVBKGo2AgggBSAFQQhqNgJAIAVBMGpBoL3AABChAQALIAkgDhCeAQALIAogCBCgAQALIAggBBCeAQALIAVByABqQRRqQQA2AgAgBUEIakEUakELNgIAIAVBFGpBDTYCACAFQTBqQRRqQQM2AgAgBUGsl8AANgJYIAVCATcCTCAFQZi9wAA2AkggBUENNgIMIAVCAzcCNCAFQYC9wAA2AjAgBSAFQcgAajYCGCAFIAVBLGo2AhAgBSAFQShqNgIIIAUgBUEIajYCQCAFQTBqQaC9wAAQoQEACyAQIAwQngEACyAIIAIQoAEACyACIAQQngEACyALIA8QoAEACyAFQcgAakEUakEANgIAIAVBCGpBFGpBCzYCACAFQRRqQQ02AgAgBUEwakEUakEDNgIAIAVBrJfAADYCWCAFQgE3AkwgBUGYvcAANgJIIAVBDTYCDCAFQgM3AjQgBUGAvcAANgIwIAUgBUHIAGo2AhggBSAFQSxqNgIQIAUgBUEoajYCCCAFIAVBCGo2AkAgBUEwakGgvcAAEKEBAAsgECAMEJ4BAAsgCCACEKABAAsgAiAEEJ4BAAsgCyAPEKABAAsgBUHIAGpBFGpBADYCACAFQQhqQRRqQQs2AgAgBUEUakENNgIAIAVBMGpBFGpBAzYCACAFQayXwAA2AlggBUIBNwJMIAVBmL3AADYCSCAFQQ02AgwgBUIDNwI0IAVBgL3AADYCMCAFIAVByABqNgIYIAUgBUEsajYCECAFIAVBKGo2AgggBSAFQQhqNgJAIAVBMGpBoL3AABChAQALIA8gDBCeAQALIAcgDxCgAQALIA8gBBCeAQALIAVByABqQRRqQQA2AgAgBUEIakEUakELNgIAIAVBFGpBDTYCACAFQTBqQRRqQQM2AgAgBUGsl8AANgJYIAVCATcCTCAFQZi9wAA2AkggBUENNgIMIAVCAzcCNCAFQYC9wAA2AjAgBSAFQcgAajYCGCAFIAVBLGo2AhAgBSAFQShqNgIIIAUgBUEIajYCQCAFQTBqQaC9wAAQoQEACyAQIAwQngEACyAIIAIQoAEACyACIAQQngEACyALIA8QoAEACyAFQcgAakEUakEANgIAIAVBCGpBFGpBCzYCACAFQRRqQQ02AgAgBUEwakEUakEDNgIAIAVBrJfAADYCWCAFQgE3AkwgBUGYvcAANgJIIAVBDTYCDCAFQgM3AjQgBUGAvcAANgIwIAUgBUHIAGo2AhggBSAFQSxqNgIQIAUgBUEoajYCCCAFIAVBCGo2AkAgBUEwakGgvcAAEKEBAAsgDyAMEJ4BAAsgByAPEKABAAsgDyAEEJ4BAAsgBUHIAGpBFGpBADYCACAFQQhqQRRqQQs2AgAgBUEUakENNgIAIAVBMGpBFGpBAzYCACAFQayXwAA2AlggBUIBNwJMIAVBmL3AADYCSCAFQQ02AgwgBUIDNwI0IAVBgL3AADYCMCAFIAVByABqNgIYIAUgBUEsajYCECAFIAVBKGo2AgggBSAFQQhqNgJAIAVBMGpBoL3AABChAQALIBAgDBCeAQALIAggAhCgAQALIAIgBBCeAQALIAsgDxCgAQALIAVByABqQRRqQQA2AgAgBUEIakEUakELNgIAIAVBFGpBDTYCACAFQTBqQRRqQQM2AgAgBUGsl8AANgJYIAVCATcCTCAFQZi9wAA2AkggBUENNgIMIAVCAzcCNCAFQYC9wAA2AjAgBSAFQcgAajYCGCAFIAVBLGo2AhAgBSAFQShqNgIIIAUgBUEIajYCQCAFQTBqQaC9wAAQoQEACyAJIA4QngEACyAKIAgQoAEACyAIIAQQngEACyAFQcgAakEUakEANgIAIAVBCGpBFGpBCzYCACAFQRRqQQ02AgAgBUEwakEUakEDNgIAIAVBrJfAADYCWCAFQgE3AkwgBUGYvcAANgJIIAVBDTYCDCAFQgM3AjQgBUGAvcAANgIwIAUgBUHIAGo2AhggBSAFQSxqNgIQIAUgBUEoajYCCCAFIAVBCGo2AkAgBUEwakGgvcAAEKEBAAsgCSAOEJ4BAAsgCiAIEKABAAsgCCAEEJ4BAAsgBUHIAGpBFGpBADYCACAFQQhqQRRqQQs2AgAgBUEUakENNgIAIAVBMGpBFGpBAzYCACAFQayXwAA2AlggBUIBNwJMIAVBmL3AADYCSCAFQQ02AgwgBUIDNwI0IAVBgL3AADYCMCAFIAVByABqNgIYIAUgBUEsajYCECAFIAVBKGo2AgggBSAFQQhqNgJAIAVBMGpBoL3AABChAQALWgECfwJAIAEgAxBTIgRBf0wNAAJAAkAgBEUNACAEQQEQDCIFDQEgBEEBEJYBAAtBASEFCyABIAIgAyAFIAQQVCAAIAQ2AgggACAENgIEIAAgBTYCAA8LEFwAC+AEAQJ/AkACQAJAAkAgAUEMaiABQQhqIAEoAgBBAUYbKAIAIgNBgQRNDQAgASgCBCIELQCBBEEHcUF/aiIBQQVLDQECQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAQ4GAAMCBAEFAAsgBCwAgARBf0wNBiACQQN2IQQgAkF4cSEBIANBggRLDQ4MDQsgBCwAgARBf0wNBCACQXhxIQEgAkEDdkEFbCEEIANBggRNDQwMDQsgBCwAgARBf0wNBSACQXhxIQEgAkEDdkEDbCEEIANBggRNDQsMDAsgBCwAgARBf0wNBSACQQJ2IQQgAkF8cSEBIANBggRNDQoMCwsgBCwAgARBf0wNBSACQQF2IQQgAkF+cSEBIANBggRNDQkMCgsgBCwAgARBf0wNBSACQXxxIQEgAkECdkEDbCEEIANBggRNDQgMCQsgAkEFbCIBQQN2IQQgAiABQQdxQQVuayEBIANBggRNDQcMCAsgAkF4cSEBIAJBA3YhBCADQYIETQ0GDAcLIAJBA2wiAUEDdiEEIAIgAUEHcUEDbmshASADQYIETQ0FDAYLIAJBfHEhASACQQJ2Qf////8BcSEEIANBggRNDQQMBQsgAkF+cSEBIAJBAXZB/////wFxIQQgA0GCBE0NAwwECyACQQZsIgFBA3YhBCACIAFBBnFBBm5rIQEgA0GCBE0NAgwDC0H4usAAQYEEIAMQnQEAC0HMlMAAQQ5B0LvAABBlAAsgASACRg0AIABBCGpBADoAACAAQQRqIAE2AgAgAEEBNgIADwsgAEEEaiAENgIAIABBADYCAAvy/AEBEH8jAEHgAGsiBiQAIAZBADYCACAGIAU2AgQgBkEQaiABIAMQViAGIAY2AiAgBiAGQRBqNgIkAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAYoAhANACAGKAIUIAVHDQAgAUEMaiABQQhqIAEoAgBBAUYbKAIAIgdBgQRNDQEgASgCBCIILQCBBCIJQQdxQX9qIgFBBUsNAgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEOBgAEAgMBBQALIAhBgAJqIQEgCCwAgAQhCCAJQQhxDQggCEF/TA0RIAdBggRNDR1BACEJIANFDTUgBkEwaiEKIAZBwABqIQsgBkE4aiEMIAZBNGohDSAGQTxqIQ4gBkHEAGohD0EAIQhBACEQA0AgAyAIayIRQXhxIgcgCGoiEiAHSQ2lAiASIANLDaYCIBFBA3YiESAJaiITIBFJDacCIBMgBUsNqAIgBkEoaiABIAIgCGogByAEIAlqIBEQSCAGKAIsIQcgBigCKEEBRw2MASAHIAhqIhIgA0sNqQIgCigCACAJaiITIAVLDaoCIAIgEmohCSAGQgA3AxAgC0IANwMAIAxCADcDACAKQgA3AwAgBkIANwMoQQAhEUEAIQcCQCADIBJrIghFDQBBACEHA0AgASAJIAdqLQAAai0AAEGBAUcNASAHQQFqIgcgCEkNAAsLAkAgByAIRg0AIAYgBzYCKCAHIAhPDa0DIAYgCSAHai0AADoAEAJAIAdBAWoiESAITw0AA0AgASAJIBFqLQAAai0AAEGBAUcNASARQQFqIhEgCEkNAAsLIBEgCEYNugEgBiARNgIsIBEgCE8NpgMgBiAJIBFqLQAAOgARAkAgEUEBaiIRIAhPDQADQCABIAkgEWotAABqLQAAQYEBRw0BIBFBAWoiESAISQ0ACwsgESAIRg26ASAKIBE2AgAgESAITw2nAyAGIAkgEWotAAA6ABICQCARQQFqIhEgCE8NAANAIAEgCSARai0AAGotAABBgQFHDQEgEUEBaiIRIAhJDQALCyARIAhGDboBIA0gETYCACARIAhPDagDIAYgCSARai0AADoAEwJAIBFBAWoiESAITw0AA0AgASAJIBFqLQAAai0AAEGBAUcNASARQQFqIhEgCEkNAAsLIBEgCEYNugEgDCARNgIAIBEgCE8NqQMgBiAJIBFqLQAAOgAUAkAgEUEBaiIRIAhPDQADQCABIAkgEWotAABqLQAAQYEBRw0BIBFBAWoiESAISQ0ACwsgESAIRg26ASAOIBE2AgAgESAITw2qAyAGIAkgEWotAAA6ABUCQCARQQFqIhEgCE8NAANAIAEgCSARai0AAGotAABBgQFHDQEgEUEBaiIRIAhJDQALCyARIAhGDboBIAsgETYCACARIAhPDasDIAYgCSARai0AADoAFgJAIBFBAWoiESAITw0AA0AgASAJIBFqLQAAai0AAEGBAUcNASARQQFqIhEgCEkNAAsLIBEgCEYNugEgDyARNgIAIBEgCE8NrAMgBiAJIBFqLQAAOgAXIBFBAWohCEEIIRELIBFBA3YiCSAFIBNrIgdLDfsCIAZByABqIAEgBkEQaiARIAQgE2ogCRBIIAYoAkhBAUYNuAEgBigCTCIJQYB+cSEQIAkgE2ohCSAIIBJqIgggA0kNAAyNAQsLIAhBgAJqIQEgCUEQcSESIAgsAIAEIQggCUEIcQ0EIAhBf0wNCiAHQYIETQ0WIANFDS4gBkEwaiEMIAZBwABqIQ0gBkE4aiEQIAZBNGohDyAGQTxqIRQgBkHEAGohFUEAIQlBACEIQQAhDgNAIAMgCGsiEUF4cSIHIAhqIhMgB0kNqgIgEyADSw2rAiARQQN2QQVsIhEgCWoiCiARSQ2sAiAKIAVLDa0CIAZBKGogEkEARyILIAEgAiAIaiAHIAQgCWogERBRIAYoAiwhByAGKAIoQQFHDXsgByAIaiITIANLDa4CIAwoAgAgCWoiCiAFSw2vAiACIBNqIQkgBkIANwMQIA1CADcDACAQQgA3AwAgDEIANwMAIAZCADcDKEEAIRFBACEHAkAgAyATayIIRQ0AQQAhBwNAIAEgCSAHai0AAGotAABBgQFHDQEgB0EBaiIHIAhJDQALCwJAIAcgCEYNACAGIAc2AiggByAITw20AyAGIAkgB2otAAA6ABACQCAHQQFqIhEgCE8NAANAIAEgCSARai0AAGotAABBgQFHDQEgEUEBaiIRIAhJDQALCyARIAhGDbEBIAYgETYCLCARIAhPDa0DIAYgCSARai0AADoAEQJAIBFBAWoiESAITw0AA0AgASAJIBFqLQAAai0AAEGBAUcNASARQQFqIhEgCEkNAAsLIBEgCEYNsQEgDCARNgIAIBEgCE8NrgMgBiAJIBFqLQAAOgASAkAgEUEBaiIRIAhPDQADQCABIAkgEWotAABqLQAAQYEBRw0BIBFBAWoiESAISQ0ACwsgESAIRg2xASAPIBE2AgAgESAITw2vAyAGIAkgEWotAAA6ABMCQCARQQFqIhEgCE8NAANAIAEgCSARai0AAGotAABBgQFHDQEgEUEBaiIRIAhJDQALCyARIAhGDbEBIBAgETYCACARIAhPDbADIAYgCSARai0AADoAFAJAIBFBAWoiESAITw0AA0AgASAJIBFqLQAAai0AAEGBAUcNASARQQFqIhEgCEkNAAsLIBEgCEYNsQEgFCARNgIAIBEgCE8NsQMgBiAJIBFqLQAAOgAVAkAgEUEBaiIRIAhPDQADQCABIAkgEWotAABqLQAAQYEBRw0BIBFBAWoiESAISQ0ACwsgESAIRg2xASANIBE2AgAgESAITw2yAyAGIAkgEWotAAA6ABYCQCARQQFqIhEgCE8NAANAIAEgCSARai0AAGotAABBgQFHDQEgEUEBaiIRIAhJDQALCyARIAhGDbEBIBUgETYCACARIAhPDbMDIAYgCSARai0AADoAFyARQQFqIQhBCCERCyARQQN2QQVsIgkgBSAKayIHSw37AiAGQcgAaiALIAEgBkEQaiARIAQgCmogCRBRIAYoAkhBAUYNrwEgBigCTCIJQYB+cSEOIAkgCmohCSAIIBNqIgggA0kNAAx8CwsgCEGAAmohASAJQRBxIRIgCCwAgAQhCCAJQQhxDQQgCEF/TA0LIAdBggRNDRcgA0UNLyAGQTBqIQwgBkHAAGohDSAGQThqIRAgBkE0aiEPIAZBPGohFCAGQcQAaiEVQQAhCUEAIQhBACEOA0AgAyAIayIRQXhxIgcgCGoiEyAHSQ2vAiATIANLDbACIBFBA3ZBA2wiESAJaiIKIBFJDbECIAogBUsNsgIgBkEoaiASQQBHIgsgASACIAhqIAcgBCAJaiAREEYgBigCLCEHIAYoAihBAUcNggEgByAIaiITIANLDbMCIAwoAgAgCWoiCiAFSw20AiACIBNqIQkgBkIANwMQIA1CADcDACAQQgA3AwAgDEIANwMAIAZCADcDKEEAIRFBACEHAkAgAyATayIIRQ0AQQAhBwNAIAEgCSAHai0AAGotAABBgQFHDQEgB0EBaiIHIAhJDQALCwJAIAcgCEYNACAGIAc2AiggByAITw27AyAGIAkgB2otAAA6ABACQCAHQQFqIhEgCE8NAANAIAEgCSARai0AAGotAABBgQFHDQEgEUEBaiIRIAhJDQALCyARIAhGDbQBIAYgETYCLCARIAhPDbQDIAYgCSARai0AADoAEQJAIBFBAWoiESAITw0AA0AgASAJIBFqLQAAai0AAEGBAUcNASARQQFqIhEgCEkNAAsLIBEgCEYNtAEgDCARNgIAIBEgCE8NtQMgBiAJIBFqLQAAOgASAkAgEUEBaiIRIAhPDQADQCABIAkgEWotAABqLQAAQYEBRw0BIBFBAWoiESAISQ0ACwsgESAIRg20ASAPIBE2AgAgESAITw22AyAGIAkgEWotAAA6ABMCQCARQQFqIhEgCE8NAANAIAEgCSARai0AAGotAABBgQFHDQEgEUEBaiIRIAhJDQALCyARIAhGDbQBIBAgETYCACARIAhPDbcDIAYgCSARai0AADoAFAJAIBFBAWoiESAITw0AA0AgASAJIBFqLQAAai0AAEGBAUcNASARQQFqIhEgCEkNAAsLIBEgCEYNtAEgFCARNgIAIBEgCE8NuAMgBiAJIBFqLQAAOgAVAkAgEUEBaiIRIAhPDQADQCABIAkgEWotAABqLQAAQYEBRw0BIBFBAWoiESAISQ0ACwsgESAIRg20ASANIBE2AgAgESAITw25AyAGIAkgEWotAAA6ABYCQCARQQFqIhEgCE8NAANAIAEgCSARai0AAGotAABBgQFHDQEgEUEBaiIRIAhJDQALCyARIAhGDbQBIBUgETYCACARIAhPDboDIAYgCSARai0AADoAFyARQQFqIQhBCCERCyARQQN2QQNsIgkgBSAKayIHSw37AiAGQcgAaiALIAEgBkEQaiARIAQgCmogCRBGIAYoAkhBAUYNsgEgBigCTCIJQYB+cSEOIAkgCmohCSAIIBNqIgggA0kNAAyDAQsLIAhBgAJqIQEgCCwAgAQhCCAJQQhxDQQgCEF/TA0MIAdBggRNDRhBACEHIANFDTAgBkEwaiEKIAZBwABqIQsgBkE4aiEQQQAhCEEAIQwDQCADIAhrIhFBfnEiCSAIaiISIAlJDdwBIBIgA0sN3QEgEUEBdiIRIAdqIhMgEUkN3gEgEyAFSw3fASAGQShqIAEgAiAIaiAJIAQgB2ogERBOIAYoAiwhCSAGKAIoQQFHDUUgCSAIaiISIANLDeABIAooAgAgB2oiEyAFSw3hASACIBJqIQcgBkIANwMQIAtCADcDACAQQgA3AwAgCkIANwMAIAZCADcDKEEAIRFBACEIAkAgAyASayIJRQ0AQQAhCANAIAEgByAIai0AAGotAABBgQFHDQEgCEEBaiIIIAlJDQALCwJAIAggCUYNACAGIAg2AiggCCAJTw3kAiAGIAcgCGotAAA6ABACQCAIQQFqIhEgCU8NAANAIAEgByARai0AAGotAABBgQFHDQEgEUEBaiIRIAlJDQALCyARIAlGDU8gBiARNgIsIBEgCU8N4wIgBiAHIBFqLQAAOgARIBFBAWohCUECIRELIBFBAXYiCCAFIBNrIgdLDeIBIAZByABqIAEgBkEQaiARIAQgE2ogCBBOIAYoAkhBAUYNTSAGKAJMIghBgH5xIQwgCCATaiEHIAkgEmoiCCADSQ0ADEYLCyAIQYACaiEBIAgsAIAEIQggCUEIcQ0FIAhBf0wNDiAHQYIETQ0aQQAhByADRQ0yIAZBMGohCiAGQcAAaiELIAZBOGohECAGQTRqIQ1BACEIQQAhDANAIAMgCGsiEUF8cSIJIAhqIhIgCUkN6QEgEiADSw3qASARQQJ2IhEgB2oiEyARSQ3rASATIAVLDewBIAZBKGogASACIAhqIAkgBCAHaiAREEkgBigCLCEJIAYoAihBAUcNUCAJIAhqIhIgA0sN7QEgCigCACAHaiITIAVLDe4BIAIgEmohByAGQgA3AxAgC0IANwMAIBBCADcDACAKQgA3AwAgBkIANwMoQQAhEUEAIQgCQCADIBJrIglFDQBBACEIA0AgASAHIAhqLQAAai0AAEGBAUcNASAIQQFqIgggCUkNAAsLAkAgCCAJRg0AIAYgCDYCKCAIIAlPDYEDIAYgByAIai0AADoAEAJAIAhBAWoiESAJTw0AA0AgASAHIBFqLQAAai0AAEGBAUcNASARQQFqIhEgCUkNAAsLIBEgCUYNYiAGIBE2AiwgESAJTw3+AiAGIAcgEWotAAA6ABECQCARQQFqIhEgCU8NAANAIAEgByARai0AAGotAABBgQFHDQEgEUEBaiIRIAlJDQALCyARIAlGDWIgCiARNgIAIBEgCU8N/wIgBiAHIBFqLQAAOgASAkAgEUEBaiIRIAlPDQADQCABIAcgEWotAABqLQAAQYEBRw0BIBFBAWoiESAJSQ0ACwsgESAJRg1iIA0gETYCACARIAlPDYADIAYgByARai0AADoAEyARQQFqIQlBBCERCyARQQJ2IgggBSATayIHSw3vASAGQcgAaiABIAZBEGogESAEIBNqIAgQSSAGKAJIQQFGDWAgBigCTCIIQYB+cSEMIAggE2ohByAJIBJqIgggA0kNAAxRCwsgCEGAAmohASAJQRBxIRIgCCwAgAQhCCAJQQhxDQUgCEF/TA0QIAdBggRNDRwgA0UNNCAGQTBqIQwgBkHAAGohDSAGQThqIQ4gBkE0aiEPQQAhB0EAIQhBACEQA0AgAyAIayIRQXxxIgkgCGoiEyAJSQ3vASATIANLDfABIBFBAnZBA2wiESAHaiIKIBFJDfEBIAogBUsN8gEgBkEoaiASQQBHIgsgASACIAhqIAkgBCAHaiAREEsgBigCLCEJIAYoAihBAUcNVyAJIAhqIhMgA0sN8wEgDCgCACAHaiIKIAVLDfQBIAIgE2ohByAGQgA3AxAgDUIANwMAIA5CADcDACAMQgA3AwAgBkIANwMoQQAhEUEAIQgCQCADIBNrIglFDQBBACEIA0AgASAHIAhqLQAAai0AAEGBAUcNASAIQQFqIgggCUkNAAsLAkAgCCAJRg0AIAYgCDYCKCAIIAlPDYQDIAYgByAIai0AADoAEAJAIAhBAWoiESAJTw0AA0AgASAHIBFqLQAAai0AAEGBAUcNASARQQFqIhEgCUkNAAsLIBEgCUYNZSAGIBE2AiwgESAJTw2BAyAGIAcgEWotAAA6ABECQCARQQFqIhEgCU8NAANAIAEgByARai0AAGotAABBgQFHDQEgEUEBaiIRIAlJDQALCyARIAlGDWUgDCARNgIAIBEgCU8NggMgBiAHIBFqLQAAOgASAkAgEUEBaiIRIAlPDQADQCABIAcgEWotAABqLQAAQYEBRw0BIBFBAWoiESAJSQ0ACwsgESAJRg1lIA8gETYCACARIAlPDYMDIAYgByARai0AADoAEyARQQFqIQlBBCERCyARQQJ2QQNsIgggBSAKayIHSw31ASAGQcgAaiALIAEgBkEQaiARIAQgCmogCBBLIAYoAkhBAUYNYyAGKAJMIghBgH5xIRAgCCAKaiEHIAkgE2oiCCADSQ0ADFgLCyAIQX9MDQYgB0GCBE0NEiADRQ0qIAZBMGohDCAGQcAAaiENIAZBOGohECAGQTRqIQ8gBkE8aiEUIAZBxABqIRVBACEJQQAhCEEAIQ4DQCADIAhrIhFBeHEiByAIaiITIAdJDbECIBMgA0sNsgIgEUEDdkEFbCIRIAlqIgogEUkNswIgCiAFSw20AiAGQShqIBJBAEciCyABIAIgCGogByAEIAlqIBEQUCAGKAIsIQcgBigCKEEBRw16IAcgCGoiEyADSw21AiAMKAIAIAlqIgogBUsNtgIgAiATaiEJIAZCADcDECANQgA3AwAgEEIANwMAIAxCADcDACAGQgA3AyhBACERQQAhBwJAIAMgE2siCEUNAEEAIQcDQCABIAkgB2otAABqLQAAQYEBRw0BIAdBAWoiByAISQ0ACwsCQCAHIAhGDQAgBiAHNgIoIAcgCE8NvwMgBiAJIAdqLQAAOgAQAkAgB0EBaiIRIAhPDQADQCABIAkgEWotAABqLQAAQYEBRw0BIBFBAWoiESAISQ0ACwsgESAIRg2uASAGIBE2AiwgESAITw24AyAGIAkgEWotAAA6ABECQCARQQFqIhEgCE8NAANAIAEgCSARai0AAGotAABBgQFHDQEgEUEBaiIRIAhJDQALCyARIAhGDa4BIAwgETYCACARIAhPDbkDIAYgCSARai0AADoAEgJAIBFBAWoiESAITw0AA0AgASAJIBFqLQAAai0AAEGBAUcNASARQQFqIhEgCEkNAAsLIBEgCEYNrgEgDyARNgIAIBEgCE8NugMgBiAJIBFqLQAAOgATAkAgEUEBaiIRIAhPDQADQCABIAkgEWotAABqLQAAQYEBRw0BIBFBAWoiESAISQ0ACwsgESAIRg2uASAQIBE2AgAgESAITw27AyAGIAkgEWotAAA6ABQCQCARQQFqIhEgCE8NAANAIAEgCSARai0AAGotAABBgQFHDQEgEUEBaiIRIAhJDQALCyARIAhGDa4BIBQgETYCACARIAhPDbwDIAYgCSARai0AADoAFQJAIBFBAWoiESAITw0AA0AgASAJIBFqLQAAai0AAEGBAUcNASARQQFqIhEgCEkNAAsLIBEgCEYNrgEgDSARNgIAIBEgCE8NvQMgBiAJIBFqLQAAOgAWAkAgEUEBaiIRIAhPDQADQCABIAkgEWotAABqLQAAQYEBRw0BIBFBAWoiESAISQ0ACwsgESAIRg2uASAVIBE2AgAgESAITw2+AyAGIAkgEWotAAA6ABcgEUEBaiEIQQghEQsgEUEDdkEFbCIJIAUgCmsiB0sN+AIgBkHIAGogCyABIAZBEGogESAEIApqIAkQUCAGKAJIQQFGDawBIAYoAkwiCUGAfnEhDiAJIApqIQkgCCATaiIIIANJDQAMewsLIAhBf0wNByAHQYIETQ0TIANFDSsgBkEwaiEMIAZBwABqIQ0gBkE4aiEQIAZBNGohDyAGQTxqIRQgBkHEAGohFUEAIQlBACEIQQAhDgNAIAMgCGsiEUF4cSIHIAhqIhMgB0kNtgIgEyADSw23AiARQQN2QQNsIhEgCWoiCiARSQ24AiAKIAVLDbkCIAZBKGogEkEARyILIAEgAiAIaiAHIAQgCWogERBPIAYoAiwhByAGKAIoQQFHDYEBIAcgCGoiEyADSw26AiAMKAIAIAlqIgogBUsNuwIgAiATaiEJIAZCADcDECANQgA3AwAgEEIANwMAIAxCADcDACAGQgA3AyhBACERQQAhBwJAIAMgE2siCEUNAEEAIQcDQCABIAkgB2otAABqLQAAQYEBRw0BIAdBAWoiByAISQ0ACwsCQCAHIAhGDQAgBiAHNgIoIAcgCE8NxgMgBiAJIAdqLQAAOgAQAkAgB0EBaiIRIAhPDQADQCABIAkgEWotAABqLQAAQYEBRw0BIBFBAWoiESAISQ0ACwsgESAIRg2xASAGIBE2AiwgESAITw2/AyAGIAkgEWotAAA6ABECQCARQQFqIhEgCE8NAANAIAEgCSARai0AAGotAABBgQFHDQEgEUEBaiIRIAhJDQALCyARIAhGDbEBIAwgETYCACARIAhPDcADIAYgCSARai0AADoAEgJAIBFBAWoiESAITw0AA0AgASAJIBFqLQAAai0AAEGBAUcNASARQQFqIhEgCEkNAAsLIBEgCEYNsQEgDyARNgIAIBEgCE8NwQMgBiAJIBFqLQAAOgATAkAgEUEBaiIRIAhPDQADQCABIAkgEWotAABqLQAAQYEBRw0BIBFBAWoiESAISQ0ACwsgESAIRg2xASAQIBE2AgAgESAITw3CAyAGIAkgEWotAAA6ABQCQCARQQFqIhEgCE8NAANAIAEgCSARai0AAGotAABBgQFHDQEgEUEBaiIRIAhJDQALCyARIAhGDbEBIBQgETYCACARIAhPDcMDIAYgCSARai0AADoAFQJAIBFBAWoiESAITw0AA0AgASAJIBFqLQAAai0AAEGBAUcNASARQQFqIhEgCEkNAAsLIBEgCEYNsQEgDSARNgIAIBEgCE8NxAMgBiAJIBFqLQAAOgAWAkAgEUEBaiIRIAhPDQADQCABIAkgEWotAABqLQAAQYEBRw0BIBFBAWoiESAISQ0ACwsgESAIRg2xASAVIBE2AgAgESAITw3FAyAGIAkgEWotAAA6ABcgEUEBaiEIQQghEQsgEUEDdkEDbCIJIAUgCmsiB0sN+AIgBkHIAGogCyABIAZBEGogESAEIApqIAkQTyAGKAJIQQFGDa8BIAYoAkwiCUGAfnEhDiAJIApqIQkgCCATaiIIIANJDQAMggELCyAIQX9MDQggB0GCBE0NFEEAIQcgA0UNLCAGQTBqIQogBkHAAGohCyAGQThqIRBBACEIQQAhDANAIAMgCGsiEUF+cSIJIAhqIhIgCUkN3gEgEiADSw3fASARQQF2IhEgB2oiEyARSQ3gASATIAVLDeEBIAZBKGogASACIAhqIAkgBCAHaiAREEcgBigCLCEJIAYoAihBAUcNRCAJIAhqIhIgA0sN4gEgCigCACAHaiITIAVLDeMBIAIgEmohByAGQgA3AxAgC0IANwMAIBBCADcDACAKQgA3AwAgBkIANwMoQQAhEUEAIQgCQCADIBJrIglFDQBBACEIA0AgASAHIAhqLQAAai0AAEGBAUcNASAIQQFqIgggCUkNAAsLAkAgCCAJRg0AIAYgCDYCKCAIIAlPDeECIAYgByAIai0AADoAEAJAIAhBAWoiESAJTw0AA0AgASAHIBFqLQAAai0AAEGBAUcNASARQQFqIhEgCUkNAAsLIBEgCUYNTCAGIBE2AiwgESAJTw3gAiAGIAcgEWotAAA6ABEgEUEBaiEJQQIhEQsgEUEBdiIIIAUgE2siB0sN5AEgBkHIAGogASAGQRBqIBEgBCATaiAIEEcgBigCSEEBRg1KIAYoAkwiCEGAfnEhDCAIIBNqIQcgCSASaiIIIANJDQAMRQsLIAhBf0wNCiAHQYIETQ0WQQAhCSADRQ0uIAZBMGohCiAGQcAAaiELIAZBOGohDCAGQTRqIQ0gBkE8aiEOIAZBxABqIQ9BACEIQQAhEANAIAMgCGsiEUF4cSIHIAhqIhIgB0kNugIgEiADSw27AiARQQN2IhEgCWoiEyARSQ28AiATIAVLDb0CIAZBKGogASACIAhqIAcgBCAJaiAREEogBigCLCEHIAYoAihBAUcNhwEgByAIaiISIANLDb4CIAooAgAgCWoiEyAFSw2/AiACIBJqIQkgBkIANwMQIAtCADcDACAMQgA3AwAgCkIANwMAIAZCADcDKEEAIRFBACEHAkAgAyASayIIRQ0AQQAhBwNAIAEgCSAHai0AAGotAABBgQFHDQEgB0EBaiIHIAhJDQALCwJAIAcgCEYNACAGIAc2AiggByAITw3MAyAGIAkgB2otAAA6ABACQCAHQQFqIhEgCE8NAANAIAEgCSARai0AAGotAABBgQFHDQEgEUEBaiIRIAhJDQALCyARIAhGDbMBIAYgETYCLCARIAhPDcUDIAYgCSARai0AADoAEQJAIBFBAWoiESAITw0AA0AgASAJIBFqLQAAai0AAEGBAUcNASARQQFqIhEgCEkNAAsLIBEgCEYNswEgCiARNgIAIBEgCE8NxgMgBiAJIBFqLQAAOgASAkAgEUEBaiIRIAhPDQADQCABIAkgEWotAABqLQAAQYEBRw0BIBFBAWoiESAISQ0ACwsgESAIRg2zASANIBE2AgAgESAITw3HAyAGIAkgEWotAAA6ABMCQCARQQFqIhEgCE8NAANAIAEgCSARai0AAGotAABBgQFHDQEgEUEBaiIRIAhJDQALCyARIAhGDbMBIAwgETYCACARIAhPDcgDIAYgCSARai0AADoAFAJAIBFBAWoiESAITw0AA0AgASAJIBFqLQAAai0AAEGBAUcNASARQQFqIhEgCEkNAAsLIBEgCEYNswEgDiARNgIAIBEgCE8NyQMgBiAJIBFqLQAAOgAVAkAgEUEBaiIRIAhPDQADQCABIAkgEWotAABqLQAAQYEBRw0BIBFBAWoiESAISQ0ACwsgESAIRg2zASALIBE2AgAgESAITw3KAyAGIAkgEWotAAA6ABYCQCARQQFqIhEgCE8NAANAIAEgCSARai0AAGotAABBgQFHDQEgEUEBaiIRIAhJDQALCyARIAhGDbMBIA8gETYCACARIAhPDcsDIAYgCSARai0AADoAFyARQQFqIQhBCCERCyARQQN2IgkgBSATayIHSw33AiAGQcgAaiABIAZBEGogESAEIBNqIAkQSiAGKAJIQQFGDbEBIAYoAkwiCUGAfnEhECAJIBNqIQkgCCASaiIIIANJDQAMiAELCyAIQX9MDQogB0GCBE0NFkEAIQcgA0UNLiAGQTBqIQogBkHAAGohCyAGQThqIRAgBkE0aiENQQAh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ADYCACAAQQRqIAc2AgAgBkHgAGokAA8LIABBATYCACAAQRBqQQA6AAAgAEEMaiAINgIAIABBCGogBzYCACAAQQRqIAg2AgAgBkHgAGokAA8LIAkgB2ohByATIQgLIAggA08NAQsDQCABIAIgCGotAABqLQAAQYEBRw0BIAhBAWoiCCADSQ0ACwsCQCAIIANHDQAgAEEANgIAIABBBGogBzYCACAGQeAAaiQADwsgAEEBNgIAIABBEGpBADoAACAAQQxqIAg2AgAgAEEIaiAHNgIAIABBBGogCDYCACAGQeAAaiQADwsgCSAHaiEHIBMhCAsgCCADTw0BCwNAIAEgAiAIai0AAGotAABBgQFHDQEgCEEBaiIIIANJDQALCwJAIAggA0cNACAAQQA2AgAgAEEEaiAHNgIAIAZB4ABqJAAPCyAAQQE2AgAgAEEQakEAOgAAIABBDGogCDYCACAAQQhqIAc2AgAgAEEEaiAINgIAIAZB4ABqJAAPCyAHIAlqIQkgEyEICyAIIANPDQELA0AgASACIAhqLQAAai0AAEGBAUcNASAIQQFqIgggA0kNAAsLAkAgCCADRw0AIABBADYCACAAQQRqIAk2AgAgBkHgAGokAA8LIABBATYCACAAQRBqQQA6AAAgAEEMaiAINgIAIABBCGogCTYCACAAQQRqIAg2AgAgBkHgAGokAA8LIAcgCWohCSATIQgLIAggA08NAQsDQCABIAIgCGotAABqLQAAQYEBRw0BIAhBAWoiCCADSQ0ACwsCQCAIIANHDQAgAEEANgIAIABBBGogCTYCACAGQeAAaiQADwsgAEEBNgIAIABBEGpBADoAACAAQQxqIAg2AgAgAEEIaiAJNgIAIABBBGogCDYCACAGQeAAaiQADwsgByAJaiEJIBMhCAsgCCADTw0BCwNAIAEgAiAIai0AAGotAABBgQFHDQEgCEEBaiIIIANJDQALCwJAIAggA0cNACAAQQA2AgAgAEEEaiAJNgIAIAZB4ABqJAAPCyAAQQE2AgAgAEEQakEAOgAAIABBDGogCDYCACAAQQhqIAk2AgAgAEEEaiAINgIAIAZB4ABqJAAPCyAHIAlqIQkgEyEICyAIIANPDQELA0AgASACIAhqLQAAai0AAEGBAUcNASAIQQFqIgggA0kNAAsLAkAgCCADRw0AIABBADYCACAA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EyADEJ4BAAsgCSAKEKABAAsgCiAFEJ4BAAsgEyADEKABAAsgCiAFEKABAAsgCCATEKABAAsgEyADEJ4BAAsgCSAKEKABAAsgCiAFEJ4BAAsgEyADEKABAAsgCiAFEKABAAsgCCATEKABAAsgEyADEJ4BAAsgCSAKEKABAAsgCiAFEJ4BAAsgEyADEKABAAsgCiAFEKABAAsgCCASEKABAAsgEiADEJ4BAAsgCSATEKABAAsgEyAFEJ4BAAsgEiADEKABAAsgEyAFEKABAAsgCCATEKABAAsgEyADEJ4BAAsgByAKEKABAAsgCiAFEJ4BAAsgESADEKABAAsgCiAFEKABAAsgCCAHEJ4BAAsgCCATEKABAAsgEyADEJ4BAAsgByAKEKABAAsgCiAFEJ4BAAsgESADEKABAAsgCiAFEKABAAsgCCAHEJ4BAAsgCCATEKABAAsgEyADEJ4BAAsgByAKEKABAAsgCiAFEJ4BAAsgESADEKABAAsgCiAFEKABAAsgCCAHEJ4BAAsgCCATEKABAAsgEyADEJ4BAAsgByAKEKABAAsgCiAFEJ4BAAsgESADEKABAAsgCiAFEKABAAsgCCAHEJ4BAAsgESEIC0HIusAAIAggCRCdAQALIBEhCAtByLrAACAIIAkQnQEAC0HIusAAIAggCRCdAQALQci6wAAgCCAJEJ0BAAtByLrAACAIIAkQnQEAC0HIusAAIAggCRCdAQALIAggEhCgAQALIBIgAxCeAQALIAcgExCgAQALIBMgBRCeAQALIBIgAxCgAQALIBMgBRCgAQALIAggBxCeAQALIAggEhCgAQALIBIgAxCeAQALIAcgExCgAQALIBMgBRCeAQALIBIgAxCgAQALIBMgBRCgAQALIAggBxCeAQALIAkgBxCeAQALIAkgBxCeAQALIAkgBxCeAQALIAkgBxCeAQALIAkgBxCeAQALIAkgBxCeAQALQci6wAAgESAJEJ0BAAtByLrAACARIAkQnQEACyARIQgLQci6wAAgCCAJEJ0BAAtByLrAACARIAkQnQEAC0HIusAAIBEgCRCdAQALIBEhCAtByLrAACAIIAkQnQEAC0HIusAAIBEgCRCdAQALQci6wAAgESAJEJ0BAAsgESEIC0HIusAAIAggCRCdAQALQci6wAAgESAJEJ0BAAtByLrAACARIAkQnQEACyARIQgLQci6wAAgCCAJEJ0BAAsgCCASEKABAAsgEiADEJ4BAAsgCSATEKABAAsgEyAFEJ4BAAsgEiADEKABAAsgEyAFEKABAAsgCCASEKABAAsgEiADEJ4BAAsgCSATEKABAAsgEyAFEJ4BAAsgEiADEKABAAsgEyAFEKABAAsgESEIC0HIusAAIAggCRCdAQALIBEhCAtByLrAACAIIAkQnQEACyARIQgLQci6wAAgCCAJEJ0BAAsgESEIC0HIusAAIAggCRCdAQALQci6wAAgESAIEJ0BAAtByLrAACARIAgQnQEAC0HIusAAIBEgCBCdAQALQci6wAAgESAIEJ0BAAtByLrAACARIAgQnQEAC0HIusAAIBEgCBCdAQALIBEhBwtByLrAACAHIAgQnQEAC0HIusAAIBEgCBCdAQALQci6wAAgESAIEJ0BAAtByLrAACARIAgQnQEAC0HIusAAIBEgCBCdAQALQci6wAAgESAIEJ0BAAtByLrAACARIAgQnQEACyARIQcLQci6wAAgByAIEJ0BAAtByLrAACARIAgQnQEAC0HIusAAIBEgCBCdAQALQci6wAAgESAIEJ0BAAtByLrAACARIAgQnQEAC0HIusAAIBEgCBCdAQALQci6wAAgESAIEJ0BAAsgESEHC0HIusAAIAcgCBCdAQALQci6wAAgESAIEJ0BAAtByLrAACARIAgQnQEAC0HIusAAIBEgCBCdAQALQci6wAAgESAIEJ0BAAtByLrAACARIAgQnQEAC0HIusAAIBEgCBCdAQALIBEhBwtByLrAACAHIAgQnQEAC0HIusAAIBEgCBCdAQALQci6wAAgESAIEJ0BAAtByLrAACARIAgQnQEAC0HIusAAIBEgCBCdAQALQci6wAAgESAIEJ0BAAtByLrAACARIAgQnQEACyARIQcLQci6wAAgByAIEJ0BAAtByLrAACARIAgQnQEAC0HIusAAIBEgCBCdAQALQci6wAAgESAIEJ0BAAtByLrAACARIAgQnQEAC0HIusAAIBEgCBCdAQALQci6wAAgESAIEJ0BAAsgESEHC0HIusAAIAcgCBCdAQALIAkgBxCeAQALIAkgBxCeAQALQci6wAAgESAJEJ0BAAtByLrAACARIAkQnQEACyARIQgLQci6wAAgCCAJEJ0BAAtByLrAACARIAkQnQEAC0HIusAAIBEgCRCdAQALIBEhCAtByLrAACAIIAkQnQEAC0HIusAAIBEgCBCdAQALQci6wAAgESAIEJ0BAAtByLrAACARIAgQnQEAC0HIusAAIBEgCBCdAQALQci6wAAgESAIEJ0BAAtByLrAACARIAgQnQEACyARIQcLQci6wAAgByAIEJ0BAAtByLrAACARIAgQnQEAC0HIusAAIBEgCBCdAQALQci6wAAgESAIEJ0BAAtByLrAACARIAgQnQEAC0HIusAAIBEgCBCdAQALQci6wAAgESAIEJ0BAAsgESEHC0HIusAAIAcgCBCdAQALQei6wAAgA0EIEJ0BAAtB6LrAACADQQgQnQEAC0HousAAIANBCBCdAQALQei6wAAgA0EIEJ0BAAtB6LrAACADQQgQnQEAC0HousAAIANBCBCdAQALQei6wAAgA0EIEJ0BAAtB6LrAACADQQgQnQEAC0HousAAIANBCBCdAQALQei6wAAgA0EIEJ0BAAtB2LrAACADQQgQnQEAC0HYusAAIANBCBCdAQALQdi6wAAgA0EIEJ0BAAtB2LrAACADQQgQnQEAC0HousAAIANBCBCdAQALQei6wAAgA0EIEJ0BAAtB6LrAACADQQgQnQEAC0HousAAIANBCBCdAQALQei6wAAgA0EIEJ0BAAtB6LrAACADQQgQnQEAC0HousAAIANBCBCdAQALQei6wAAgA0EIEJ0BAAtB6LrAACADQQgQnQEAC0HousAAIANBCBCdAQALQei6wAAgA0EIEJ0BAAtB6LrAACADQQgQnQEAC0HousAAIANBCBCdAQALQei6wAAgA0EIEJ0BAAutAgEDfyMAQSBrIgQkACAEQQhqIAEgAxBWIAQoAgwhBQJAIAQoAghBAUcNACAEQQhqQQhqLQAAIQEgACAFNgIEIABBATYCACAAQQhqIAE6AAAgBEEgaiQADwsCQAJAIAVBf0wNAEEBIQYCQCAFRQ0AIAVBARAMIgZFDQILIARBCGogASACIAMgBiAFEFcgBEEIakEMaiAEQQhqQQRyIAQoAghBAUYiAxsoAgAhAQJAIANFDQAgBEEYai0AACEDIAAgATYCBCAAQQE2AgAgAEEIaiADOgAAAkAgBUUNACAGIAVBARAKCyAEQSBqJAAPCyAAIAY2AgQgAEEANgIAIABBCGogBTYCACAAQQxq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ADYCDAJAAkAgAUH/AEsNACACIAE6AAxBASEBDAELAkAgAUH/D0sNACACIAFBP3FBgAFyOgANIAIgAUEGdkEfcUHAAXI6AAxBAiEBDAELAkAgAUH//wNLDQAgAiABQT9xQYABcjoADiACIAFBBnZBP3FBgAFyOgANIAIgAUEMdkEPcUHgAXI6AAxBAyEBDAELIAIgAUE/cUGAAXI6AA8gAiABQRJ2QfABcjoADCACIAFBBnZBP3FBgAFyOgAOIAIgAUEMdkE/cUGAAXI6AA1BBCEBCyAAIAJBDGogARC7ASEBIAJBEGokACABC2EBAX8jAEEgayICJAAgAiAANgIEIAJBCGpBEGogAUEQaikCADcDACACQQhqQQhqIAFBCGopAgA3AwAgAiABKQIANwMIIAJBBGpBiMLAACACQQhqEKYBIQEgAkEgaiQAIAELDgAgACgCACABIAIQuwELDAAgACgCACABEL8BC2QBAX8jAEEgayICJAAgAiAAKAIANgIEIAJBCGpBEGogAUEQaikCADcDACACQQhqQQhqIAFBCGopAgA3AwAgAiABKQIANwMIIAJBBGpBiMLAACACQQhqEKYBIQEgAkEgaiQAIAELCQAgACABEKQBC2UBAn8jAEEgayICJAAgAUEcaigCACEDIAEoAhghASACQQhqQRBqIABBEGopAgA3AwAgAkEIakEIaiAAQQhqKQIANwMAIAIgACkCADcDCCABIAMgAkEIahCmASEAIAJBIGokACAAC8kLAQd/IwBBEGsiBiQAAkACQCABRQ0AQStBgIDEACAAKAIAIgdBAXEiARshCCABIAVqIQkMAQsgBUEBaiEJIAAoAgAhB0EtIQgLAkAgB0EEcSIKRQ0AQQAhCwJAIANFDQAgAyEMIAIhAQNAIAsgAS0AAEHAAXFBgAFGaiELIAFBAWohASAMQX9qIgwNAAsLIAkgA2ogC2shCQsgCkECdiEKAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCCEEBRw0AIABBDGooAgAiCyAJTQ0BIAdBCHENAiALIAlrIQxBASAALQAwIgEgAUEDRhtBA3EiAUUNAyABQQJGDQRBACEJDAULAkAgCEGAgMQARg0AQQEhASAAKAIYIAggAEEcaigCACgCEBECAA0PCwJAIApFDQBBASEBIABBGGoo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IAJFDQBBACEDA0AgACADai0AACIEIAEgA2otAAAiBUcNAiADQQFqIgMgAkkNAAtBAA8LQQAPCyAEIAVrCwvUUwMAQYCAwAALgDZUcmllZCB0byBzaHJpbmsgdG8gYSBsYXJnZXIgY2FwYWNpdHlzcmMvbGliYWxsb2MvcmF3X3ZlYy5yc2hjazBoY2EwaGNzMGludmFsaWQgZW5jb2RpbmcgbmFtZTogIiJudWxsIHBvaW50ZXIgcGFzc2VkIHRvIHJ1c3RyZWN1cnNpdmUgdXNlIG9mIGFuIG9iamVjdCBkZXRlY3RlZCB3aGljaCB3b3VsZCBsZWFkIHRvIHVuc2FmZSBhbGlhc2luZyBpbiBydXN0AAAAAAAAL3J1c3RjLzE5Zjg5NThmODI3ZTM3OWJlOWIwZmZjOTNmY2E1ODBlYzhmZmFjNzcvc3JjL2xpYmNvcmUvc2xpY2UvbW9kLnJzMTAxQUJDREVGR0hJSktNTk9QUVJTVFVWV1hZWjM0NTY3ODlCYWREYXRhTGVuOixFeHBlY3RlZDpJbnRlcm5hbEdlbmVyYXRlZEJhZExlbjoBAAAAAAAAACAAAAAIAAAAAwAAAAAAAAAAAAAACAAAAAMAAABUb29NYW55RXJyb3JzQmFkSWRMZW46UHJlZml4TWlzbWF0Y2gvcnVzdGMvMTlmODk1OGY4MjdlMzc5YmU5YjBmZmM5M2ZjYTU4MGVjOGZmYWM3Ny9zcmMvbGliY29yZS9zbGljZS9tb2QucnNIY2lkRXJyb3Jhc3NlcnRpb24gZmFpbGVkOiBgKGxlZnQgPT0gcmlnaHQpYAogIGxlZnQ6IGBgLAogcmlnaHQ6IGBgOiBkZXN0aW5hdGlvbiBhbmQgc291cmNlIHNsaWNlcyBoYXZlIGRpZmZlcmVudCBsZW5ndGhzAAAAc3JjL2xpYmNvcmUvc2xpY2UvbW9kLnJzAQIECBAgQIAdOnTozYcTJkyYLVq0derJjwMGDBgwYMCdJ06cJUqUNWrUtXfuwZ8jRowFChQoUKBdumnSuW/eoV++YcKZL168ZcqJDx48ePD959O7a9axf/7h36NbtnHi2a9DhhEiRIgNGjRo0L1nzoEfPnz47ceTO3bsxZczZsyFFy5cuG3aqU+eIUKEFSpUqE2aKVKkVapJkjly5NW3c+bRv2PGkT9+/OXXs3v28f/j26tLljFixJU3btylV65BghkyZMiNBw4cOHDg3adTplGiWbJ58vnvw5srVqxFigkSJEiQPXr09ffz++vLiwsWLFiwffrpz4MbNmzYrUeOAQIECBAgQIAdOnTozYcTJkyYLVq0derJjwMGDBgwYMCdJ06cJUqUNWrUtXfuwZ8jRowFChQoUKBdumnSuW/eoV++YcKZL168ZcqJDx48ePD959O7a9axf/7h36NbtnHi2a9DhhEiRIgNGjRo0L1nzoEfPnz47ceTO3bsxZczZsyFFy5cuG3aqU+eIUKEFSpUqE2aKVKkVapJkjly5NW3c+bRv2PGkT9+/OXXs3v28f/j26tLljFixJU3btylV65BghkyZMiNBw4cOHDg3adTplGiWbJ58vnvw5srVqxFigkSJEiQPXr09ffz++vLiwsWLFiwffrpz4MbNmzYrUeOAQIAAAEZAjIaxgPfM+4baMdLBGTgDjSN74EcwWn4yAhMcQWKZS/hJA8hNZOO2vASgkUdtcJ9aif5ucmaCXhN5HKmBr+LYmbdMP3imCWzEJEiiDbQlM6Pltu98dITXIM4RkAeQrajw0h+bms6KFT6hbo9yl6bnwoVeStO1OWsc/OnVwdwwPeMgGMNZ0re7THF/hjjpZl3Jri0fBFEktkjIIkuNz/RW5W8z82Qh5ey3Py+YfJW06sUKl2ehDw5U0dtQaIfLUPYt3ukdsQXSex/DG/2bKE7UimdVar7YIaxu8w+WstZX7CcqaBRC/UW63p1LNdPrtXp5uet6HTW9OqoUFivAAAAAC9ob21lL3dpbGxlbS8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yZWVkLXNvbG9tb24tMC4yLjEvc3JjL21hY3Jvcy5ycwAAAC9ob21lL3dpbGxlbS8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yZWVkLXNvbG9tb24tMC4yLjEvc3JjL2dmL3BvbHkucnMAAC9ob21lL3dpbGxlbS8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yZWVkLXNvbG9tb24tMC4yLjEvc3JjL21hY3Jvcy5ycwAAAC9ob21lL3dpbGxlbS8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yZWVkLXNvbG9tb24tMC4yLjEvc3JjL2dmL3BvbHlfbWF0aC5yc2Fzc2VydGlvbiBmYWlsZWQ6IG1zZy5sZW4oKSA8IDI1Ni9ob21lL3dpbGxlbS8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yZWVkLXNvbG9tb24tMC4yLjEvc3JjL2RlY29kZXIucnMAAAAAAAAAAAAAAAAAAC9ob21lL3dpbGxlbS8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yZWVkLXNvbG9tb24tMC4yLjEvc3JjL2RlY29kZXIucnNUb29NYW55RXJyb3JzAAAAAAAvaG9tZS93aWxsZW0vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmVlZC1zb2xvbW9uLTAuMi4xL3NyYy9tYWNyb3MucnMAAAAvaG9tZS93aWxsZW0vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmVlZC1zb2xvbW9uLTAuMi4xL3NyYy9lbmNvZGVyLnJzY2FsbGVkIGBSZXN1bHQ6OnVud3JhcCgpYCBvbiBhbiBgRXJyYCB2YWx1ZQAAAAAAAAAvcnVzdGMvMTlmODk1OGY4MjdlMzc5YmU5YjBmZmM5M2ZjYTU4MGVjOGZmYWM3Ny9zcmMvbGliY29yZS9zbGljZS9tb2QucnMAAAAAAAAAAC9ob21lL3dpbGxlbS8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9kYXRhLWVuY29kaW5nLTIuMS4yL3NyYy9saWIucnMAAAAAAGF0dGVtcHQgdG8gZGl2aWRlIGJ5IHplcm8vaG9tZS93aWxsZW0vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvZGF0YS1lbmNvZGluZy0yLjEuMi9zcmMvbGliLnJzaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZWV4cGxpY2l0IHBhbmljYXNzZXJ0aW9uIGZhaWxlZDogYChsZWZ0ID09IHJpZ2h0KWAKICBsZWZ0OiBgYCwKIHJpZ2h0OiBgYIFQYWRkaW5nVHJhaWxpbmdTeW1ib2xMZW5ndGhEZWNvZGVFcnJvcnBvc2l0aW9ua2luZFVuZGVmaW5lZEZyb21Ub1dyYXBXaWR0aFdyYXBMZW5ndGhFeHRyYVBhZGRpbmdEdXBsaWNhdGVOb3RBc2NpaUJhZFNpemVTcGVjaWZpY2F0aW9uRXJyb3I6IHNyYy9saWJjb3JlL3Jlc3VsdC5yc0Vyck9rYXNzZXJ0aW9uIGZhaWxlZDogYChsZWZ0ID09IHJpZ2h0KWAKICBsZWZ0OiBgYCwKIHJpZ2h0OiBgYDogZGVzdGluYXRpb24gYW5kIHNvdXJjZSBzbGljZXMgaGF2ZSBkaWZmZXJlbnQgbGVuZ3RocwBzcmMvbGliY29yZS9zbGljZS9tb2QucnNjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlc3JjL2xpYmNvcmUvb3B0aW9uLnJzAAAAAAAAAAAAAAAAL3J1c3RjLzE5Zjg5NThmODI3ZTM3OWJlOWIwZmZjOTNmY2E1ODBlYzhmZmFjNzcvc3JjL2xpYmNvcmUvZm10L21vZC5ycwAAOiBzcmMvbGliY29yZS9yZXN1bHQucnNzcmMvbGliYWxsb2MvcmF3X3ZlYy5yc2NhcGFjaXR5IG92ZXJmbG93YSBmb3JtYXR0aW5nIHRyYWl0IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yAABgZnJvbV9zdHJfcmFkaXhfaW50OiBtdXN0IGxpZSBpbiB0aGUgcmFuZ2UgYFsyLCAzNl1gIC0gZm91bmQgc3JjL2xpYmNvcmUvbnVtL21vZC5ycy4uaW5kZXggb3V0IG9mIGJvdW5kczogdGhlIGxlbiBpcyAgYnV0IHRoZSBpbmRleCBpcyBjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlc3JjL2xpYmNvcmUvb3B0aW9uLnJzOiBzcmMvbGliY29yZS9zbGljZS9tb2QucnNpbmRleCAgb3V0IG9mIHJhbmdlIGZvciBz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IQICAgICAgICAgICAgICIiMkJSYCJwIoAgICKSorAiwtLi8wAgIxAgICMgICAgICAgICMwICNAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICNQI2AjcCAgICAgICAjgCOQICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICOjs8AgICAj0CAj4/QEFCQ0RFRgICAkcCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICSAICAgICAgICAgICSQICAgICOwIAAQICAgIDAgICAgQCBQYCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICOQAAAAQAAAAEAAAAPQAAAABBmM/AAAugBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAq1kEbmFtZQGjWdkBABVfX3diaW5kZ2VuX3N0cmluZ19uZXcBEF9fd2JpbmRnZW5fdGhyb3cCEl9fd2JpbmRnZW5fcmV0aHJvdwMTX193YmdfZW5jb2RpbmdfZnJlZQQMZW5jb2RpbmdfbmV3BQ9lbmNvZGluZ19lbmNvZGUGD2VuY29kaW5nX2RlY29kZQcTZW5jb2RpbmdfaXNfY29ycnVwdAgyPCZUIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aDhiMGRhN2Y0ODFhZTdmM2IJDF9fcnVzdF9hbGxvYwoOX19ydXN0X2RlYWxsb2MLDl9fcnVzdF9yZWFsbG9jDBNfX3J1c3RfYWxsb2NfemVyb2VkDSp3YXNtX2JpbmRnZW46OnRocm93X3N0cjo6aDBmZGFjZGQzNTA5YTBkMWIOKndhc21fYmluZGdlbjo6dGhyb3dfdmFsOjpoYTU2NmRhNmMzZjVmNzdmNA8xd2FzbV9iaW5kZ2VuOjpfX3J0Ojp0aHJvd19udWxsOjpoMDhlYTIzMTM0MzVkZTEwNBAyd2FzbV9iaW5kZ2VuOjpfX3J0Ojpib3Jyb3dfZmFpbDo6aDhiZDc3MWFhOTNkYzBlMTERHl9fd2JpbmRnZW5fZ2xvYmFsX2FyZ3VtZW50X3B0chIRX193YmluZGdlbl9tYWxsb2MTD19fd2JpbmRnZW5fZnJlZRQiaGNpZDo6d2l0aF9oY2swOjpoNGMwNmQzOGFkODAzOWI1NhUqaGNpZDo6SGNpZEVuY29kaW5nOjpuZXc6OmgwNWJkNzRjZTRkNjRhOTRkFiJoY2lkOjp3aXRoX2hjYTA6OmgxYmNkZmVhMTJjZGQxODU2FyJoY2lkOjp3aXRoX2hjczA6Omg3ZDA1ZmYxOTAwZmNlOTFjGC1oY2lkOjpIY2lkRW5jb2Rpbmc6OmVuY29kZTo6aDQ2YmVhYTU5YWNiMmZjZDEZLWhjaWQ6OkhjaWRFbmNvZGluZzo6ZGVjb2RlOjpoNTE3YmE2OTYxZGRkMzUyMBoxaGNpZDo6SGNpZEVuY29kaW5nOjpwcmVfZGVjb2RlOjpoMGI1ZjFkN2JjZjEzMjdjYhsxaGNpZDo6SGNpZEVuY29kaW5nOjppc19jb3JydXB0OjpoOGQxYjAwMmJlMjk1NWM1YxxLPGFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCwgQT4+OjphbGxvY2F0ZV9pbjo6e3tjbG9zdXJlfX06Omg3ZTU5MTExNjVlNjkzYjE2HSloY2lkOjp1dGlsOjpjYXBfZGVjb2RlOjpoY2E4YTZkYWU3NTkzMGJjOR4qaGNpZDo6dXRpbDo6YjMyX2NvcnJlY3Q6OmgwNmNkOGNjNzQ0Nzg2NzNmHzA8JlQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGI2NDIxOWU2NDdkMTM4ZWMgMGNvcmU6OnB0cjo6cmVhbF9kcm9wX2luX3BsYWNlOjpoNTc4ZDQ3YzdiYjEyNzc1NiFEPGhjaWQ6OmVycm9yOjpIY2lkRXJyb3IgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGM0OTkxYjFmMDk0MzAxMzYiMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoOThmYTNiOGEwMzFmNmNmOSM7Y29yZTo6c2xpY2U6OjxpbXBsIFtUXT46OmNvcHlfZnJvbV9zbGljZTo6aGQ2NzUwOTFkNjE1MzI0NWIkUzxyZWVkX3NvbG9tb246OmJ1ZmZlcjo6QnVmZmVyIGFzIGNvcmU6Om9wczo6ZGVyZWY6OkRlcmVmPjo6ZGVyZWY6Omg5NTk1Y2JlOWFkYTg2YmExJUI8W3U4XSBhcyByZWVkX3NvbG9tb246OmdmOjpwb2x5X21hdGg6OkFkZD46OmFkZDo6aDhiNGNlNGIwMmIxNDhlYzMmQjxbdThdIGFzIHJlZWRfc29sb21vbjo6Z2Y6OnBvbHlfbWF0aDo6RGl2Pjo6ZGl2OjpoYTI1ZWVmZmQ2MjE5MzU2Yyc2cmVlZF9zb2xvbW9uOjpkZWNvZGVyOjpEZWNvZGVyOjpuZXc6OmhlOTc0YTYwNWJmNjg5NzM1KERyZWVkX3NvbG9tb246OmRlY29kZXI6OkRlY29kZXI6OmNvcnJlY3RfZXJyX2NvdW50OjpoMTYxZTAwM2RmNGZmMDMxMik/cmVlZF9zb2xvbW9uOjpkZWNvZGVyOjpEZWNvZGVyOjppc19jb3JydXB0ZWQ6OmhlNDU3Y2RkMTFkM2Q4ZjEwKjpyZWVkX3NvbG9tb246OmRlY29kZXI6OkRlY29kZXI6OmNvcnJlY3Q6OmhmZTYyZDc1MjJjYTZkMjZiK1E8cmVlZF9zb2xvbW9uOjpkZWNvZGVyOjpEZWNvZGVyRXJyb3IgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDJmMTVhM2U5MGIwNzg1ZmMsNnJlZWRfc29sb21vbjo6ZW5jb2Rlcjo6RW5jb2Rlcjo6bmV3OjpoZTM3ZGJkN2IzNmQ3MzhlMy05cmVlZF9zb2xvbW9uOjplbmNvZGVyOjpFbmNvZGVyOjplbmNvZGU6OmhjZTRlMDE1YTA2ODIwNTRmLjA8JlQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDdjMDAyNTBhNzZkZmJjODMvMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoOGQ3ZmMyZjdlZDI0Y2I3NjBHPGRhdGFfZW5jb2Rpbmc6OkRlY29kZUtpbmQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDRkMTdhZWQ5MmUwYTRkOTQxMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoZWIzZDkwMDQ0YzJjOTBjMDJTPGRhdGFfZW5jb2Rpbmc6OlNwZWNpZmljYXRpb25FcnJvckltcGwgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDQ1MTg3ZTgzN2ZhYjRjOTgzMGNvcmU6OnB0cjo6cmVhbF9kcm9wX2luX3BsYWNlOjpoMzBlNmJmZGIzYmI0NWNkYTQtZGF0YV9lbmNvZGluZzo6ZW5jb2RlX2Jhc2U6OmgwODllYWQxNTE5YmE1NDhmNS1kYXRhX2VuY29kaW5nOjplbmNvZGVfYmFzZTo6aDNkMDYxMmY4YTNiODVkYmQ2LWRhdGFfZW5jb2Rpbmc6OmVuY29kZV9iYXNlOjpoNDVjMzQzN2RmMjI2MWNjODctZGF0YV9lbmNvZGluZzo6ZW5jb2RlX2Jhc2U6Omg2YTNmOTg0Mzg5Njk0YzRlOC1kYXRhX2VuY29kaW5nOjplbmNvZGVfYmFzZTo6aDkyOGZhOTYwMzg5ODM5YzE5LWRhdGFfZW5jb2Rpbmc6OmVuY29kZV9iYXNlOjpoOTdhOWVhZDIzN2NmMzViMjoxZGF0YV9lbmNvZGluZzo6ZGVjb2RlX2Jhc2VfbXV0OjpoMjE3MDYzMmUyODFiMjQ2ZDsxZGF0YV9lbmNvZGluZzo6ZGVjb2RlX2Jhc2VfbXV0OjpoMzRiZGExMDQyZjk3ODgyMjwxZGF0YV9lbmNvZGluZzo6ZGVjb2RlX2Jhc2VfbXV0OjpoM2Y1NzFhMDQzZTMwMzg5MT0xZGF0YV9lbmNvZGluZzo6ZGVjb2RlX2Jhc2VfbXV0OjpoNDMxYzc1NjVmNDFmNTBjZD4xZGF0YV9lbmNvZGluZzo6ZGVjb2RlX2Jhc2VfbXV0OjpoNDdlMGQxYTkzNzViZTI2ND8xZGF0YV9lbmNvZGluZzo6ZGVjb2RlX2Jhc2VfbXV0OjpoNWY3NjMwMDM2NzAwMGQ5N0AxZGF0YV9lbmNvZGluZzo6ZGVjb2RlX2Jhc2VfbXV0OjpoNmU3NTA3YTgwZGUzNGZkMUExZGF0YV9lbmNvZGluZzo6ZGVjb2RlX2Jhc2VfbXV0OjpoOTExZDBkMjZjMzY1MWU2OEIxZGF0YV9lbmNvZGluZzo6ZGVjb2RlX2Jhc2VfbXV0OjpoYTc2Mjk3ZjhlMDUyMDg4YkMxZGF0YV9lbmNvZGluZzo6ZGVjb2RlX2Jhc2VfbXV0OjpoYThjMDg2MTVhYTI0MjljYUQxZGF0YV9lbmNvZGluZzo6ZGVjb2RlX2Jhc2VfbXV0OjpoYjZmZTVhOGQ3YTcwOTcyZkUxZGF0YV9lbmNvZGluZzo6ZGVjb2RlX2Jhc2VfbXV0OjpoZjMxNjI0Mzk5NGFiNTRmY0YwZGF0YV9lbmNvZGluZzo6ZGVjb2RlX3BhZF9tdXQ6OmgyNmMxMmYzZmQzZGExNDlhRzBkYXRhX2VuY29kaW5nOjpkZWNvZGVfcGFkX211dDo6aDI4MTg4OTZlYjc1MTkzNWFIMGRhdGFfZW5jb2Rpbmc6OmRlY29kZV9wYWRfbXV0OjpoMmM1YjQ5MWY0YTJkYjYxYkkwZGF0YV9lbmNvZGluZzo6ZGVjb2RlX3BhZF9tdXQ6OmgzZjE2ODIxNDcyNzZkMGVmSjBkYXRhX2VuY29kaW5nOjpkZWNvZGVfcGFkX211dDo6aDQ0ODliNjdlMDlmOTU3ZmVLMGRhdGFfZW5jb2Rpbmc6OmRlY29kZV9wYWRfbXV0OjpoNDZmMzk4NDFiMDJlNmRlNkwwZGF0YV9lbmNvZGluZzo6ZGVjb2RlX3BhZF9tdXQ6Omg1MDJlYWQzZDg1ZTliNTA4TTBkYXRhX2VuY29kaW5nOjpkZWNvZGVfcGFkX211dDo6aDU4MTJhNWNkMDRhZDgxZDBOMGRhdGFfZW5jb2Rpbmc6OmRlY29kZV9wYWRfbXV0OjpoNzZkZDJkZmMyY2RmZDIyME8wZGF0YV9lbmNvZGluZzo6ZGVjb2RlX3BhZF9tdXQ6OmhhZjc2MjExNWQ3NTA5NTgwUDBkYXRhX2VuY29kaW5nOjpkZWNvZGVfcGFkX211dDo6aGMzZDk3M2MzNzg3NDc4YTBRMGRhdGFfZW5jb2Rpbmc6OmRlY29kZV9wYWRfbXV0OjpoZjJkNWE1MTlkYTM2MjcxY1I0ZGF0YV9lbmNvZGluZzo6U3BlY2lmaWNhdGlvbjo6bmV3OjpoN2NmNTEwMjIwZDY1MGI4ZFM2ZGF0YV9lbmNvZGluZzo6RW5jb2Rpbmc6OmVuY29kZV9sZW46Omg5OWM4YTc1NzA0OGFlOTZmVDZkYXRhX2VuY29kaW5nOjpFbmNvZGluZzo6ZW5jb2RlX211dDo6aDA5ZTdkNmFhMTMxNDYwOWFVMmRhdGFfZW5jb2Rpbmc6OkVuY29kaW5nOjplbmNvZGU6OmgzMjg5ODk0NjA0ZjZhMTZiVjZkYXRhX2VuY29kaW5nOjpFbmNvZGluZzo6ZGVjb2RlX2xlbjo6aDJhMWMzOGQ2NTAzNTkxYjZXNmRhdGFfZW5jb2Rpbmc6OkVuY29kaW5nOjpkZWNvZGVfbXV0OjpoNmVlMjJmM2ZjZDUyNDEzOVgyZGF0YV9lbmNvZGluZzo6RW5jb2Rpbmc6OmRlY29kZTo6aGY0MTUxOTAyNGM5NjJjY2NZOWRhdGFfZW5jb2Rpbmc6OlNwZWNpZmljYXRpb246OmVuY29kaW5nOjpoYWY1NTZjYWMyNTBmNjI5OVpIPGRhdGFfZW5jb2Rpbmc6OkRlY29kZUVycm9yIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmgyYzlhZGMwZDg1NzgzNjQzW088ZGF0YV9lbmNvZGluZzo6U3BlY2lmaWNhdGlvbkVycm9yIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhhNzZjY2M0ODc5ODUyZDljXEs8YWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULCBBPj46OmFsbG9jYXRlX2luOjp7e2Nsb3N1cmV9fTo6aGFhNzRlM2NlZWM4ODg2MWZdMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoZDVmNjY0NWVmNzM4NmM5Y14wY29yZTo6cHRyOjpyZWFsX2Ryb3BfaW5fcGxhY2U6OmgzMGU2YmZkYjNiYjQ1Y2RhXy5jb3JlOjpyZXN1bHQ6OnVud3JhcF9mYWlsZWQ6OmhiNjlmNjQ0ZDViZjRkOTAwYDA8JlQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDU2NDNiMGZjMDY1NDNlMzFhMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoOWI0NzhhYzAxY2Q1NDk0N2IyPCZUIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aGQ1MzhmMWIxMjY5OTIzNWNjNTxUIGFzIGNvcmU6OmFueTo6QW55Pjo6Z2V0X3R5cGVfaWQ6OmgzNTUxM2JmYWExMjMyODBlZDU8VCBhcyBjb3JlOjphbnk6OkFueT46OmdldF90eXBlX2lkOjpoNDM1ZWZhNGJmYWI0ZDRlZWUuc3RkOjpwYW5pY2tpbmc6OmJlZ2luX3BhbmljOjpoZjdlODRmNTkxZGZhNGNhOWYwY29yZTo6cHRyOjpyZWFsX2Ryb3BfaW5fcGxhY2U6Omg1M2I5NGE2YzY5OTEwY2Q4ZzBjb3JlOjpwdHI6OnJlYWxfZHJvcF9pbl9wbGFjZTo6aGM1YTY3NjQ2YjYwYTAzZWVoXjxzdGQ6OnBhbmlja2luZzo6YmVnaW5fcGFuaWM6OlBhbmljUGF5bG9hZDxBPiBhcyBjb3JlOjpwYW5pYzo6Qm94TWVVcD46OmdldDo6aGZmMGMyOGJhOTI0MTkxZTRpZDxzdGQ6OnBhbmlja2luZzo6YmVnaW5fcGFuaWM6OlBhbmljUGF5bG9hZDxBPiBhcyBjb3JlOjpwYW5pYzo6Qm94TWVVcD46OmJveF9tZV91cDo6aDJiYWYzMDIxMGJlMDdjMDJqMDxhbGxvYzo6dmVjOjpWZWM8VD4+OjpyZXNlcnZlOjpoZTkxY2RiMDM2OTFkODI2OWs1PFQgYXMgY29yZTo6YW55OjpBbnk+OjpnZXRfdHlwZV9pZDo6aDA2ZjI4NTFiNGY2MTUzNDlsNTxUIGFzIGNvcmU6OmFueTo6QW55Pjo6Z2V0X3R5cGVfaWQ6OmhjNDRkNWU2YTI4NWEzMGQ2bTQ8Y29yZTo6b3B0aW9uOjpPcHRpb248VD4+Ojp1bndyYXA6Omg4ZTg1MDFhNDc4NDJiNWY4bjQ8Y29yZTo6b3B0aW9uOjpPcHRpb248VD4+Ojp1bndyYXA6OmhjNjhkMzkzYzUxZjFlYTVlbzJzdGQ6OnBhbmlja2luZzo6YmVnaW5fcGFuaWNfZm10OjpoZDcyNDMwNmRhZTU0ZjMzZXAwY29yZTo6cHRyOjpyZWFsX2Ryb3BfaW5fcGxhY2U6OmgwNzVkM2I5NzdhYzg3MDRicTBjb3JlOjpwdHI6OnJlYWxfZHJvcF9pbl9wbGFjZTo6aDgzMzU4Nzg2ODFmMGFlYjlyMGNvcmU6OnB0cjo6cmVhbF9kcm9wX2luX3BsYWNlOjpoYmU1NjkwYjI4M2FkYmYyZHM7PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfY2hhcjo6aGQ0YWYzZTY2Nzg5MWQ4MzF0OjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX2ZtdDo6aGJkNDEzZDExN2U3N2I2YWF1OjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX3N0cjo6aDM0YTE2ZjllM2NhMWE0NWF2JnN0ZDo6cHJvY2Vzczo6YWJvcnQ6Omg4MWIwYzI3ZGE4NWE5OTQ4d1Y8c3RkOjpzeXNfY29tbW9uOjp0aHJlYWRfbG9jYWw6OktleSBhcyBjb3JlOjpvcHM6OmRyb3A6OkRyb3A+Ojpkcm9wOjpoYjJkNjU1OWEwMzJiN2YyNXg3c3RkOjphbGxvYzo6ZGVmYXVsdF9hbGxvY19lcnJvcl9ob29rOjpoZWYxMTBkNjY4MDE2NjllNHkIcnVzdF9vb216C19fcmRsX2FsbG9jew1fX3JkbF9kZWFsbG9jfA1fX3JkbF9yZWFsbG9jfRJfX3JkbF9hbGxvY196ZXJvZWR+EXJ1c3RfYmVnaW5fdW53aW5kfzVzdGQ6OnBhbmlja2luZzo6Y29udGludWVfcGFuaWNfZm10OjpoNDA4MDUxNWU0NzYzNTQyNYABN3N0ZDo6cGFuaWNraW5nOjpydXN0X3BhbmljX3dpdGhfaG9vazo6aDEzYjllODg1OTA4MDkwYTmBAWw8c3RkOjpwYW5pY2tpbmc6OmNvbnRpbnVlX3BhbmljX2ZtdDo6UGFuaWNQYXlsb2FkPCdhPiBhcyBjb3JlOjpwYW5pYzo6Qm94TWVVcD46OmJveF9tZV91cDo6aDljYTk0YzMzYjIwZjI4ZTiCAWY8c3RkOjpwYW5pY2tpbmc6OmNvbnRpbnVlX3BhbmljX2ZtdDo6UGFuaWNQYXlsb2FkPCdhPiBhcyBjb3JlOjpwYW5pYzo6Qm94TWVVcD46OmdldDo6aGQ5NTM1YmQ5NzJmYjk0NzSDAQpydXN0X3BhbmljhAESX19ydXN0X3N0YXJ0X3BhbmljhQFBZGxtYWxsb2M6OmRsbWFsbG9jOjpEbG1hbGxvYzo6bWFsbG9jX2FsaWdubWVudDo6aGFjYmNlMzVlZDc2YzZhNWGGAUJkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jOjpjYWxsb2NfbXVzdF9jbGVhcjo6aDcyMGFhYjRlY2Y0MTA0YzmHATdkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jOjptYWxsb2M6Omg4NzE2YjA3N2M3ZTRkYTFkiAFDZGxtYWxsb2M6OmRsbWFsbG9jOjpEbG1hbGxvYzo6dW5saW5rX2xhcmdlX2NodW5rOjpoMjE5OTA4Zjk1MDFkODdlNYkBQ2RsbWFsbG9jOjpkbG1hbGxvYzo6RGxtYWxsb2M6Omluc2VydF9sYXJnZV9jaHVuazo6aGI1NGFkZDkxOTM2MTNlMTOKAThkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jOjpyZWFsbG9jOjpoZjY3ODc0ODFkMmVlZDE2ZosBPmRsbWFsbG9jOjpkbG1hbGxvYzo6RGxtYWxsb2M6OmRpc3Bvc2VfY2h1bms6OmhjZTY5MWJkOTM0MzhiNTA5jAE1ZGxtYWxsb2M6OmRsbWFsbG9jOjpEbG1hbGxvYzo6ZnJlZTo6aGZlMzhlODdkZTgxNDM2NWGNATlkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jOjptZW1hbGlnbjo6aDAyYTY5Yjg1ZTNiN2NjZDCOATI8JlQgYXMgY29yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoYzlmOGNmMWJlZTNlMWE5ZY8BMGNvcmU6OnB0cjo6cmVhbF9kcm9wX2luX3BsYWNlOjpoMTUxNjRhMWYzODNjMzc0ZJABLmNvcmU6OnJlc3VsdDo6dW53cmFwX2ZhaWxlZDo6aDVkY2YxNjlmOTE3ZTAyOGGRATs8Jm11dCBXIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9jaGFyOjpoOWNkMWNlYmZhMWI0ODdlM5IBLmFsbG9jOjpzdHJpbmc6OlN0cmluZzo6cHVzaDo6aDM2MjUxZTBiZTZmYzQ3ZWWTATo8Jm11dCBXIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9mbXQ6Omg4MDlhOWM1MjRjOTVmYWFhlAE6PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfc3RyOjpoNTc4MDU0YTg3OWQzYTIyOJUBMDxhbGxvYzo6dmVjOjpWZWM8VD4+OjpyZXNlcnZlOjpoMzkzMzdkZGNlNjExMDIyY5YBM2FsbG9jOjphbGxvYzo6aGFuZGxlX2FsbG9jX2Vycm9yOjpoY2U5MzMxOWU3YTA1MDhmZpcBSzxhbGxvYzo6cmF3X3ZlYzo6UmF3VmVjPFQsIEE+Pjo6YWxsb2NhdGVfaW46Ont7Y2xvc3VyZX19OjpoMTMyMjRhN2E4ZmU0MmY5N5gBNGFsbG9jOjpyYXdfdmVjOjpjYXBhY2l0eV9vdmVyZmxvdzo6aDA1ZWQ0ZDI0YTAzYmNhNmKZASVhbGxvYzo6Zm10Ojpmb3JtYXQ6Omg5ZTdlZTY4OGMzOGNiNjE2mgEwY29yZTo6cHRyOjpyZWFsX2Ryb3BfaW5fcGxhY2U6OmgwNDg1NzFjZDBiM2MzNzA1mwEwY29yZTo6cHRyOjpyZWFsX2Ryb3BfaW5fcGxhY2U6OmgxMWIxMTJmZWM1OTc0NzU4nAEwY29yZTo6cHRyOjpyZWFsX2Ryb3BfaW5fcGxhY2U6Omg3M2M2MDliMzQ4ZjZjZjY3nQE2Y29yZTo6cGFuaWNraW5nOjpwYW5pY19ib3VuZHNfY2hlY2s6OmhkMWMwMTM0ZjU0NDIyMTBlngE0Y29yZTo6c2xpY2U6OnNsaWNlX2luZGV4X2xlbl9mYWlsOjpoNDkwMzA5NWY1ZmZhMTExMp8BKWNvcmU6OnBhbmlja2luZzo6cGFuaWM6OmhjOGMzZGQ5OTEyN2M5MTdkoAE2Y29yZTo6c2xpY2U6OnNsaWNlX2luZGV4X29yZGVyX2ZhaWw6OmgzYjBkZWExMTRjNzRjYWMxoQEtY29yZTo6cGFuaWNraW5nOjpwYW5pY19mbXQ6OmhjNTYyMzk4ZWEwODBjOGNhogEsY29yZTo6Zm10OjpGb3JtYXR0ZXI6OnBhZDo6aDg1NzJhY2U1MDliZjI3OTejAS5jb3JlOjpzdHI6OnNsaWNlX2Vycm9yX2ZhaWw6Omg4MDUzNDM0ZTNhODA2YTUxpAFJY29yZTo6Zm10OjpudW06OjxpbXBsIGNvcmU6OmZtdDo6RGlzcGxheSBmb3IgdTMyPjo6Zm10OjpoM2YyNDM1ZTZmM2U0YWM4M6UBLGNvcmU6Om51bTo6ZnJvbV9zdHJfcmFkaXg6OmhkMzQ4M2EwMDI3YzIwMDVmpgEjY29yZTo6Zm10Ojp3cml0ZTo6aDE3MGVlZDcwMTBhMTc5OGanAUo8Y29yZTo6b3BzOjpyYW5nZTo6UmFuZ2U8SWR4PiBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoN2U5ZjcyMDUzZjJmNWUwNagBSWNvcmU6OmZtdDo6bnVtOjo8aW1wbCBjb3JlOjpmbXQ6OkRlYnVnIGZvciB1c2l6ZT46OmZtdDo6aDRiYmIyMTY0YzAwZDc2N2SpATU8VCBhcyBjb3JlOjphbnk6OkFueT46OmdldF90eXBlX2lkOjpoMTQ1N2RlNWU1MTA5MjA5NqoBQWNvcmU6OmNoYXI6Om1ldGhvZHM6OjxpbXBsIGNoYXI+Ojplc2NhcGVfZGVidWc6OmhjY2Q4MTZlZjU2YTgxZGM1qwE9Y29yZTo6dW5pY29kZTo6Ym9vbF90cmllOjpCb29sVHJpZTo6bG9va3VwOjpoMTRiZDJiZmZiNTY4ZTdjNKwBMmNvcmU6OnVuaWNvZGU6OnByaW50YWJsZTo6Y2hlY2s6OmhiN2NiNWQzYTMyZDZmZWQxrQEyY29yZTo6cGFuaWM6OlBhbmljSW5mbzo6bWVzc2FnZTo6aDk4Njg5OTMyMGIzY2FmZDGuATNjb3JlOjpwYW5pYzo6UGFuaWNJbmZvOjpsb2NhdGlvbjo6aDVmNzVkMWRlZDI0NWIzNzGvATI8JlQgYXMgY29yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoZDZjNWY3ODM1ZGYwNDQyYrABPmNvcmU6OnBhbmljOjpMb2NhdGlvbjo6aW50ZXJuYWxfY29uc3RydWN0b3I6OmhlMGVlN2FjMmUwNjQwYTVisQEuY29yZTo6cGFuaWM6OkxvY2F0aW9uOjpmaWxlOjpoMmUwZDA0YWQwNzcwNTk5NLIBLmNvcmU6OnBhbmljOjpMb2NhdGlvbjo6bGluZTo6aGYyNWI4N2ExYjRjYzNlM2KzATBjb3JlOjpwYW5pYzo6TG9jYXRpb246OmNvbHVtbjo6aDljZTkyNzJiNjIyYjRiNDW0ATpjb3JlOjpmbXQ6OmJ1aWxkZXJzOjpEZWJ1Z1N0cnVjdDo6ZmllbGQ6OmgyZTA0MjBiZGRmNzc0OTVktQEuY29yZTo6c2xpY2U6Om1lbWNocjo6bWVtY2hyOjpoNjE2ZWJhYTkzMjBkMjFkY7YBRTxpOCBhcyBjb3JlOjpzbGljZTo6U2xpY2VDb250YWlucz46OnNsaWNlX2NvbnRhaW5zOjpoYjVlNzYwZGU3YmYxMTNlNLcBgAFjb3JlOjpzdHI6OnRyYWl0czo6PGltcGwgY29yZTo6c2xpY2U6OlNsaWNlSW5kZXg8c3RyPiBmb3IgY29yZTo6b3BzOjpyYW5nZTo6UmFuZ2U8dXNpemU+Pjo6aW5kZXg6Ont7Y2xvc3VyZX19OjpoNGY3NzVjYmU1ZDMwZDgzNbgBSWNvcmU6OmZtdDo6bnVtOjo8aW1wbCBjb3JlOjpmbXQ6Okxvd2VySGV4IGZvciBpOD46OmZtdDo6aGFmMmQwZDRlNWNjNzE1Nzm5AUhjb3JlOjpmbXQ6Om51bTo6PGltcGwgY29yZTo6Zm10OjpEaXNwbGF5IGZvciB1OD46OmZtdDo6aGJlM2UyNDE3MDY5NDUwYjK6ATI8Y2hhciBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoNTQ3OTRiNTdmMjQxMTA3Y7sBVzxjb3JlOjpmbXQ6OmJ1aWxkZXJzOjpQYWRBZGFwdGVyPCdfPiBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfc3RyOjpoNjk0YzJmYzEzZGQ5YjVmYrwBO2NvcmU6OmZtdDo6YnVpbGRlcnM6OkRlYnVnU3RydWN0OjpmaW5pc2g6OmgwOTg5NWE3ZjAyZTRmNjBmvQE5Y29yZTo6Zm10OjpidWlsZGVyczo6RGVidWdUdXBsZTo6ZmllbGQ6OmgxNGFiY2NkOGEzNDg1MWZjvgE6Y29yZTo6Zm10OjpidWlsZGVyczo6RGVidWdUdXBsZTo6ZmluaXNoOjpoNzdhNTA5MjQ4MzYxYWM3ML8BL2NvcmU6OmZtdDo6V3JpdGU6OndyaXRlX2NoYXI6Omg2MGE0MDM2YmFmNjhjNjNjwAEuY29yZTo6Zm10OjpXcml0ZTo6d3JpdGVfZm10OjpoM2VkNTRjMmMwN2Q4Y2M3ZsEBOjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX3N0cjo6aDU1YmI5OGU0Mzc4NjA5NTTCATs8Jm11dCBXIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9jaGFyOjpoZWMzNDRmZjQzNmFiZGM0NMMBOjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX2ZtdDo6aDQxNjBkNzZiNDM4ZjE5MGXEATRjb3JlOjpmbXQ6OkFyZ3VtZW50VjE6OnNob3dfdXNpemU6OmgyMzk3MWZkNWYxZGM0NzYwxQFIPGNvcmU6OmZtdDo6QXJndW1lbnRzPCdfPiBhcyBjb3JlOjpmbXQ6OkRpc3BsYXk+OjpmbXQ6OmgxNmRhZTQ2ZTJkM2I1MjNhxgE1Y29yZTo6Zm10OjpGb3JtYXR0ZXI6OnBhZF9pbnRlZ3JhbDo6aDlhNmJiNzIyNmU0N2EyZWXHAThjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6ZGVidWdfbG93ZXJfaGV4OjpoODNmYzg1YWI5M2NjYjZmM8gBOGNvcmU6OmZtdDo6Rm9ybWF0dGVyOjpkZWJ1Z191cHBlcl9oZXg6OmgyZWE3ZDRlNTRmMDExMmIzyQE1Y29yZTo6Zm10OjpGb3JtYXR0ZXI6OmRlYnVnX3N0cnVjdDo6aGUxMjhlNzYxNjhjMjIyZTjKATRjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6ZGVidWdfdHVwbGU6Omg3MWIxN2Q5ZWE4MGMzN2IzywExPHN0ciBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoYzE5OGMyODc2YmE3M2Q3McwBMzxzdHIgYXMgY29yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoM2I4YTkwODZkMWEzYzQxNM0BSmNvcmU6OmZtdDo6bnVtOjo8aW1wbCBjb3JlOjpmbXQ6Okxvd2VySGV4IGZvciBpMzI+OjpmbXQ6Omg2Njc3ZGM1NDQwZjlkZThhzgE3Y29yZTo6bnVtOjo8aW1wbCB1OD46OmZyb21fc3RyX3JhZGl4OjpoNjE2M2ZlZTcwMTJhOTliOc8BRjxjb3JlOjpudW06OlBhcnNlSW50RXJyb3IgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDk4ZTQzNzk0ZDBkZjkwMGPQAUdjb3JlOjpmbXQ6Om51bTo6PGltcGwgY29yZTo6Zm10OjpCaW5hcnkgZm9yIGk4Pjo6Zm10OjpoZWExYjMzOWI1NTFlOTkxY9EBSWNvcmU6OmZtdDo6bnVtOjo8aW1wbCBjb3JlOjpmbXQ6OlVwcGVySGV4IGZvciBpOD46OmZtdDo6aGYyNGEwYmM1YWIwNGEyNWLSAUpjb3JlOjpmbXQ6Om51bTo6PGltcGwgY29yZTo6Zm10OjpVcHBlckhleCBmb3IgaTMyPjo6Zm10OjpoZDdkODIxZWRhNDE5NmQ0ZdMBPjxjb3JlOjpmbXQ6OkVycm9yIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6Omg2YjUwNzhmOGZjODUxZmEz1AEwPCZUIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6Omg4ZGNmYjliYTg3OTE3MzEz1QEGbWVtc2V01gEGbWVtY3B51wEHbWVtbW92ZdgBBm1lbWNtcABtCXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QEMjAxNQxwcm9jZXNzZWQtYnkCBXJ1c3RjJTEuMzMuMC1uaWdodGx5ICgxOWY4OTU4ZjggMjAxOS0wMS0yMykMd2FzbS1iaW5kZ2VuBjAuMi4zMw==";

if (typeof Buffer === 'undefined') {
  bytes = Uint8Array.from(atob(base64), function (c) {
    return c.charCodeAt(0);
  });
} else {
  bytes = Buffer.from(base64, 'base64');
}

var booted = WebAssembly.instantiate(bytes, {
  './bindgen': import_b
}).then(function (obj) {
  var wasm = obj.instance;
  exports.memory = memory = wasm.exports.memory;
  exports.__wbg_encoding_free = __wbg_encoding_free = wasm.exports.__wbg_encoding_free;
  exports.encoding_new = encoding_new = wasm.exports.encoding_new;
  exports.encoding_encode = encoding_encode = wasm.exports.encoding_encode;
  exports.encoding_decode = encoding_decode = wasm.exports.encoding_decode;
  exports.encoding_is_corrupt = encoding_is_corrupt = wasm.exports.encoding_is_corrupt;
  exports.__wbindgen_global_argument_ptr = __wbindgen_global_argument_ptr = wasm.exports.__wbindgen_global_argument_ptr;
  exports.__wbindgen_malloc = __wbindgen_malloc = wasm.exports.__wbindgen_malloc;
  exports.__wbindgen_free = __wbindgen_free = wasm.exports.__wbindgen_free;
});
exports.booted = booted;
var memory;
exports.memory = memory;

var __wbg_encoding_free;

exports.__wbg_encoding_free = __wbg_encoding_free;
var encoding_new;
exports.encoding_new = encoding_new;
var encoding_encode;
exports.encoding_encode = encoding_encode;
var encoding_decode;
exports.encoding_decode = encoding_decode;
var encoding_is_corrupt;
exports.encoding_is_corrupt = encoding_is_corrupt;

var __wbindgen_global_argument_ptr;

exports.__wbindgen_global_argument_ptr = __wbindgen_global_argument_ptr;

var __wbindgen_malloc;

exports.__wbindgen_malloc = __wbindgen_malloc;

var __wbindgen_free;

exports.__wbindgen_free = __wbindgen_free;
},{"./bindgen":"../lib/browser/bindgen.js","buffer":"../node_modules/buffer/index.js"}],"../lib/browser/bindgen.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__wbindgen_string_new = __wbindgen_string_new;
exports.__wbindgen_rethrow = __wbindgen_rethrow;
exports.__wbindgen_throw = __wbindgen_throw;
exports.Encoding = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var wasm = _interopRequireWildcard(require("./bindgen_bg"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* tslint:disable */
var cachedTextEncoder = new TextEncoder('utf-8');
var cachegetUint8Memory = null;

function getUint8Memory() {
  if (cachegetUint8Memory === null || cachegetUint8Memory.buffer !== wasm.memory.buffer) {
    cachegetUint8Memory = new Uint8Array(wasm.memory.buffer);
  }

  return cachegetUint8Memory;
}

var WASM_VECTOR_LEN = 0;

function passStringToWasm(arg) {
  var buf = cachedTextEncoder.encode(arg);

  var ptr = wasm.__wbindgen_malloc(buf.length);

  getUint8Memory().set(buf, ptr);
  WASM_VECTOR_LEN = buf.length;
  return ptr;
}

function passArray8ToWasm(arg) {
  var ptr = wasm.__wbindgen_malloc(arg.length * 1);

  getUint8Memory().set(arg, ptr / 1);
  WASM_VECTOR_LEN = arg.length;
  return ptr;
}

var cachedTextDecoder = new TextDecoder('utf-8');

function getStringFromWasm(ptr, len) {
  return cachedTextDecoder.decode(getUint8Memory().subarray(ptr, ptr + len));
}

var cachedGlobalArgumentPtr = null;

function globalArgumentPtr() {
  if (cachedGlobalArgumentPtr === null) {
    cachedGlobalArgumentPtr = wasm.__wbindgen_global_argument_ptr();
  }

  return cachedGlobalArgumentPtr;
}

var cachegetUint32Memory = null;

function getUint32Memory() {
  if (cachegetUint32Memory === null || cachegetUint32Memory.buffer !== wasm.memory.buffer) {
    cachegetUint32Memory = new Uint32Array(wasm.memory.buffer);
  }

  return cachegetUint32Memory;
}

function getArrayU8FromWasm(ptr, len) {
  return getUint8Memory().subarray(ptr / 1, ptr / 1 + len);
}

var heap = new Array(32);
heap.fill(undefined);
heap.push(undefined, null, true, false);
var heap_next = heap.length;

function addHeapObject(obj) {
  if (heap_next === heap.length) heap.push(heap.length + 1);
  var idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj;
  return idx;
}

function __wbindgen_string_new(p, l) {
  return addHeapObject(getStringFromWasm(p, l));
}

function getObject(idx) {
  return heap[idx];
}

function dropObject(idx) {
  if (idx < 36) return;
  heap[idx] = heap_next;
  heap_next = idx;
}

function takeObject(idx) {
  var ret = getObject(idx);
  dropObject(idx);
  return ret;
}

function __wbindgen_rethrow(idx) {
  throw takeObject(idx);
}

function freeEncoding(ptr) {
  wasm.__wbg_encoding_free(ptr);
}
/**
*/


var Encoding =
/*#__PURE__*/
function () {
  (0, _createClass2.default)(Encoding, [{
    key: "free",
    value: function free() {
      var ptr = this.ptr;
      this.ptr = 0;
      freeEncoding(ptr);
    }
    /**
    * @param {string} arg0
    * @returns {}
    */

  }]);

  function Encoding(arg0) {
    (0, _classCallCheck2.default)(this, Encoding);
    var ptr0 = passStringToWasm(arg0);
    var len0 = WASM_VECTOR_LEN;

    try {
      this.ptr = wasm.encoding_new(ptr0, len0);
    } finally {
      wasm.__wbindgen_free(ptr0, len0 * 1);
    }
  }
  /**
  * @param {Uint8Array} arg0
  * @returns {string}
  */


  (0, _createClass2.default)(Encoding, [{
    key: "encode",
    value: function encode(arg0) {
      var ptr0 = passArray8ToWasm(arg0);
      var len0 = WASM_VECTOR_LEN;
      var retptr = globalArgumentPtr();

      try {
        wasm.encoding_encode(retptr, this.ptr, ptr0, len0);
        var mem = getUint32Memory();
        var rustptr = mem[retptr / 4];
        var rustlen = mem[retptr / 4 + 1];
        var realRet = getStringFromWasm(rustptr, rustlen).slice();

        wasm.__wbindgen_free(rustptr, rustlen * 1);

        return realRet;
      } finally {
        wasm.__wbindgen_free(ptr0, len0 * 1);
      }
    }
    /**
    * @param {string} arg0
    * @returns {Uint8Array}
    */

  }, {
    key: "decode",
    value: function decode(arg0) {
      var ptr0 = passStringToWasm(arg0);
      var len0 = WASM_VECTOR_LEN;
      var retptr = globalArgumentPtr();

      try {
        wasm.encoding_decode(retptr, this.ptr, ptr0, len0);
        var mem = getUint32Memory();
        var rustptr = mem[retptr / 4];
        var rustlen = mem[retptr / 4 + 1];
        var realRet = getArrayU8FromWasm(rustptr, rustlen).slice();

        wasm.__wbindgen_free(rustptr, rustlen * 1);

        return realRet;
      } finally {
        wasm.__wbindgen_free(ptr0, len0 * 1);
      }
    }
    /**
    * @param {string} arg0
    * @returns {boolean}
    */

  }, {
    key: "is_corrupt",
    value: function is_corrupt(arg0) {
      var ptr0 = passStringToWasm(arg0);
      var len0 = WASM_VECTOR_LEN;

      try {
        return wasm.encoding_is_corrupt(this.ptr, ptr0, len0) !== 0;
      } finally {
        wasm.__wbindgen_free(ptr0, len0 * 1);
      }
    }
  }]);
  return Encoding;
}();

exports.Encoding = Encoding;

function __wbindgen_throw(ptr, len) {
  throw new Error(getStringFromWasm(ptr, len));
}
},{"@babel/runtime/helpers/classCallCheck":"../node_modules/@babel/runtime/helpers/classCallCheck.js","@babel/runtime/helpers/createClass":"../node_modules/@babel/runtime/helpers/createClass.js","./bindgen_bg":"../lib/browser/bindgen_bg.js"}],"../lib/browser/index.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Encoding = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var bindgen = _interopRequireWildcard(require("./bindgen"));

var _bindgen_bg = require("./bindgen_bg");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint camelcase:0 */
function txError(fn) {
  try {
    return fn();
  } catch (e) {
    throw new Error(e);
  }
}

function checkFixBuffer(buf) {
  if (typeof Buffer === 'function' && buf instanceof Buffer) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }

  return buf;
}

var Encoding =
/*#__PURE__*/
function () {
  function Encoding(encoding_name) {
    var _this = this;

    (0, _classCallCheck2.default)(this, Encoding);
    return _bindgen_bg.booted.then(function () {
      if (typeof encoding_name !== 'string') {
        throw new Error('encoding_name must be a string');
      }

      _this._raw = txError(function () {
        return new bindgen.Encoding(encoding_name);
      });
      return _this;
    });
  }

  (0, _createClass2.default)(Encoding, [{
    key: "encode",
    value: function encode(data) {
      var _this2 = this;

      data = checkFixBuffer(data);

      if (!(data instanceof Uint8Array)) {
        throw new Error('data must be a Uint8Array');
      }

      return txError(function () {
        return _this2._raw.encode(data);
      });
    }
  }, {
    key: "decode",
    value: function decode(data) {
      var _this3 = this;

      if (typeof data !== 'string') {
        throw new Error('data must be a string');
      }

      return txError(function () {
        return _this3._raw.decode(data);
      });
    }
  }, {
    key: "is_corrupt",
    value: function is_corrupt(data) {
      var _this4 = this;

      if (typeof data !== 'string') {
        throw new Error('data must be a string');
      }

      return txError(function () {
        return _this4._raw.is_corrupt(data);
      });
    }
  }]);
  return Encoding;
}();

exports.Encoding = Encoding;
},{"@babel/runtime/helpers/classCallCheck":"../node_modules/@babel/runtime/helpers/classCallCheck.js","@babel/runtime/helpers/createClass":"../node_modules/@babel/runtime/helpers/createClass.js","./bindgen":"../lib/browser/bindgen.js","./bindgen_bg":"../lib/browser/bindgen_bg.js","buffer":"../node_modules/buffer/index.js"}],"../node_modules/assertion-error/index.js":[function(require,module,exports) {
/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */

function exclude () {
  var excludes = [].slice.call(arguments);

  function excludeProps (res, obj) {
    Object.keys(obj).forEach(function (key) {
      if (!~excludes.indexOf(key)) res[key] = obj[key];
    });
  }

  return function extendExclude () {
    var args = [].slice.call(arguments)
      , i = 0
      , res = {};

    for (; i < args.length; i++) {
      excludeProps(res, args[i]);
    }

    return res;
  };
};

/*!
 * Primary Exports
 */

module.exports = AssertionError;

/**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */

function AssertionError (message, _props, ssf) {
  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')
    , props = extend(_props || {});

  // default values
  this.message = message || 'Unspecified AssertionError';
  this.showDiff = false;

  // copy from properties
  for (var key in props) {
    this[key] = props[key];
  }

  // capture stack trace
  ssf = ssf || AssertionError;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, ssf);
  } else {
    try {
      throw new Error();
    } catch(e) {
      this.stack = e.stack;
    }
  }
}

/*!
 * Inherit from Error.prototype
 */

AssertionError.prototype = Object.create(Error.prototype);

/*!
 * Statically set name
 */

AssertionError.prototype.name = 'AssertionError';

/*!
 * Ensure correct constructor
 */

AssertionError.prototype.constructor = AssertionError;

/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */

AssertionError.prototype.toJSON = function (stack) {
  var extend = exclude('constructor', 'toJSON', 'stack')
    , props = extend({ name: this.name }, this);

  // include stack if exists and not turned off
  if (false !== stack && this.stack) {
    props.stack = this.stack;
  }

  return props;
};

},{}],"../node_modules/pathval/index.js":[function(require,module,exports) {
'use strict';

/* !
 * Chai - pathval utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */

/**
 * ### .hasProperty(object, name)
 *
 * This allows checking whether an object has own
 * or inherited from prototype chain named property.
 *
 * Basically does the same thing as the `in`
 * operator but works properly with null/undefined values
 * and other primitives.
 *
 *     var obj = {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *
 * The following would be the results.
 *
 *     hasProperty(obj, 'str');  // true
 *     hasProperty(obj, 'constructor');  // true
 *     hasProperty(obj, 'bar');  // false
 *
 *     hasProperty(obj.str, 'length'); // true
 *     hasProperty(obj.str, 1);  // true
 *     hasProperty(obj.str, 5);  // false
 *
 *     hasProperty(obj.arr, 'length');  // true
 *     hasProperty(obj.arr, 2);  // true
 *     hasProperty(obj.arr, 3);  // false
 *
 * @param {Object} object
 * @param {String|Symbol} name
 * @returns {Boolean} whether it exists
 * @namespace Utils
 * @name hasProperty
 * @api public
 */

function hasProperty(obj, name) {
  if (typeof obj === 'undefined' || obj === null) {
    return false;
  }

  // The `in` operator does not work with primitives.
  return name in Object(obj);
}

/* !
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `internalGetPathValue`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be infinitely deep and nested.
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 * * Literal dots and brackets (not delimiter) must be backslash-escaped.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */

function parsePath(path) {
  var str = path.replace(/([^\\])\[/g, '$1.[');
  var parts = str.match(/(\\\.|[^.]+?)+/g);
  return parts.map(function mapMatches(value) {
    var regexp = /^\[(\d+)\]$/;
    var mArr = regexp.exec(value);
    var parsed = null;
    if (mArr) {
      parsed = { i: parseFloat(mArr[1]) };
    } else {
      parsed = { p: value.replace(/\\([.\[\]])/g, '$1') };
    }

    return parsed;
  });
}

/* !
 * ## internalGetPathValue(obj, parsed[, pathDepth])
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(obj, parsed);
 *
 * @param {Object} object to search against
 * @param {Object} parsed definition from `parsePath`.
 * @param {Number} depth (nesting level) of the property we want to retrieve
 * @returns {Object|Undefined} value
 * @api private
 */

function internalGetPathValue(obj, parsed, pathDepth) {
  var temporaryValue = obj;
  var res = null;
  pathDepth = (typeof pathDepth === 'undefined' ? parsed.length : pathDepth);

  for (var i = 0; i < pathDepth; i++) {
    var part = parsed[i];
    if (temporaryValue) {
      if (typeof part.p === 'undefined') {
        temporaryValue = temporaryValue[part.i];
      } else {
        temporaryValue = temporaryValue[part.p];
      }

      if (i === (pathDepth - 1)) {
        res = temporaryValue;
      }
    }
  }

  return res;
}

/* !
 * ## internalSetPathValue(obj, value, parsed)
 *
 * Companion function for `parsePath` that sets
 * the value located at a parsed address.
 *
 *  internalSetPathValue(obj, 'value', parsed);
 *
 * @param {Object} object to search and define on
 * @param {*} value to use upon set
 * @param {Object} parsed definition from `parsePath`
 * @api private
 */

function internalSetPathValue(obj, val, parsed) {
  var tempObj = obj;
  var pathDepth = parsed.length;
  var part = null;
  // Here we iterate through every part of the path
  for (var i = 0; i < pathDepth; i++) {
    var propName = null;
    var propVal = null;
    part = parsed[i];

    // If it's the last part of the path, we set the 'propName' value with the property name
    if (i === (pathDepth - 1)) {
      propName = typeof part.p === 'undefined' ? part.i : part.p;
      // Now we set the property with the name held by 'propName' on object with the desired val
      tempObj[propName] = val;
    } else if (typeof part.p !== 'undefined' && tempObj[part.p]) {
      tempObj = tempObj[part.p];
    } else if (typeof part.i !== 'undefined' && tempObj[part.i]) {
      tempObj = tempObj[part.i];
    } else {
      // If the obj doesn't have the property we create one with that name to define it
      var next = parsed[i + 1];
      // Here we set the name of the property which will be defined
      propName = typeof part.p === 'undefined' ? part.i : part.p;
      // Here we decide if this property will be an array or a new object
      propVal = typeof next.p === 'undefined' ? [] : {};
      tempObj[propName] = propVal;
      tempObj = tempObj[propName];
    }
  }
}

/**
 * ### .getPathInfo(object, path)
 *
 * This allows the retrieval of property info in an
 * object given a string path.
 *
 * The path info consists of an object with the
 * following properties:
 *
 * * parent - The parent object of the property referenced by `path`
 * * name - The name of the final property, a number if it was an array indexer
 * * value - The value of the property, if it exists, otherwise `undefined`
 * * exists - Whether the property exists or not
 *
 * @param {Object} object
 * @param {String} path
 * @returns {Object} info
 * @namespace Utils
 * @name getPathInfo
 * @api public
 */

function getPathInfo(obj, path) {
  var parsed = parsePath(path);
  var last = parsed[parsed.length - 1];
  var info = {
    parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,
    name: last.p || last.i,
    value: internalGetPathValue(obj, parsed),
  };
  info.exists = hasProperty(info.parent, info.name);

  return info;
}

/**
 * ### .getPathValue(object, path)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue(obj, 'prop1.str'); // Hello
 *     getPathValue(obj, 'prop1.att[2]'); // b
 *     getPathValue(obj, 'prop2.arr[0].nested'); // Universe
 *
 * @param {Object} object
 * @param {String} path
 * @returns {Object} value or `undefined`
 * @namespace Utils
 * @name getPathValue
 * @api public
 */

function getPathValue(obj, path) {
  var info = getPathInfo(obj, path);
  return info.value;
}

/**
 * ### .setPathValue(object, path, value)
 *
 * Define the value in an object at a given string path.
 *
 * ```js
 * var obj = {
 *     prop1: {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *   , prop2: {
 *         arr: [ { nested: 'Universe' } ]
 *       , str: 'Hello again!'
 *     }
 * };
 * ```
 *
 * The following would be acceptable.
 *
 * ```js
 * var properties = require('tea-properties');
 * properties.set(obj, 'prop1.str', 'Hello Universe!');
 * properties.set(obj, 'prop1.arr[2]', 'B');
 * properties.set(obj, 'prop2.arr[0].nested.value', { hello: 'universe' });
 * ```
 *
 * @param {Object} object
 * @param {String} path
 * @param {Mixed} value
 * @api private
 */

function setPathValue(obj, path, val) {
  var parsed = parsePath(path);
  internalSetPathValue(obj, val, parsed);
  return obj;
}

module.exports = {
  hasProperty: hasProperty,
  getPathInfo: getPathInfo,
  getPathValue: getPathValue,
  setPathValue: setPathValue,
};

},{}],"../node_modules/chai/lib/chai/utils/flag.js":[function(require,module,exports) {
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .flag(object, key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or `undefined` if
 * the value is not set.
 *
 *     utils.flag(this, 'foo', 'bar'); // setter
 *     utils.flag(this, 'foo'); // getter, returns `bar`
 *
 * @param {Object} object constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @namespace Utils
 * @name flag
 * @api private
 */
module.exports = function flag(obj, key, value) {
  var flags = obj.__flags || (obj.__flags = Object.create(null));

  if (arguments.length === 3) {
    flags[key] = value;
  } else {
    return flags[key];
  }
};
},{}],"../node_modules/chai/lib/chai/utils/test.js":[function(require,module,exports) {
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */
var flag = require('./flag');
/**
 * ### .test(object, expression)
 *
 * Test and object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name test
 */


module.exports = function test(obj, args) {
  var negate = flag(obj, 'negate'),
      expr = args[0];
  return negate ? !expr : expr;
};
},{"./flag":"../node_modules/chai/lib/chai/utils/flag.js"}],"../node_modules/type-detect/type-detect.js":[function(require,module,exports) {
var define;
var global = arguments[3];
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.typeDetect = factory();
})(this, function () {
  'use strict';
  /* !
   * type-detect
   * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
   * MIT Licensed
   */

  var promiseExists = typeof Promise === 'function';
  /* eslint-disable no-undef */

  var globalObject = (typeof self === "undefined" ? "undefined" : _typeof(self)) === 'object' ? self : global; // eslint-disable-line id-blacklist

  var symbolExists = typeof Symbol !== 'undefined';
  var mapExists = typeof Map !== 'undefined';
  var setExists = typeof Set !== 'undefined';
  var weakMapExists = typeof WeakMap !== 'undefined';
  var weakSetExists = typeof WeakSet !== 'undefined';
  var dataViewExists = typeof DataView !== 'undefined';
  var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';
  var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';
  var setEntriesExists = setExists && typeof Set.prototype.entries === 'function';
  var mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';
  var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf(new Set().entries());
  var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf(new Map().entries());
  var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
  var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
  var stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === 'function';
  var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());
  var toStringLeftSliceLength = 8;
  var toStringRightSliceLength = -1;
  /**
   * ### typeOf (obj)
   *
   * Uses `Object.prototype.toString` to determine the type of an object,
   * normalising behaviour across engine versions & well optimised.
   *
   * @param {Mixed} object
   * @return {String} object type
   * @api public
   */

  function typeDetect(obj) {
    /* ! Speed optimisation
     * Pre:
     *   string literal     x 3,039,035 ops/sec ±1.62% (78 runs sampled)
     *   boolean literal    x 1,424,138 ops/sec ±4.54% (75 runs sampled)
     *   number literal     x 1,653,153 ops/sec ±1.91% (82 runs sampled)
     *   undefined          x 9,978,660 ops/sec ±1.92% (75 runs sampled)
     *   function           x 2,556,769 ops/sec ±1.73% (77 runs sampled)
     * Post:
     *   string literal     x 38,564,796 ops/sec ±1.15% (79 runs sampled)
     *   boolean literal    x 31,148,940 ops/sec ±1.10% (79 runs sampled)
     *   number literal     x 32,679,330 ops/sec ±1.90% (78 runs sampled)
     *   undefined          x 32,363,368 ops/sec ±1.07% (82 runs sampled)
     *   function           x 31,296,870 ops/sec ±0.96% (83 runs sampled)
     */
    var typeofObj = _typeof(obj);

    if (typeofObj !== 'object') {
      return typeofObj;
    }
    /* ! Speed optimisation
     * Pre:
     *   null               x 28,645,765 ops/sec ±1.17% (82 runs sampled)
     * Post:
     *   null               x 36,428,962 ops/sec ±1.37% (84 runs sampled)
     */


    if (obj === null) {
      return 'null';
    }
    /* ! Spec Conformance
     * Test: `Object.prototype.toString.call(window)``
     *  - Node === "[object global]"
     *  - Chrome === "[object global]"
     *  - Firefox === "[object Window]"
     *  - PhantomJS === "[object Window]"
     *  - Safari === "[object Window]"
     *  - IE 11 === "[object Window]"
     *  - IE Edge === "[object Window]"
     * Test: `Object.prototype.toString.call(this)``
     *  - Chrome Worker === "[object global]"
     *  - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
     *  - Safari Worker === "[object DedicatedWorkerGlobalScope]"
     *  - IE 11 Worker === "[object WorkerGlobalScope]"
     *  - IE Edge Worker === "[object WorkerGlobalScope]"
     */


    if (obj === globalObject) {
      return 'global';
    }
    /* ! Speed optimisation
     * Pre:
     *   array literal      x 2,888,352 ops/sec ±0.67% (82 runs sampled)
     * Post:
     *   array literal      x 22,479,650 ops/sec ±0.96% (81 runs sampled)
     */


    if (Array.isArray(obj) && (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))) {
      return 'Array';
    } // Not caching existence of `window` and related properties due to potential
    // for `window` to be unset before tests in quasi-browser environments.


    if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' && window !== null) {
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/browsers.html#location)
       * WhatWG HTML$7.7.3 - The `Location` interface
       * Test: `Object.prototype.toString.call(window.location)``
       *  - IE <=11 === "[object Object]"
       *  - IE Edge <=13 === "[object Object]"
       */
      if (_typeof(window.location) === 'object' && obj === window.location) {
        return 'Location';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#document)
       * WhatWG HTML$3.1.1 - The `Document` object
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       *       WhatWG HTML states:
       *         > For historical reasons, Window objects must also have a
       *         > writable, configurable, non-enumerable property named
       *         > HTMLDocument whose value is the Document interface object.
       * Test: `Object.prototype.toString.call(document)``
       *  - Chrome === "[object HTMLDocument]"
       *  - Firefox === "[object HTMLDocument]"
       *  - Safari === "[object HTMLDocument]"
       *  - IE <=10 === "[object Document]"
       *  - IE 11 === "[object HTMLDocument]"
       *  - IE Edge <=13 === "[object HTMLDocument]"
       */


      if (_typeof(window.document) === 'object' && obj === window.document) {
        return 'Document';
      }

      if (_typeof(window.navigator) === 'object') {
        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
         * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
         * Test: `Object.prototype.toString.call(navigator.mimeTypes)``
         *  - IE <=10 === "[object MSMimeTypesCollection]"
         */
        if (_typeof(window.navigator.mimeTypes) === 'object' && obj === window.navigator.mimeTypes) {
          return 'MimeTypeArray';
        }
        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
         * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
         * Test: `Object.prototype.toString.call(navigator.plugins)``
         *  - IE <=10 === "[object MSPluginsCollection]"
         */


        if (_typeof(window.navigator.plugins) === 'object' && obj === window.navigator.plugins) {
          return 'PluginArray';
        }
      }

      if ((typeof window.HTMLElement === 'function' || _typeof(window.HTMLElement) === 'object') && obj instanceof window.HTMLElement) {
        /* ! Spec Conformance
        * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
        * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`
        * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``
        *  - IE <=10 === "[object HTMLBlockElement]"
        */
        if (obj.tagName === 'BLOCKQUOTE') {
          return 'HTMLQuoteElement';
        }
        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/#htmltabledatacellelement)
         * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`
         * Note: Most browsers currently adher to the W3C DOM Level 2 spec
         *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
         *       which suggests that browsers should use HTMLTableCellElement for
         *       both TD and TH elements. WhatWG separates these.
         * Test: Object.prototype.toString.call(document.createElement('td'))
         *  - Chrome === "[object HTMLTableCellElement]"
         *  - Firefox === "[object HTMLTableCellElement]"
         *  - Safari === "[object HTMLTableCellElement]"
         */


        if (obj.tagName === 'TD') {
          return 'HTMLTableDataCellElement';
        }
        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/#htmltableheadercellelement)
         * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`
         * Note: Most browsers currently adher to the W3C DOM Level 2 spec
         *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
         *       which suggests that browsers should use HTMLTableCellElement for
         *       both TD and TH elements. WhatWG separates these.
         * Test: Object.prototype.toString.call(document.createElement('th'))
         *  - Chrome === "[object HTMLTableCellElement]"
         *  - Firefox === "[object HTMLTableCellElement]"
         *  - Safari === "[object HTMLTableCellElement]"
         */


        if (obj.tagName === 'TH') {
          return 'HTMLTableHeaderCellElement';
        }
      }
    }
    /* ! Speed optimisation
    * Pre:
    *   Float64Array       x 625,644 ops/sec ±1.58% (80 runs sampled)
    *   Float32Array       x 1,279,852 ops/sec ±2.91% (77 runs sampled)
    *   Uint32Array        x 1,178,185 ops/sec ±1.95% (83 runs sampled)
    *   Uint16Array        x 1,008,380 ops/sec ±2.25% (80 runs sampled)
    *   Uint8Array         x 1,128,040 ops/sec ±2.11% (81 runs sampled)
    *   Int32Array         x 1,170,119 ops/sec ±2.88% (80 runs sampled)
    *   Int16Array         x 1,176,348 ops/sec ±5.79% (86 runs sampled)
    *   Int8Array          x 1,058,707 ops/sec ±4.94% (77 runs sampled)
    *   Uint8ClampedArray  x 1,110,633 ops/sec ±4.20% (80 runs sampled)
    * Post:
    *   Float64Array       x 7,105,671 ops/sec ±13.47% (64 runs sampled)
    *   Float32Array       x 5,887,912 ops/sec ±1.46% (82 runs sampled)
    *   Uint32Array        x 6,491,661 ops/sec ±1.76% (79 runs sampled)
    *   Uint16Array        x 6,559,795 ops/sec ±1.67% (82 runs sampled)
    *   Uint8Array         x 6,463,966 ops/sec ±1.43% (85 runs sampled)
    *   Int32Array         x 5,641,841 ops/sec ±3.49% (81 runs sampled)
    *   Int16Array         x 6,583,511 ops/sec ±1.98% (80 runs sampled)
    *   Int8Array          x 6,606,078 ops/sec ±1.74% (81 runs sampled)
    *   Uint8ClampedArray  x 6,602,224 ops/sec ±1.77% (83 runs sampled)
    */


    var stringTag = symbolToStringTagExists && obj[Symbol.toStringTag];

    if (typeof stringTag === 'string') {
      return stringTag;
    }

    var objPrototype = Object.getPrototypeOf(obj);
    /* ! Speed optimisation
    * Pre:
    *   regex literal      x 1,772,385 ops/sec ±1.85% (77 runs sampled)
    *   regex constructor  x 2,143,634 ops/sec ±2.46% (78 runs sampled)
    * Post:
    *   regex literal      x 3,928,009 ops/sec ±0.65% (78 runs sampled)
    *   regex constructor  x 3,931,108 ops/sec ±0.58% (84 runs sampled)
    */

    if (objPrototype === RegExp.prototype) {
      return 'RegExp';
    }
    /* ! Speed optimisation
    * Pre:
    *   date               x 2,130,074 ops/sec ±4.42% (68 runs sampled)
    * Post:
    *   date               x 3,953,779 ops/sec ±1.35% (77 runs sampled)
    */


    if (objPrototype === Date.prototype) {
      return 'Date';
    }
    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
     * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
     * Test: `Object.prototype.toString.call(Promise.resolve())``
     *  - Chrome <=47 === "[object Object]"
     *  - Edge <=20 === "[object Object]"
     *  - Firefox 29-Latest === "[object Promise]"
     *  - Safari 7.1-Latest === "[object Promise]"
     */


    if (promiseExists && objPrototype === Promise.prototype) {
      return 'Promise';
    }
    /* ! Speed optimisation
    * Pre:
    *   set                x 2,222,186 ops/sec ±1.31% (82 runs sampled)
    * Post:
    *   set                x 4,545,879 ops/sec ±1.13% (83 runs sampled)
    */


    if (setExists && objPrototype === Set.prototype) {
      return 'Set';
    }
    /* ! Speed optimisation
    * Pre:
    *   map                x 2,396,842 ops/sec ±1.59% (81 runs sampled)
    * Post:
    *   map                x 4,183,945 ops/sec ±6.59% (82 runs sampled)
    */


    if (mapExists && objPrototype === Map.prototype) {
      return 'Map';
    }
    /* ! Speed optimisation
    * Pre:
    *   weakset            x 1,323,220 ops/sec ±2.17% (76 runs sampled)
    * Post:
    *   weakset            x 4,237,510 ops/sec ±2.01% (77 runs sampled)
    */


    if (weakSetExists && objPrototype === WeakSet.prototype) {
      return 'WeakSet';
    }
    /* ! Speed optimisation
    * Pre:
    *   weakmap            x 1,500,260 ops/sec ±2.02% (78 runs sampled)
    * Post:
    *   weakmap            x 3,881,384 ops/sec ±1.45% (82 runs sampled)
    */


    if (weakMapExists && objPrototype === WeakMap.prototype) {
      return 'WeakMap';
    }
    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
     * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
     * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``
     *  - Edge <=13 === "[object Object]"
     */


    if (dataViewExists && objPrototype === DataView.prototype) {
      return 'DataView';
    }
    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
     * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
     * Test: `Object.prototype.toString.call(new Map().entries())``
     *  - Edge <=13 === "[object Object]"
     */


    if (mapExists && objPrototype === mapIteratorPrototype) {
      return 'Map Iterator';
    }
    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
     * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
     * Test: `Object.prototype.toString.call(new Set().entries())``
     *  - Edge <=13 === "[object Object]"
     */


    if (setExists && objPrototype === setIteratorPrototype) {
      return 'Set Iterator';
    }
    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
     * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
     * Test: `Object.prototype.toString.call([][Symbol.iterator]())``
     *  - Edge <=13 === "[object Object]"
     */


    if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
      return 'Array Iterator';
    }
    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
     * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
     * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``
     *  - Edge <=13 === "[object Object]"
     */


    if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
      return 'String Iterator';
    }
    /* ! Speed optimisation
    * Pre:
    *   object from null   x 2,424,320 ops/sec ±1.67% (76 runs sampled)
    * Post:
    *   object from null   x 5,838,000 ops/sec ±0.99% (84 runs sampled)
    */


    if (objPrototype === null) {
      return 'Object';
    }

    return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength, toStringRightSliceLength);
  }

  return typeDetect;
});
},{}],"../node_modules/chai/lib/chai/utils/expectTypes.js":[function(require,module,exports) {
/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .expectTypes(obj, types)
 *
 * Ensures that the object being tested against is of a valid type.
 *
 *     utils.expectTypes(this, ['array', 'object', 'string']);
 *
 * @param {Mixed} obj constructed Assertion
 * @param {Array} type A list of allowed types for this assertion
 * @namespace Utils
 * @name expectTypes
 * @api public
 */
var AssertionError = require('assertion-error');

var flag = require('./flag');

var type = require('type-detect');

module.exports = function expectTypes(obj, types) {
  var flagMsg = flag(obj, 'message');
  var ssfi = flag(obj, 'ssfi');
  flagMsg = flagMsg ? flagMsg + ': ' : '';
  obj = flag(obj, 'object');
  types = types.map(function (t) {
    return t.toLowerCase();
  });
  types.sort(); // Transforms ['lorem', 'ipsum'] into 'a lorem, or an ipsum'

  var str = types.map(function (t, index) {
    var art = ~['a', 'e', 'i', 'o', 'u'].indexOf(t.charAt(0)) ? 'an' : 'a';
    var or = types.length > 1 && index === types.length - 1 ? 'or ' : '';
    return or + art + ' ' + t;
  }).join(', ');
  var objType = type(obj).toLowerCase();

  if (!types.some(function (expected) {
    return objType === expected;
  })) {
    throw new AssertionError(flagMsg + 'object tested must be ' + str + ', but ' + objType + ' given', undefined, ssfi);
  }
};
},{"assertion-error":"../node_modules/assertion-error/index.js","./flag":"../node_modules/chai/lib/chai/utils/flag.js","type-detect":"../node_modules/type-detect/type-detect.js"}],"../node_modules/chai/lib/chai/utils/getActual.js":[function(require,module,exports) {
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getActual(object, [actual])
 *
 * Returns the `actual` value for an Assertion.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getActual
 */
module.exports = function getActual(obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
};
},{}],"../node_modules/get-func-name/index.js":[function(require,module,exports) {
'use strict';

/* !
 * Chai - getFuncName utility
 * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getFuncName(constructorFn)
 *
 * Returns the name of a function.
 * When a non-function instance is passed, returns `null`.
 * This also includes a polyfill function if `aFunc.name` is not defined.
 *
 * @name getFuncName
 * @param {Function} funct
 * @namespace Utils
 * @api public
 */

var toString = Function.prototype.toString;
var functionNameMatch = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\s\(\/]+)/;
function getFuncName(aFunc) {
  if (typeof aFunc !== 'function') {
    return null;
  }

  var name = '';
  if (typeof Function.prototype.name === 'undefined' && typeof aFunc.name === 'undefined') {
    // Here we run a polyfill if Function does not support the `name` property and if aFunc.name is not defined
    var match = toString.call(aFunc).match(functionNameMatch);
    if (match) {
      name = match[1];
    }
  } else {
    // If we've got a `name` property we just use it
    name = aFunc.name;
  }

  return name;
}

module.exports = getFuncName;

},{}],"../node_modules/chai/lib/chai/utils/getProperties.js":[function(require,module,exports) {
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getProperties
 * @api public
 */
module.exports = function getProperties(object) {
  var result = Object.getOwnPropertyNames(object);

  function addProperty(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }

  var proto = Object.getPrototypeOf(object);

  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty);
    proto = Object.getPrototypeOf(proto);
  }

  return result;
};
},{}],"../node_modules/chai/lib/chai/utils/getEnumerableProperties.js":[function(require,module,exports) {
/*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getEnumerableProperties(object)
 *
 * This allows the retrieval of enumerable property names of an object,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getEnumerableProperties
 * @api public
 */
module.exports = function getEnumerableProperties(object) {
  var result = [];

  for (var name in object) {
    result.push(name);
  }

  return result;
};
},{}],"../node_modules/chai/lib/chai/config.js":[function(require,module,exports) {
module.exports = {
  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */
  includeStack: false,

  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */
  showDiff: true,

  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */
  truncateThreshold: 40,

  /**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {Boolean}
   * @api public
   */
  useProxy: true,

  /**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the `useProxy` configuration setting is enabled.
   * By default, `then` and `inspect` will not throw an error if they do not exist on the
   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @api public
   */
  proxyExcludedKeys: ['then', 'catch', 'inspect', 'toJSON']
};
},{}],"../node_modules/chai/lib/chai/utils/inspect.js":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// This is (almost) directly from Node.js utils
// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js
var getName = require('get-func-name');

var getProperties = require('./getProperties');

var getEnumerableProperties = require('./getEnumerableProperties');

var config = require('../config');

module.exports = inspect;
/**
 * ### .inspect(obj, [showHidden], [depth], [colors])
 *
 * Echoes the value of a value. Tries to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
 *    properties of objects. Default is false.
 * @param {Number} depth Depth in which to descend in object. Default is 2.
 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
 *    output. Default is false (no coloring).
 * @namespace Utils
 * @name inspect
 */

function inspect(obj, showHidden, depth, colors) {
  var ctx = {
    showHidden: showHidden,
    seen: [],
    stylize: function (str) {
      return str;
    }
  };
  return formatValue(ctx, obj, typeof depth === 'undefined' ? 2 : depth);
} // Returns true if object is a DOM element.


var isDOMElement = function (object) {
  if ((typeof HTMLElement === "undefined" ? "undefined" : _typeof(HTMLElement)) === 'object') {
    return object instanceof HTMLElement;
  } else {
    return object && _typeof(object) === 'object' && 'nodeType' in object && object.nodeType === 1 && typeof object.nodeName === 'string';
  }
};

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (value && typeof value.inspect === 'function' && // Filter out the util module, it's inspect function is special
  value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);

    if (typeof ret !== 'string') {
      ret = formatValue(ctx, ret, recurseTimes);
    }

    return ret;
  } // Primitive types cannot have properties


  var primitive = formatPrimitive(ctx, value);

  if (primitive) {
    return primitive;
  } // If this is a DOM element, try to get the outer HTML.


  if (isDOMElement(value)) {
    if ('outerHTML' in value) {
      return value.outerHTML; // This value does not have an outerHTML attribute,
      //   it could still be an XML element
    } else {
      // Attempt to serialize it
      try {
        if (document.xmlVersion) {
          var xmlSerializer = new XMLSerializer();
          return xmlSerializer.serializeToString(value);
        } else {
          // Firefox 11- do not support outerHTML
          //   It does, however, support innerHTML
          //   Use the following to render the element
          var ns = "http://www.w3.org/1999/xhtml";
          var container = document.createElementNS(ns, '_');
          container.appendChild(value.cloneNode(false));
          var html = container.innerHTML.replace('><', '>' + value.innerHTML + '<');
          container.innerHTML = '';
          return html;
        }
      } catch (err) {// This could be a non-native DOM implementation,
        //   continue with the normal flow:
        //   printing the element as if it is an object.
      }
    }
  } // Look up the keys of the object.


  var visibleKeys = getEnumerableProperties(value);
  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;
  var name, nameSuffix; // Some type of object without properties can be shortcut.
  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
  // a `stack` plus `description` property; ignore those for consistency.

  if (keys.length === 0 || isError(value) && (keys.length === 1 && keys[0] === 'stack' || keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')) {
    if (typeof value === 'function') {
      name = getName(value);
      nameSuffix = name ? ': ' + name : '';
      return ctx.stylize('[Function' + nameSuffix + ']', 'special');
    }

    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }

    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');
    }

    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '',
      array = false,
      typedArray = false,
      braces = ['{', '}'];

  if (isTypedArray(value)) {
    typedArray = true;
    braces = ['[', ']'];
  } // Make Array say that they are Array


  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  } // Make functions say that they are functions


  if (typeof value === 'function') {
    name = getName(value);
    nameSuffix = name ? ': ' + name : '';
    base = ' [Function' + nameSuffix + ']';
  } // Make RegExps say that they are RegExps


  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  } // Make dates with properties first say the date


  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  } // Make error with message first say the error


  if (isError(value)) {
    return formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);
  var output;

  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else if (typedArray) {
    return formatTypedArray(value);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}

function formatPrimitive(ctx, value) {
  switch (_typeof(value)) {
    case 'undefined':
      return ctx.stylize('undefined', 'undefined');

    case 'string':
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');

    case 'number':
      if (value === 0 && 1 / value === -Infinity) {
        return ctx.stylize('-0', 'number');
      }

      return ctx.stylize('' + value, 'number');

    case 'boolean':
      return ctx.stylize('' + value, 'boolean');

    case 'symbol':
      return ctx.stylize(value.toString(), 'symbol');
  } // For some reason typeof null is "object", so special case here.


  if (value === null) {
    return ctx.stylize('null', 'null');
  }
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];

  for (var i = 0, l = value.length; i < l; ++i) {
    if (Object.prototype.hasOwnProperty.call(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }

  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}

function formatTypedArray(value) {
  var str = '[ ';

  for (var i = 0; i < value.length; ++i) {
    if (str.length >= config.truncateThreshold - 7) {
      str += '...';
      break;
    }

    str += value[i] + ', ';
  }

  str += ' ]'; // Removing trailing `, ` if the array was not truncated

  if (str.indexOf(',  ]') !== -1) {
    str = str.replace(',  ]', ' ]');
  }

  return str;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name;
  var propDescriptor = Object.getOwnPropertyDescriptor(value, key);
  var str;

  if (propDescriptor) {
    if (propDescriptor.get) {
      if (propDescriptor.set) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (propDescriptor.set) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }
  }

  if (visibleKeys.indexOf(key) < 0) {
    name = '[' + key + ']';
  }

  if (!str) {
    if (ctx.seen.indexOf(value[key]) < 0) {
      if (recurseTimes === null) {
        str = formatValue(ctx, value[key], null);
      } else {
        str = formatValue(ctx, value[key], recurseTimes - 1);
      }

      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }

  if (typeof name === 'undefined') {
    if (array && key.match(/^\d+$/)) {
      return str;
    }

    name = JSON.stringify('' + key);

    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces) {
  var length = output.reduce(function (prev, cur) {
    return prev + cur.length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

function isTypedArray(ar) {
  // Unfortunately there's no way to check if an object is a TypedArray
  // We have to check if it's one of these types
  return _typeof(ar) === 'object' && /\w+Array]$/.test(objectToString(ar));
}

function isArray(ar) {
  return Array.isArray(ar) || _typeof(ar) === 'object' && objectToString(ar) === '[object Array]';
}

function isRegExp(re) {
  return _typeof(re) === 'object' && objectToString(re) === '[object RegExp]';
}

function isDate(d) {
  return _typeof(d) === 'object' && objectToString(d) === '[object Date]';
}

function isError(e) {
  return _typeof(e) === 'object' && objectToString(e) === '[object Error]';
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
},{"get-func-name":"../node_modules/get-func-name/index.js","./getProperties":"../node_modules/chai/lib/chai/utils/getProperties.js","./getEnumerableProperties":"../node_modules/chai/lib/chai/utils/getEnumerableProperties.js","../config":"../node_modules/chai/lib/chai/config.js"}],"../node_modules/chai/lib/chai/utils/objDisplay.js":[function(require,module,exports) {
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */
var inspect = require('./inspect');

var config = require('../config');
/**
 * ### .objDisplay(object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @name objDisplay
 * @namespace Utils
 * @api public
 */


module.exports = function objDisplay(obj) {
  var str = inspect(obj),
      type = Object.prototype.toString.call(obj);

  if (config.truncateThreshold && str.length >= config.truncateThreshold) {
    if (type === '[object Function]') {
      return !obj.name || obj.name === '' ? '[Function]' : '[Function: ' + obj.name + ']';
    } else if (type === '[object Array]') {
      return '[ Array(' + obj.length + ') ]';
    } else if (type === '[object Object]') {
      var keys = Object.keys(obj),
          kstr = keys.length > 2 ? keys.splice(0, 2).join(', ') + ', ...' : keys.join(', ');
      return '{ Object (' + kstr + ') }';
    } else {
      return str;
    }
  } else {
    return str;
  }
};
},{"./inspect":"../node_modules/chai/lib/chai/utils/inspect.js","../config":"../node_modules/chai/lib/chai/config.js"}],"../node_modules/chai/lib/chai/utils/getMessage.js":[function(require,module,exports) {
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */
var flag = require('./flag'),
    getActual = require('./getActual'),
    objDisplay = require('./objDisplay');
/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - `#{this}` current asserted object
 * - `#{act}` actual value
 * - `#{exp}` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getMessage
 * @api public
 */


module.exports = function getMessage(obj, args) {
  var negate = flag(obj, 'negate'),
      val = flag(obj, 'object'),
      expected = args[3],
      actual = getActual(obj, args),
      msg = negate ? args[2] : args[1],
      flagMsg = flag(obj, 'message');
  if (typeof msg === "function") msg = msg();
  msg = msg || '';
  msg = msg.replace(/#\{this\}/g, function () {
    return objDisplay(val);
  }).replace(/#\{act\}/g, function () {
    return objDisplay(actual);
  }).replace(/#\{exp\}/g, function () {
    return objDisplay(expected);
  });
  return flagMsg ? flagMsg + ': ' + msg : msg;
};
},{"./flag":"../node_modules/chai/lib/chai/utils/flag.js","./getActual":"../node_modules/chai/lib/chai/utils/getActual.js","./objDisplay":"../node_modules/chai/lib/chai/utils/objDisplay.js"}],"../node_modules/chai/lib/chai/utils/transferFlags.js":[function(require,module,exports) {
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for `assertion` to `object`. If
 * `includeAll` is set to `false`, then the base Chai
 * assertion flags (namely `object`, `ssfi`, `lockSsfi`,
 * and `message`) will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAssertion = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags to; usually a new assertion
 * @param {Boolean} includeAll
 * @namespace Utils
 * @name transferFlags
 * @api private
 */
module.exports = function transferFlags(assertion, object, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = Object.create(null));

  if (!object.__flags) {
    object.__flags = Object.create(null);
  }

  includeAll = arguments.length === 3 ? includeAll : true;

  for (var flag in flags) {
    if (includeAll || flag !== 'object' && flag !== 'ssfi' && flag !== 'lockSsfi' && flag != 'message') {
      object.__flags[flag] = flags[flag];
    }
  }
};
},{}],"../node_modules/deep-eql/index.js":[function(require,module,exports) {
'use strict';
/* globals Symbol: false, Uint8Array: false, WeakMap: false */

/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var type = require('type-detect');

function FakeMap() {
  this._key = 'chai/deep-eql__' + Math.random() + Date.now();
}

FakeMap.prototype = {
  get: function getMap(key) {
    return key[this._key];
  },
  set: function setMap(key, value) {
    if (Object.isExtensible(key)) {
      Object.defineProperty(key, this._key, {
        value: value,
        configurable: true
      });
    }
  }
};
var MemoizeMap = typeof WeakMap === 'function' ? WeakMap : FakeMap;
/*!
 * Check to see if the MemoizeMap has recorded a result of the two operands
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @returns {Boolean|null} result
*/

function memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {
  // Technically, WeakMap keys can *only* be objects, not primitives.
  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    return null;
  }

  var leftHandMap = memoizeMap.get(leftHandOperand);

  if (leftHandMap) {
    var result = leftHandMap.get(rightHandOperand);

    if (typeof result === 'boolean') {
      return result;
    }
  }

  return null;
}
/*!
 * Set the result of the equality into the MemoizeMap
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @param {Boolean} result
*/


function memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {
  // Technically, WeakMap keys can *only* be objects, not primitives.
  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    return;
  }

  var leftHandMap = memoizeMap.get(leftHandOperand);

  if (leftHandMap) {
    leftHandMap.set(rightHandOperand, result);
  } else {
    leftHandMap = new MemoizeMap();
    leftHandMap.set(rightHandOperand, result);
    memoizeMap.set(leftHandOperand, leftHandMap);
  }
}
/*!
 * Primary Export
 */


module.exports = deepEqual;
module.exports.MemoizeMap = MemoizeMap;
/**
 * Assert deeply nested sameValue equality between two objects of any type.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
 */

function deepEqual(leftHandOperand, rightHandOperand, options) {
  // If we have a comparator, we can't assume anything; so bail to its check first.
  if (options && options.comparator) {
    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
  }

  var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);

  if (simpleResult !== null) {
    return simpleResult;
  } // Deeper comparisons are pushed through to a larger function


  return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
}
/**
 * Many comparisons can be canceled out early via simple equality or primitive checks.
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @return {Boolean|null} equal match
 */


function simpleEqual(leftHandOperand, rightHandOperand) {
  // Equal references (except for Numbers) can be returned early
  if (leftHandOperand === rightHandOperand) {
    // Handle +-0 cases
    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;
  } // handle NaN cases


  if (leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare
  rightHandOperand !== rightHandOperand // eslint-disable-line no-self-compare
  ) {
      return true;
    } // Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,
  // strings, and undefined, can be compared by reference.


  if (isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    // Easy out b/c it would have passed the first equality check
    return false;
  }

  return null;
}
/*!
 * The main logic of the `deepEqual` function.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
*/


function extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {
  options = options || {};
  options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();
  var comparator = options && options.comparator; // Check if a memoized result exists.

  var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);

  if (memoizeResultLeft !== null) {
    return memoizeResultLeft;
  }

  var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);

  if (memoizeResultRight !== null) {
    return memoizeResultRight;
  } // If a comparator is present, use it.


  if (comparator) {
    var comparatorResult = comparator(leftHandOperand, rightHandOperand); // Comparators may return null, in which case we want to go back to default behavior.

    if (comparatorResult === false || comparatorResult === true) {
      memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);
      return comparatorResult;
    } // To allow comparators to override *any* behavior, we ran them first. Since it didn't decide
    // what to do, we need to make sure to return the basic tests first before we move on.


    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);

    if (simpleResult !== null) {
      // Don't memoize this, it takes longer to set/retrieve than to just compare.
      return simpleResult;
    }
  }

  var leftHandType = type(leftHandOperand);

  if (leftHandType !== type(rightHandOperand)) {
    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);
    return false;
  } // Temporarily set the operands in the memoize object to prevent blowing the stack


  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);
  var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);
  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);
  return result;
}

function extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {
  switch (leftHandType) {
    case 'String':
    case 'Number':
    case 'Boolean':
    case 'Date':
      // If these types are their instance types (e.g. `new Number`) then re-deepEqual against their values
      return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());

    case 'Promise':
    case 'Symbol':
    case 'function':
    case 'WeakMap':
    case 'WeakSet':
    case 'Error':
      return leftHandOperand === rightHandOperand;

    case 'Arguments':
    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
    case 'Array':
      return iterableEqual(leftHandOperand, rightHandOperand, options);

    case 'RegExp':
      return regexpEqual(leftHandOperand, rightHandOperand);

    case 'Generator':
      return generatorEqual(leftHandOperand, rightHandOperand, options);

    case 'DataView':
      return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);

    case 'ArrayBuffer':
      return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);

    case 'Set':
      return entriesEqual(leftHandOperand, rightHandOperand, options);

    case 'Map':
      return entriesEqual(leftHandOperand, rightHandOperand, options);

    default:
      return objectEqual(leftHandOperand, rightHandOperand, options);
  }
}
/*!
 * Compare two Regular Expressions for equality.
 *
 * @param {RegExp} leftHandOperand
 * @param {RegExp} rightHandOperand
 * @return {Boolean} result
 */


function regexpEqual(leftHandOperand, rightHandOperand) {
  return leftHandOperand.toString() === rightHandOperand.toString();
}
/*!
 * Compare two Sets/Maps for equality. Faster than other equality functions.
 *
 * @param {Set} leftHandOperand
 * @param {Set} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function entriesEqual(leftHandOperand, rightHandOperand, options) {
  // IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach
  if (leftHandOperand.size !== rightHandOperand.size) {
    return false;
  }

  if (leftHandOperand.size === 0) {
    return true;
  }

  var leftHandItems = [];
  var rightHandItems = [];
  leftHandOperand.forEach(function gatherEntries(key, value) {
    leftHandItems.push([key, value]);
  });
  rightHandOperand.forEach(function gatherEntries(key, value) {
    rightHandItems.push([key, value]);
  });
  return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);
}
/*!
 * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function iterableEqual(leftHandOperand, rightHandOperand, options) {
  var length = leftHandOperand.length;

  if (length !== rightHandOperand.length) {
    return false;
  }

  if (length === 0) {
    return true;
  }

  var index = -1;

  while (++index < length) {
    if (deepEqual(leftHandOperand[index], rightHandOperand[index], options) === false) {
      return false;
    }
  }

  return true;
}
/*!
 * Simple equality for generator objects such as those returned by generator functions.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function generatorEqual(leftHandOperand, rightHandOperand, options) {
  return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);
}
/*!
 * Determine if the given object has an @@iterator function.
 *
 * @param {Object} target
 * @return {Boolean} `true` if the object has an @@iterator function.
 */


function hasIteratorFunction(target) {
  return typeof Symbol !== 'undefined' && _typeof(target) === 'object' && typeof Symbol.iterator !== 'undefined' && typeof target[Symbol.iterator] === 'function';
}
/*!
 * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
 * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
 *
 * @param {Object} target
 * @returns {Array} an array of entries from the @@iterator function
 */


function getIteratorEntries(target) {
  if (hasIteratorFunction(target)) {
    try {
      return getGeneratorEntries(target[Symbol.iterator]());
    } catch (iteratorError) {
      return [];
    }
  }

  return [];
}
/*!
 * Gets all entries from a Generator. This will consume the generator - which could have side effects.
 *
 * @param {Generator} target
 * @returns {Array} an array of entries from the Generator.
 */


function getGeneratorEntries(generator) {
  var generatorResult = generator.next();
  var accumulator = [generatorResult.value];

  while (generatorResult.done === false) {
    generatorResult = generator.next();
    accumulator.push(generatorResult.value);
  }

  return accumulator;
}
/*!
 * Gets all own and inherited enumerable keys from a target.
 *
 * @param {Object} target
 * @returns {Array} an array of own and inherited enumerable keys from the target.
 */


function getEnumerableKeys(target) {
  var keys = [];

  for (var key in target) {
    keys.push(key);
  }

  return keys;
}
/*!
 * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
 * each key. If any value of the given key is not equal, the function will return false (early).
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function keysEqual(leftHandOperand, rightHandOperand, keys, options) {
  var length = keys.length;

  if (length === 0) {
    return true;
  }

  for (var i = 0; i < length; i += 1) {
    if (deepEqual(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === false) {
      return false;
    }
  }

  return true;
}
/*!
 * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
 * for each enumerable key in the object.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function objectEqual(leftHandOperand, rightHandOperand, options) {
  var leftHandKeys = getEnumerableKeys(leftHandOperand);
  var rightHandKeys = getEnumerableKeys(rightHandOperand);

  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {
    leftHandKeys.sort();
    rightHandKeys.sort();

    if (iterableEqual(leftHandKeys, rightHandKeys) === false) {
      return false;
    }

    return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);
  }

  var leftHandEntries = getIteratorEntries(leftHandOperand);
  var rightHandEntries = getIteratorEntries(rightHandOperand);

  if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {
    leftHandEntries.sort();
    rightHandEntries.sort();
    return iterableEqual(leftHandEntries, rightHandEntries, options);
  }

  if (leftHandKeys.length === 0 && leftHandEntries.length === 0 && rightHandKeys.length === 0 && rightHandEntries.length === 0) {
    return true;
  }

  return false;
}
/*!
 * Returns true if the argument is a primitive.
 *
 * This intentionally returns true for all objects that can be compared by reference,
 * including functions and symbols.
 *
 * @param {Mixed} value
 * @return {Boolean} result
 */


function isPrimitive(value) {
  return value === null || _typeof(value) !== 'object';
}
},{"type-detect":"../node_modules/type-detect/type-detect.js"}],"../node_modules/chai/lib/chai/utils/isProxyEnabled.js":[function(require,module,exports) {
var config = require('../config');
/*!
 * Chai - isProxyEnabled helper
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .isProxyEnabled()
 *
 * Helper function to check if Chai's proxy protection feature is enabled. If
 * proxies are unsupported or disabled via the user's Chai config, then return
 * false. Otherwise, return true.
 *
 * @namespace Utils
 * @name isProxyEnabled
 */


module.exports = function isProxyEnabled() {
  return config.useProxy && typeof Proxy !== 'undefined' && typeof Reflect !== 'undefined';
};
},{"../config":"../node_modules/chai/lib/chai/config.js"}],"../node_modules/chai/lib/chai/utils/addProperty.js":[function(require,module,exports) {
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var chai = require('../../chai');

var flag = require('./flag');

var isProxyEnabled = require('./isProxyEnabled');

var transferFlags = require('./transferFlags');
/**
 * ### .addProperty(ctx, name, getter)
 *
 * Adds a property to the prototype of an object.
 *
 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.instanceof(Foo);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.foo;
 *
 * @param {Object} ctx object to which the property is added
 * @param {String} name of property to add
 * @param {Function} getter function to be used for name
 * @namespace Utils
 * @name addProperty
 * @api public
 */


module.exports = function addProperty(ctx, name, getter) {
  getter = getter === undefined ? function () {} : getter;
  Object.defineProperty(ctx, name, {
    get: function propertyGetter() {
      // Setting the `ssfi` flag to `propertyGetter` causes this function to
      // be the starting point for removing implementation frames from the
      // stack trace of a failed assertion.
      //
      // However, we only want to use this function as the starting point if
      // the `lockSsfi` flag isn't set and proxy protection is disabled.
      //
      // If the `lockSsfi` flag is set, then either this assertion has been
      // overwritten by another assertion, or this assertion is being invoked
      // from inside of another assertion. In the first case, the `ssfi` flag
      // has already been set by the overwriting assertion. In the second
      // case, the `ssfi` flag has already been set by the outer assertion.
      //
      // If proxy protection is enabled, then the `ssfi` flag has already been
      // set by the proxy getter.
      if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {
        flag(this, 'ssfi', propertyGetter);
      }

      var result = getter.call(this);
      if (result !== undefined) return result;
      var newAssertion = new chai.Assertion();
      transferFlags(this, newAssertion);
      return newAssertion;
    },
    configurable: true
  });
};
},{"../../chai":"../node_modules/chai/lib/chai.js","./flag":"../node_modules/chai/lib/chai/utils/flag.js","./isProxyEnabled":"../node_modules/chai/lib/chai/utils/isProxyEnabled.js","./transferFlags":"../node_modules/chai/lib/chai/utils/transferFlags.js"}],"../node_modules/chai/lib/chai/utils/addLengthGuard.js":[function(require,module,exports) {
var fnLengthDesc = Object.getOwnPropertyDescriptor(function () {}, 'length');
/*!
 * Chai - addLengthGuard utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .addLengthGuard(fn, assertionName, isChainable)
 *
 * Define `length` as a getter on the given uninvoked method assertion. The
 * getter acts as a guard against chaining `length` directly off of an uninvoked
 * method assertion, which is a problem because it references `function`'s
 * built-in `length` property instead of Chai's `length` assertion. When the
 * getter catches the user making this mistake, it throws an error with a
 * helpful message.
 *
 * There are two ways in which this mistake can be made. The first way is by
 * chaining the `length` assertion directly off of an uninvoked chainable
 * method. In this case, Chai suggests that the user use `lengthOf` instead. The
 * second way is by chaining the `length` assertion directly off of an uninvoked
 * non-chainable method. Non-chainable methods must be invoked prior to
 * chaining. In this case, Chai suggests that the user consult the docs for the
 * given assertion.
 *
 * If the `length` property of functions is unconfigurable, then return `fn`
 * without modification.
 *
 * Note that in ES6, the function's `length` property is configurable, so once
 * support for legacy environments is dropped, Chai's `length` property can
 * replace the built-in function's `length` property, and this length guard will
 * no longer be necessary. In the mean time, maintaining consistency across all
 * environments is the priority.
 *
 * @param {Function} fn
 * @param {String} assertionName
 * @param {Boolean} isChainable
 * @namespace Utils
 * @name addLengthGuard
 */

module.exports = function addLengthGuard(fn, assertionName, isChainable) {
  if (!fnLengthDesc.configurable) return fn;
  Object.defineProperty(fn, 'length', {
    get: function () {
      if (isChainable) {
        throw Error('Invalid Chai property: ' + assertionName + '.length. Due' + ' to a compatibility issue, "length" cannot directly follow "' + assertionName + '". Use "' + assertionName + '.lengthOf" instead.');
      }

      throw Error('Invalid Chai property: ' + assertionName + '.length. See' + ' docs for proper usage of "' + assertionName + '".');
    }
  });
  return fn;
};
},{}],"../node_modules/chai/lib/chai/utils/proxify.js":[function(require,module,exports) {
var config = require('../config');

var flag = require('./flag');

var getProperties = require('./getProperties');

var isProxyEnabled = require('./isProxyEnabled');
/*!
 * Chai - proxify utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .proxify(object)
 *
 * Return a proxy of given object that throws an error when a non-existent
 * property is read. By default, the root cause is assumed to be a misspelled
 * property, and thus an attempt is made to offer a reasonable suggestion from
 * the list of existing properties. However, if a nonChainableMethodName is
 * provided, then the root cause is instead a failure to invoke a non-chainable
 * method prior to reading the non-existent property.
 *
 * If proxies are unsupported or disabled via the user's Chai config, then
 * return object without modification.
 *
 * @param {Object} obj
 * @param {String} nonChainableMethodName
 * @namespace Utils
 * @name proxify
 */


var builtins = ['__flags', '__methods', '_obj', 'assert'];

module.exports = function proxify(obj, nonChainableMethodName) {
  if (!isProxyEnabled()) return obj;
  return new Proxy(obj, {
    get: function proxyGetter(target, property) {
      // This check is here because we should not throw errors on Symbol properties
      // such as `Symbol.toStringTag`.
      // The values for which an error should be thrown can be configured using
      // the `config.proxyExcludedKeys` setting.
      if (typeof property === 'string' && config.proxyExcludedKeys.indexOf(property) === -1 && !Reflect.has(target, property)) {
        // Special message for invalid property access of non-chainable methods.
        if (nonChainableMethodName) {
          throw Error('Invalid Chai property: ' + nonChainableMethodName + '.' + property + '. See docs for proper usage of "' + nonChainableMethodName + '".');
        } // If the property is reasonably close to an existing Chai property,
        // suggest that property to the user. Only suggest properties with a
        // distance less than 4.


        var suggestion = null;
        var suggestionDistance = 4;
        getProperties(target).forEach(function (prop) {
          if (!Object.prototype.hasOwnProperty(prop) && builtins.indexOf(prop) === -1) {
            var dist = stringDistanceCapped(property, prop, suggestionDistance);

            if (dist < suggestionDistance) {
              suggestion = prop;
              suggestionDistance = dist;
            }
          }
        });

        if (suggestion !== null) {
          throw Error('Invalid Chai property: ' + property + '. Did you mean "' + suggestion + '"?');
        } else {
          throw Error('Invalid Chai property: ' + property);
        }
      } // Use this proxy getter as the starting point for removing implementation
      // frames from the stack trace of a failed assertion. For property
      // assertions, this prevents the proxy getter from showing up in the stack
      // trace since it's invoked before the property getter. For method and
      // chainable method assertions, this flag will end up getting changed to
      // the method wrapper, which is good since this frame will no longer be in
      // the stack once the method is invoked. Note that Chai builtin assertion
      // properties such as `__flags` are skipped since this is only meant to
      // capture the starting point of an assertion. This step is also skipped
      // if the `lockSsfi` flag is set, thus indicating that this assertion is
      // being called from within another assertion. In that case, the `ssfi`
      // flag is already set to the outer assertion's starting point.


      if (builtins.indexOf(property) === -1 && !flag(target, 'lockSsfi')) {
        flag(target, 'ssfi', proxyGetter);
      }

      return Reflect.get(target, property);
    }
  });
};
/**
 * # stringDistanceCapped(strA, strB, cap)
 * Return the Levenshtein distance between two strings, but no more than cap.
 * @param {string} strA
 * @param {string} strB
 * @param {number} number
 * @return {number} min(string distance between strA and strB, cap)
 * @api private
 */


function stringDistanceCapped(strA, strB, cap) {
  if (Math.abs(strA.length - strB.length) >= cap) {
    return cap;
  }

  var memo = []; // `memo` is a two-dimensional array containing distances.
  // memo[i][j] is the distance between strA.slice(0, i) and
  // strB.slice(0, j).

  for (var i = 0; i <= strA.length; i++) {
    memo[i] = Array(strB.length + 1).fill(0);
    memo[i][0] = i;
  }

  for (var j = 0; j < strB.length; j++) {
    memo[0][j] = j;
  }

  for (var i = 1; i <= strA.length; i++) {
    var ch = strA.charCodeAt(i - 1);

    for (var j = 1; j <= strB.length; j++) {
      if (Math.abs(i - j) >= cap) {
        memo[i][j] = cap;
        continue;
      }

      memo[i][j] = Math.min(memo[i - 1][j] + 1, memo[i][j - 1] + 1, memo[i - 1][j - 1] + (ch === strB.charCodeAt(j - 1) ? 0 : 1));
    }
  }

  return memo[strA.length][strB.length];
}
},{"../config":"../node_modules/chai/lib/chai/config.js","./flag":"../node_modules/chai/lib/chai/utils/flag.js","./getProperties":"../node_modules/chai/lib/chai/utils/getProperties.js","./isProxyEnabled":"../node_modules/chai/lib/chai/utils/isProxyEnabled.js"}],"../node_modules/chai/lib/chai/utils/addMethod.js":[function(require,module,exports) {
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var addLengthGuard = require('./addLengthGuard');

var chai = require('../../chai');

var flag = require('./flag');

var proxify = require('./proxify');

var transferFlags = require('./transferFlags');
/**
 * ### .addMethod(ctx, name, method)
 *
 * Adds a method to the prototype of an object.
 *
 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(fooStr).to.be.foo('bar');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for name
 * @namespace Utils
 * @name addMethod
 * @api public
 */


module.exports = function addMethod(ctx, name, method) {
  var methodWrapper = function () {
    // Setting the `ssfi` flag to `methodWrapper` causes this function to be the
    // starting point for removing implementation frames from the stack trace of
    // a failed assertion.
    //
    // However, we only want to use this function as the starting point if the
    // `lockSsfi` flag isn't set.
    //
    // If the `lockSsfi` flag is set, then either this assertion has been
    // overwritten by another assertion, or this assertion is being invoked from
    // inside of another assertion. In the first case, the `ssfi` flag has
    // already been set by the overwriting assertion. In the second case, the
    // `ssfi` flag has already been set by the outer assertion.
    if (!flag(this, 'lockSsfi')) {
      flag(this, 'ssfi', methodWrapper);
    }

    var result = method.apply(this, arguments);
    if (result !== undefined) return result;
    var newAssertion = new chai.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };

  addLengthGuard(methodWrapper, name, false);
  ctx[name] = proxify(methodWrapper, name);
};
},{"./addLengthGuard":"../node_modules/chai/lib/chai/utils/addLengthGuard.js","../../chai":"../node_modules/chai/lib/chai.js","./flag":"../node_modules/chai/lib/chai/utils/flag.js","./proxify":"../node_modules/chai/lib/chai/utils/proxify.js","./transferFlags":"../node_modules/chai/lib/chai/utils/transferFlags.js"}],"../node_modules/chai/lib/chai/utils/overwriteProperty.js":[function(require,module,exports) {
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var chai = require('../../chai');

var flag = require('./flag');

var isProxyEnabled = require('./isProxyEnabled');

var transferFlags = require('./transferFlags');
/**
 * ### .overwriteProperty(ctx, name, fn)
 *
 * Overwrites an already existing property getter and provides
 * access to previous value. Must return function to use as getter.
 *
 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
 *       return function () {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.name).to.equal('bar');
 *         } else {
 *           _super.call(this);
 *         }
 *       }
 *     });
 *
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.ok;
 *
 * @param {Object} ctx object whose property is to be overwritten
 * @param {String} name of property to overwrite
 * @param {Function} getter function that returns a getter function to be used for name
 * @namespace Utils
 * @name overwriteProperty
 * @api public
 */


module.exports = function overwriteProperty(ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name),
      _super = function () {};

  if (_get && 'function' === typeof _get.get) _super = _get.get;
  Object.defineProperty(ctx, name, {
    get: function overwritingPropertyGetter() {
      // Setting the `ssfi` flag to `overwritingPropertyGetter` causes this
      // function to be the starting point for removing implementation frames
      // from the stack trace of a failed assertion.
      //
      // However, we only want to use this function as the starting point if
      // the `lockSsfi` flag isn't set and proxy protection is disabled.
      //
      // If the `lockSsfi` flag is set, then either this assertion has been
      // overwritten by another assertion, or this assertion is being invoked
      // from inside of another assertion. In the first case, the `ssfi` flag
      // has already been set by the overwriting assertion. In the second
      // case, the `ssfi` flag has already been set by the outer assertion.
      //
      // If proxy protection is enabled, then the `ssfi` flag has already been
      // set by the proxy getter.
      if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {
        flag(this, 'ssfi', overwritingPropertyGetter);
      } // Setting the `lockSsfi` flag to `true` prevents the overwritten
      // assertion from changing the `ssfi` flag. By this point, the `ssfi`
      // flag is already set to the correct starting point for this assertion.


      var origLockSsfi = flag(this, 'lockSsfi');
      flag(this, 'lockSsfi', true);
      var result = getter(_super).call(this);
      flag(this, 'lockSsfi', origLockSsfi);

      if (result !== undefined) {
        return result;
      }

      var newAssertion = new chai.Assertion();
      transferFlags(this, newAssertion);
      return newAssertion;
    },
    configurable: true
  });
};
},{"../../chai":"../node_modules/chai/lib/chai.js","./flag":"../node_modules/chai/lib/chai/utils/flag.js","./isProxyEnabled":"../node_modules/chai/lib/chai/utils/isProxyEnabled.js","./transferFlags":"../node_modules/chai/lib/chai/utils/transferFlags.js"}],"../node_modules/chai/lib/chai/utils/overwriteMethod.js":[function(require,module,exports) {
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var addLengthGuard = require('./addLengthGuard');

var chai = require('../../chai');

var flag = require('./flag');

var proxify = require('./proxify');

var transferFlags = require('./transferFlags');
/**
 * ### .overwriteMethod(ctx, name, fn)
 *
 * Overwrites an already existing method and provides
 * access to previous function. Must return function
 * to be used for name.
 *
 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
 *       return function (str) {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.value).to.equal(str);
 *         } else {
 *           _super.apply(this, arguments);
 *         }
 *       }
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.equal('bar');
 *
 * @param {Object} ctx object whose method is to be overwritten
 * @param {String} name of method to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @namespace Utils
 * @name overwriteMethod
 * @api public
 */


module.exports = function overwriteMethod(ctx, name, method) {
  var _method = ctx[name],
      _super = function () {
    throw new Error(name + ' is not a function');
  };

  if (_method && 'function' === typeof _method) _super = _method;

  var overwritingMethodWrapper = function () {
    // Setting the `ssfi` flag to `overwritingMethodWrapper` causes this
    // function to be the starting point for removing implementation frames from
    // the stack trace of a failed assertion.
    //
    // However, we only want to use this function as the starting point if the
    // `lockSsfi` flag isn't set.
    //
    // If the `lockSsfi` flag is set, then either this assertion has been
    // overwritten by another assertion, or this assertion is being invoked from
    // inside of another assertion. In the first case, the `ssfi` flag has
    // already been set by the overwriting assertion. In the second case, the
    // `ssfi` flag has already been set by the outer assertion.
    if (!flag(this, 'lockSsfi')) {
      flag(this, 'ssfi', overwritingMethodWrapper);
    } // Setting the `lockSsfi` flag to `true` prevents the overwritten assertion
    // from changing the `ssfi` flag. By this point, the `ssfi` flag is already
    // set to the correct starting point for this assertion.


    var origLockSsfi = flag(this, 'lockSsfi');
    flag(this, 'lockSsfi', true);
    var result = method(_super).apply(this, arguments);
    flag(this, 'lockSsfi', origLockSsfi);

    if (result !== undefined) {
      return result;
    }

    var newAssertion = new chai.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };

  addLengthGuard(overwritingMethodWrapper, name, false);
  ctx[name] = proxify(overwritingMethodWrapper, name);
};
},{"./addLengthGuard":"../node_modules/chai/lib/chai/utils/addLengthGuard.js","../../chai":"../node_modules/chai/lib/chai.js","./flag":"../node_modules/chai/lib/chai/utils/flag.js","./proxify":"../node_modules/chai/lib/chai/utils/proxify.js","./transferFlags":"../node_modules/chai/lib/chai/utils/transferFlags.js"}],"../node_modules/chai/lib/chai/utils/addChainableMethod.js":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */
var addLengthGuard = require('./addLengthGuard');

var chai = require('../../chai');

var flag = require('./flag');

var proxify = require('./proxify');

var transferFlags = require('./transferFlags');
/*!
 * Module variables
 */
// Check whether `Object.setPrototypeOf` is supported


var canSetPrototype = typeof Object.setPrototypeOf === 'function'; // Without `Object.setPrototypeOf` support, this module will need to add properties to a function.
// However, some of functions' own props are not configurable and should be skipped.

var testFn = function () {};

var excludeNames = Object.getOwnPropertyNames(testFn).filter(function (name) {
  var propDesc = Object.getOwnPropertyDescriptor(testFn, name); // Note: PhantomJS 1.x includes `callee` as one of `testFn`'s own properties,
  // but then returns `undefined` as the property descriptor for `callee`. As a
  // workaround, we perform an otherwise unnecessary type-check for `propDesc`,
  // and then filter it out if it's not an object as it should be.

  if (_typeof(propDesc) !== 'object') return true;
  return !propDesc.configurable;
}); // Cache `Function` properties

var call = Function.prototype.call,
    apply = Function.prototype.apply;
/**
 * ### .addChainableMethod(ctx, name, method, chainingBehavior)
 *
 * Adds a method to an object, such that the method can also be chained.
 *
 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
 *
 * The result can then be used as both a method assertion, executing both `method` and
 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
 *
 *     expect(fooStr).to.be.foo('bar');
 *     expect(fooStr).to.be.foo.equal('foo');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for `name`, when called
 * @param {Function} chainingBehavior function to be called every time the property is accessed
 * @namespace Utils
 * @name addChainableMethod
 * @api public
 */

module.exports = function addChainableMethod(ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== 'function') {
    chainingBehavior = function () {};
  }

  var chainableBehavior = {
    method: method,
    chainingBehavior: chainingBehavior
  }; // save the methods so we can overwrite them later, if we need to.

  if (!ctx.__methods) {
    ctx.__methods = {};
  }

  ctx.__methods[name] = chainableBehavior;
  Object.defineProperty(ctx, name, {
    get: function chainableMethodGetter() {
      chainableBehavior.chainingBehavior.call(this);

      var chainableMethodWrapper = function () {
        // Setting the `ssfi` flag to `chainableMethodWrapper` causes this
        // function to be the starting point for removing implementation
        // frames from the stack trace of a failed assertion.
        //
        // However, we only want to use this function as the starting point if
        // the `lockSsfi` flag isn't set.
        //
        // If the `lockSsfi` flag is set, then this assertion is being
        // invoked from inside of another assertion. In this case, the `ssfi`
        // flag has already been set by the outer assertion.
        //
        // Note that overwriting a chainable method merely replaces the saved
        // methods in `ctx.__methods` instead of completely replacing the
        // overwritten assertion. Therefore, an overwriting assertion won't
        // set the `ssfi` or `lockSsfi` flags.
        if (!flag(this, 'lockSsfi')) {
          flag(this, 'ssfi', chainableMethodWrapper);
        }

        var result = chainableBehavior.method.apply(this, arguments);

        if (result !== undefined) {
          return result;
        }

        var newAssertion = new chai.Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
      };

      addLengthGuard(chainableMethodWrapper, name, true); // Use `Object.setPrototypeOf` if available

      if (canSetPrototype) {
        // Inherit all properties from the object by replacing the `Function` prototype
        var prototype = Object.create(this); // Restore the `call` and `apply` methods from `Function`

        prototype.call = call;
        prototype.apply = apply;
        Object.setPrototypeOf(chainableMethodWrapper, prototype);
      } // Otherwise, redefine all properties (slow!)
      else {
          var asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(function (asserterName) {
            if (excludeNames.indexOf(asserterName) !== -1) {
              return;
            }

            var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
            Object.defineProperty(chainableMethodWrapper, asserterName, pd);
          });
        }

      transferFlags(this, chainableMethodWrapper);
      return proxify(chainableMethodWrapper);
    },
    configurable: true
  });
};
},{"./addLengthGuard":"../node_modules/chai/lib/chai/utils/addLengthGuard.js","../../chai":"../node_modules/chai/lib/chai.js","./flag":"../node_modules/chai/lib/chai/utils/flag.js","./proxify":"../node_modules/chai/lib/chai/utils/proxify.js","./transferFlags":"../node_modules/chai/lib/chai/utils/transferFlags.js"}],"../node_modules/chai/lib/chai/utils/overwriteChainableMethod.js":[function(require,module,exports) {
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var chai = require('../../chai');

var transferFlags = require('./transferFlags');
/**
 * ### .overwriteChainableMethod(ctx, name, method, chainingBehavior)
 *
 * Overwrites an already existing chainable method
 * and provides access to the previous function or
 * property.  Must return functions to be used for
 * name.
 *
 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'lengthOf',
 *       function (_super) {
 *       }
 *     , function (_super) {
 *       }
 *     );
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.have.lengthOf(3);
 *     expect(myFoo).to.have.lengthOf.above(3);
 *
 * @param {Object} ctx object whose method / property is to be overwritten
 * @param {String} name of method / property to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @param {Function} chainingBehavior function that returns a function to be used for property
 * @namespace Utils
 * @name overwriteChainableMethod
 * @api public
 */


module.exports = function overwriteChainableMethod(ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name];
  var _chainingBehavior = chainableBehavior.chainingBehavior;

  chainableBehavior.chainingBehavior = function overwritingChainableMethodGetter() {
    var result = chainingBehavior(_chainingBehavior).call(this);

    if (result !== undefined) {
      return result;
    }

    var newAssertion = new chai.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };

  var _method = chainableBehavior.method;

  chainableBehavior.method = function overwritingChainableMethodWrapper() {
    var result = method(_method).apply(this, arguments);

    if (result !== undefined) {
      return result;
    }

    var newAssertion = new chai.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };
};
},{"../../chai":"../node_modules/chai/lib/chai.js","./transferFlags":"../node_modules/chai/lib/chai/utils/transferFlags.js"}],"../node_modules/chai/lib/chai/utils/compareByInspect.js":[function(require,module,exports) {
/*!
 * Chai - compareByInspect utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */
var inspect = require('./inspect');
/**
 * ### .compareByInspect(mixed, mixed)
 *
 * To be used as a compareFunction with Array.prototype.sort. Compares elements
 * using inspect instead of default behavior of using toString so that Symbols
 * and objects with irregular/missing toString can still be sorted without a
 * TypeError.
 *
 * @param {Mixed} first element to compare
 * @param {Mixed} second element to compare
 * @returns {Number} -1 if 'a' should come before 'b'; otherwise 1
 * @name compareByInspect
 * @namespace Utils
 * @api public
 */


module.exports = function compareByInspect(a, b) {
  return inspect(a) < inspect(b) ? -1 : 1;
};
},{"./inspect":"../node_modules/chai/lib/chai/utils/inspect.js"}],"../node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js":[function(require,module,exports) {
/*!
 * Chai - getOwnEnumerablePropertySymbols utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getOwnEnumerablePropertySymbols(object)
 *
 * This allows the retrieval of directly-owned enumerable property symbols of an
 * object. This function is necessary because Object.getOwnPropertySymbols
 * returns both enumerable and non-enumerable property symbols.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getOwnEnumerablePropertySymbols
 * @api public
 */
module.exports = function getOwnEnumerablePropertySymbols(obj) {
  if (typeof Object.getOwnPropertySymbols !== 'function') return [];
  return Object.getOwnPropertySymbols(obj).filter(function (sym) {
    return Object.getOwnPropertyDescriptor(obj, sym).enumerable;
  });
};
},{}],"../node_modules/chai/lib/chai/utils/getOwnEnumerableProperties.js":[function(require,module,exports) {
/*!
 * Chai - getOwnEnumerableProperties utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */
var getOwnEnumerablePropertySymbols = require('./getOwnEnumerablePropertySymbols');
/**
 * ### .getOwnEnumerableProperties(object)
 *
 * This allows the retrieval of directly-owned enumerable property names and
 * symbols of an object. This function is necessary because Object.keys only
 * returns enumerable property names, not enumerable property symbols.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getOwnEnumerableProperties
 * @api public
 */


module.exports = function getOwnEnumerableProperties(obj) {
  return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));
};
},{"./getOwnEnumerablePropertySymbols":"../node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js"}],"../node_modules/check-error/index.js":[function(require,module,exports) {
'use strict';

/* !
 * Chai - checkError utility
 * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .checkError
 *
 * Checks that an error conforms to a given set of criteria and/or retrieves information about it.
 *
 * @api public
 */

/**
 * ### .compatibleInstance(thrown, errorLike)
 *
 * Checks if two instances are compatible (strict equal).
 * Returns false if errorLike is not an instance of Error, because instances
 * can only be compatible if they're both error instances.
 *
 * @name compatibleInstance
 * @param {Error} thrown error
 * @param {Error|ErrorConstructor} errorLike object to compare against
 * @namespace Utils
 * @api public
 */

function compatibleInstance(thrown, errorLike) {
  return errorLike instanceof Error && thrown === errorLike;
}

/**
 * ### .compatibleConstructor(thrown, errorLike)
 *
 * Checks if two constructors are compatible.
 * This function can receive either an error constructor or
 * an error instance as the `errorLike` argument.
 * Constructors are compatible if they're the same or if one is
 * an instance of another.
 *
 * @name compatibleConstructor
 * @param {Error} thrown error
 * @param {Error|ErrorConstructor} errorLike object to compare against
 * @namespace Utils
 * @api public
 */

function compatibleConstructor(thrown, errorLike) {
  if (errorLike instanceof Error) {
    // If `errorLike` is an instance of any error we compare their constructors
    return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor;
  } else if (errorLike.prototype instanceof Error || errorLike === Error) {
    // If `errorLike` is a constructor that inherits from Error, we compare `thrown` to `errorLike` directly
    return thrown.constructor === errorLike || thrown instanceof errorLike;
  }

  return false;
}

/**
 * ### .compatibleMessage(thrown, errMatcher)
 *
 * Checks if an error's message is compatible with a matcher (String or RegExp).
 * If the message contains the String or passes the RegExp test,
 * it is considered compatible.
 *
 * @name compatibleMessage
 * @param {Error} thrown error
 * @param {String|RegExp} errMatcher to look for into the message
 * @namespace Utils
 * @api public
 */

function compatibleMessage(thrown, errMatcher) {
  var comparisonString = typeof thrown === 'string' ? thrown : thrown.message;
  if (errMatcher instanceof RegExp) {
    return errMatcher.test(comparisonString);
  } else if (typeof errMatcher === 'string') {
    return comparisonString.indexOf(errMatcher) !== -1; // eslint-disable-line no-magic-numbers
  }

  return false;
}

/**
 * ### .getFunctionName(constructorFn)
 *
 * Returns the name of a function.
 * This also includes a polyfill function if `constructorFn.name` is not defined.
 *
 * @name getFunctionName
 * @param {Function} constructorFn
 * @namespace Utils
 * @api private
 */

var functionNameMatch = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\(\/]+)/;
function getFunctionName(constructorFn) {
  var name = '';
  if (typeof constructorFn.name === 'undefined') {
    // Here we run a polyfill if constructorFn.name is not defined
    var match = String(constructorFn).match(functionNameMatch);
    if (match) {
      name = match[1];
    }
  } else {
    name = constructorFn.name;
  }

  return name;
}

/**
 * ### .getConstructorName(errorLike)
 *
 * Gets the constructor name for an Error instance or constructor itself.
 *
 * @name getConstructorName
 * @param {Error|ErrorConstructor} errorLike
 * @namespace Utils
 * @api public
 */

function getConstructorName(errorLike) {
  var constructorName = errorLike;
  if (errorLike instanceof Error) {
    constructorName = getFunctionName(errorLike.constructor);
  } else if (typeof errorLike === 'function') {
    // If `err` is not an instance of Error it is an error constructor itself or another function.
    // If we've got a common function we get its name, otherwise we may need to create a new instance
    // of the error just in case it's a poorly-constructed error. Please see chaijs/chai/issues/45 to know more.
    constructorName = getFunctionName(errorLike).trim() ||
        getFunctionName(new errorLike()); // eslint-disable-line new-cap
  }

  return constructorName;
}

/**
 * ### .getMessage(errorLike)
 *
 * Gets the error message from an error.
 * If `err` is a String itself, we return it.
 * If the error has no message, we return an empty string.
 *
 * @name getMessage
 * @param {Error|String} errorLike
 * @namespace Utils
 * @api public
 */

function getMessage(errorLike) {
  var msg = '';
  if (errorLike && errorLike.message) {
    msg = errorLike.message;
  } else if (typeof errorLike === 'string') {
    msg = errorLike;
  }

  return msg;
}

module.exports = {
  compatibleInstance: compatibleInstance,
  compatibleConstructor: compatibleConstructor,
  compatibleMessage: compatibleMessage,
  getMessage: getMessage,
  getConstructorName: getConstructorName,
};

},{}],"../node_modules/chai/lib/chai/utils/isNaN.js":[function(require,module,exports) {
/*!
 * Chai - isNaN utility
 * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
 * MIT Licensed
 */

/**
 * ### .isNaN(value)
 *
 * Checks if the given value is NaN or not.
 *
 *     utils.isNaN(NaN); // true
 *
 * @param {Value} The value which has to be checked if it is NaN
 * @name isNaN
 * @api private
 */
function isNaN(value) {
  // Refer http://www.ecma-international.org/ecma-262/6.0/#sec-isnan-number
  // section's NOTE.
  return value !== value;
} // If ECMAScript 6's Number.isNaN is present, prefer that.


module.exports = Number.isNaN || isNaN;
},{}],"../node_modules/chai/lib/chai/utils/index.js":[function(require,module,exports) {
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Dependencies that are used for multiple exports are required here only once
 */
var pathval = require('pathval');
/*!
 * test utility
 */


exports.test = require('./test');
/*!
 * type utility
 */

exports.type = require('type-detect');
/*!
 * expectTypes utility
 */

exports.expectTypes = require('./expectTypes');
/*!
 * message utility
 */

exports.getMessage = require('./getMessage');
/*!
 * actual utility
 */

exports.getActual = require('./getActual');
/*!
 * Inspect util
 */

exports.inspect = require('./inspect');
/*!
 * Object Display util
 */

exports.objDisplay = require('./objDisplay');
/*!
 * Flag utility
 */

exports.flag = require('./flag');
/*!
 * Flag transferring utility
 */

exports.transferFlags = require('./transferFlags');
/*!
 * Deep equal utility
 */

exports.eql = require('deep-eql');
/*!
 * Deep path info
 */

exports.getPathInfo = pathval.getPathInfo;
/*!
 * Check if a property exists
 */

exports.hasProperty = pathval.hasProperty;
/*!
 * Function name
 */

exports.getName = require('get-func-name');
/*!
 * add Property
 */

exports.addProperty = require('./addProperty');
/*!
 * add Method
 */

exports.addMethod = require('./addMethod');
/*!
 * overwrite Property
 */

exports.overwriteProperty = require('./overwriteProperty');
/*!
 * overwrite Method
 */

exports.overwriteMethod = require('./overwriteMethod');
/*!
 * Add a chainable method
 */

exports.addChainableMethod = require('./addChainableMethod');
/*!
 * Overwrite chainable method
 */

exports.overwriteChainableMethod = require('./overwriteChainableMethod');
/*!
 * Compare by inspect method
 */

exports.compareByInspect = require('./compareByInspect');
/*!
 * Get own enumerable property symbols method
 */

exports.getOwnEnumerablePropertySymbols = require('./getOwnEnumerablePropertySymbols');
/*!
 * Get own enumerable properties method
 */

exports.getOwnEnumerableProperties = require('./getOwnEnumerableProperties');
/*!
 * Checks error against a given set of criteria
 */

exports.checkError = require('check-error');
/*!
 * Proxify util
 */

exports.proxify = require('./proxify');
/*!
 * addLengthGuard util
 */

exports.addLengthGuard = require('./addLengthGuard');
/*!
 * isProxyEnabled helper
 */

exports.isProxyEnabled = require('./isProxyEnabled');
/*!
 * isNaN method
 */

exports.isNaN = require('./isNaN');
},{"pathval":"../node_modules/pathval/index.js","./test":"../node_modules/chai/lib/chai/utils/test.js","type-detect":"../node_modules/type-detect/type-detect.js","./expectTypes":"../node_modules/chai/lib/chai/utils/expectTypes.js","./getMessage":"../node_modules/chai/lib/chai/utils/getMessage.js","./getActual":"../node_modules/chai/lib/chai/utils/getActual.js","./inspect":"../node_modules/chai/lib/chai/utils/inspect.js","./objDisplay":"../node_modules/chai/lib/chai/utils/objDisplay.js","./flag":"../node_modules/chai/lib/chai/utils/flag.js","./transferFlags":"../node_modules/chai/lib/chai/utils/transferFlags.js","deep-eql":"../node_modules/deep-eql/index.js","get-func-name":"../node_modules/get-func-name/index.js","./addProperty":"../node_modules/chai/lib/chai/utils/addProperty.js","./addMethod":"../node_modules/chai/lib/chai/utils/addMethod.js","./overwriteProperty":"../node_modules/chai/lib/chai/utils/overwriteProperty.js","./overwriteMethod":"../node_modules/chai/lib/chai/utils/overwriteMethod.js","./addChainableMethod":"../node_modules/chai/lib/chai/utils/addChainableMethod.js","./overwriteChainableMethod":"../node_modules/chai/lib/chai/utils/overwriteChainableMethod.js","./compareByInspect":"../node_modules/chai/lib/chai/utils/compareByInspect.js","./getOwnEnumerablePropertySymbols":"../node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js","./getOwnEnumerableProperties":"../node_modules/chai/lib/chai/utils/getOwnEnumerableProperties.js","check-error":"../node_modules/check-error/index.js","./proxify":"../node_modules/chai/lib/chai/utils/proxify.js","./addLengthGuard":"../node_modules/chai/lib/chai/utils/addLengthGuard.js","./isProxyEnabled":"../node_modules/chai/lib/chai/utils/isProxyEnabled.js","./isNaN":"../node_modules/chai/lib/chai/utils/isNaN.js"}],"../node_modules/chai/lib/chai/assertion.js":[function(require,module,exports) {
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var config = require('./config');

module.exports = function (_chai, util) {
  /*!
   * Module dependencies.
   */
  var AssertionError = _chai.AssertionError,
      flag = util.flag;
  /*!
   * Module export.
   */

  _chai.Assertion = Assertion;
  /*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * `Assertion` objects contain metadata in the form of flags. Three flags can
   * be assigned during instantiation by passing arguments to this constructor:
   *
   * - `object`: This flag contains the target of the assertion. For example, in
   *   the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
   *   contain `numKittens` so that the `equal` assertion can reference it when
   *   needed.
   *
   * - `message`: This flag contains an optional custom error message to be
   *   prepended to the error message that's generated by the assertion when it
   *   fails.
   *
   * - `ssfi`: This flag stands for "start stack function indicator". It
   *   contains a function reference that serves as the starting point for
   *   removing frames from the stack trace of the error that's created by the
   *   assertion when it fails. The goal is to provide a cleaner stack trace to
   *   end users by removing Chai's internal functions. Note that it only works
   *   in environments that support `Error.captureStackTrace`, and only when
   *   `Chai.config.includeStack` hasn't been set to `false`.
   *
   * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
   *   should retain its current value, even as assertions are chained off of
   *   this object. This is usually set to `true` when creating a new assertion
   *   from within another assertion. It's also temporarily set to `true` before
   *   an overwritten assertion gets called by the overwriting assertion.
   *
   * @param {Mixed} obj target of the assertion
   * @param {String} msg (optional) custom error message
   * @param {Function} ssfi (optional) starting point for removing stack frames
   * @param {Boolean} lockSsfi (optional) whether or not the ssfi flag is locked
   * @api private
   */

  function Assertion(obj, msg, ssfi, lockSsfi) {
    flag(this, 'ssfi', ssfi || Assertion);
    flag(this, 'lockSsfi', lockSsfi);
    flag(this, 'object', obj);
    flag(this, 'message', msg);
    return util.proxify(this);
  }

  Object.defineProperty(Assertion, 'includeStack', {
    get: function () {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      return config.includeStack;
    },
    set: function (value) {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      config.includeStack = value;
    }
  });
  Object.defineProperty(Assertion, 'showDiff', {
    get: function () {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      return config.showDiff;
    },
    set: function (value) {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      config.showDiff = value;
    }
  });

  Assertion.addProperty = function (name, fn) {
    util.addProperty(this.prototype, name, fn);
  };

  Assertion.addMethod = function (name, fn) {
    util.addMethod(this.prototype, name, fn);
  };

  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  Assertion.overwriteProperty = function (name, fn) {
    util.overwriteProperty(this.prototype, name, fn);
  };

  Assertion.overwriteMethod = function (name, fn) {
    util.overwriteMethod(this.prototype, name, fn);
  };

  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
  };
  /**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String|Function} message or function that returns message to display if expression fails
   * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to `this.obj`
   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
   * @api private
   */


  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
    var ok = util.test(this, arguments);
    if (false !== showDiff) showDiff = true;
    if (undefined === expected && undefined === _actual) showDiff = false;
    if (true !== config.showDiff) showDiff = false;

    if (!ok) {
      msg = util.getMessage(this, arguments);
      var actual = util.getActual(this, arguments);
      throw new AssertionError(msg, {
        actual: actual,
        expected: expected,
        showDiff: showDiff
      }, config.includeStack ? this.assert : flag(this, 'ssfi'));
    }
  };
  /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */


  Object.defineProperty(Assertion.prototype, '_obj', {
    get: function () {
      return flag(this, 'object');
    },
    set: function (val) {
      flag(this, 'object', val);
    }
  });
};
},{"./config":"../node_modules/chai/lib/chai/config.js"}],"../node_modules/chai/lib/chai/core/assertions.js":[function(require,module,exports) {
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
module.exports = function (chai, _) {
  var Assertion = chai.Assertion,
      AssertionError = chai.AssertionError,
      flag = _.flag;
  /**
   * ### Language Chains
   *
   * The following are provided as chainable getters to improve the readability
   * of your assertions.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - which
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   * - but
   * - does
   * - still
   *
   * @name language chains
   * @namespace BDD
   * @api public
   */

  ['to', 'be', 'been', 'is', 'and', 'has', 'have', 'with', 'that', 'which', 'at', 'of', 'same', 'but', 'does', 'still'].forEach(function (chain) {
    Assertion.addProperty(chain);
  });
  /**
   * ### .not
   *
   * Negates all assertions that follow in the chain.
   *
   *     expect(function () {}).to.not.throw();
   *     expect({a: 1}).to.not.have.property('b');
   *     expect([1, 2]).to.be.an('array').that.does.not.include(3);
   *
   * Just because you can negate any assertion with `.not` doesn't mean you
   * should. With great power comes great responsibility. It's often best to
   * assert that the one expected output was produced, rather than asserting
   * that one of countless unexpected outputs wasn't produced. See individual
   * assertions for specific guidance.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.equal(1); // Not recommended
   *
   * @name not
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('not', function () {
    flag(this, 'negate', true);
  });
  /**
   * ### .deep
   *
   * Causes all `.equal`, `.include`, `.members`, `.keys`, and `.property`
   * assertions that follow in the chain to use deep equality instead of strict
   * (`===`) equality. See the `deep-eql` project page for info on the deep
   * equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) equals `{a: 1}`
   *     expect({a: 1}).to.deep.equal({a: 1});
   *     expect({a: 1}).to.not.equal({a: 1});
   *
   *     // Target array deeply (but not strictly) includes `{a: 1}`
   *     expect([{a: 1}]).to.deep.include({a: 1});
   *     expect([{a: 1}]).to.not.include({a: 1});
   *
   *     // Target object deeply (but not strictly) includes `x: {a: 1}`
   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});
   *
   *     // Target array deeply (but not strictly) has member `{a: 1}`
   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);
   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);
   *
   *     // Target set deeply (but not strictly) has key `{a: 1}`
   *     expect(new Set([{a: 1}])).to.have.deep.keys([{a: 1}]);
   *     expect(new Set([{a: 1}])).to.not.have.keys([{a: 1}]);
   *
   *     // Target object deeply (but not strictly) has property `x: {a: 1}`
   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
   *
   * @name deep
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('deep', function () {
    flag(this, 'deep', true);
  });
  /**
   * ### .nested
   *
   * Enables dot- and bracket-notation in all `.property` and `.include`
   * assertions that follow in the chain.
   *
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
   *
   * If `.` or `[]` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
   *     expect({'.a': {'[b]': 'x'}}).to.nested.include({'\\.a.\\[b\\]': 'x'});
   *
   * `.nested` cannot be combined with `.own`.
   *
   * @name nested
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('nested', function () {
    flag(this, 'nested', true);
  });
  /**
   * ### .own
   *
   * Causes all `.property` and `.include` assertions that follow in the chain
   * to ignore inherited properties.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.have.own.property('a');
   *     expect({a: 1}).to.have.property('b');
   *     expect({a: 1}).to.not.have.own.property('b');
   *
   *     expect({a: 1}).to.own.include({a: 1});
   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
   *
   * `.own` cannot be combined with `.nested`.
   *
   * @name own
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('own', function () {
    flag(this, 'own', true);
  });
  /**
   * ### .ordered
   *
   * Causes all `.members` assertions that follow in the chain to require that
   * members be in the same order.
   *
   *     expect([1, 2]).to.have.ordered.members([1, 2])
   *       .but.not.have.ordered.members([2, 1]);
   *
   * When `.include` and `.ordered` are combined, the ordering begins at the
   * start of both arrays.
   *
   *     expect([1, 2, 3]).to.include.ordered.members([1, 2])
   *       .but.not.include.ordered.members([2, 3]);
   *
   * @name ordered
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('ordered', function () {
    flag(this, 'ordered', true);
  });
  /**
   * ### .any
   *
   * Causes all `.keys` assertions that follow in the chain to only require that
   * the target have at least one of the given keys. This is the opposite of
   * `.all`, which requires that the target have all of the given keys.
   *
   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
   *
   * See the `.keys` doc for guidance on when to use `.any` or `.all`.
   *
   * @name any
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('any', function () {
    flag(this, 'any', true);
    flag(this, 'all', false);
  });
  /**
   * ### .all
   *
   * Causes all `.keys` assertions that follow in the chain to require that the
   * target have all of the given keys. This is the opposite of `.any`, which
   * only requires that the target have at least one of the given keys.
   *
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *
   * Note that `.all` is used by default when neither `.all` nor `.any` are
   * added earlier in the chain. However, it's often best to add `.all` anyway
   * because it improves readability.
   *
   * See the `.keys` doc for guidance on when to use `.any` or `.all`.
   *
   * @name all
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('all', function () {
    flag(this, 'all', true);
    flag(this, 'any', false);
  });
  /**
   * ### .a(type[, msg])
   *
   * Asserts that the target's type is equal to the given string `type`. Types
   * are case insensitive. See the `type-detect` project page for info on the
   * type detection algorithm: https://github.com/chaijs/type-detect.
   *
   *     expect('foo').to.be.a('string');
   *     expect({a: 1}).to.be.an('object');
   *     expect(null).to.be.a('null');
   *     expect(undefined).to.be.an('undefined');
   *     expect(new Error).to.be.an('error');
   *     expect(Promise.resolve()).to.be.a('promise');
   *     expect(new Float32Array).to.be.a('float32array');
   *     expect(Symbol()).to.be.a('symbol');
   *
   * `.a` supports objects that have a custom type set via `Symbol.toStringTag`.
   *
   *     var myObj = {
   *       [Symbol.toStringTag]: 'myCustomType'
   *     };
   *
   *     expect(myObj).to.be.a('myCustomType').but.not.an('object');
   *
   * It's often best to use `.a` to check a target's type before making more
   * assertions on the same target. That way, you avoid unexpected behavior from
   * any assertion that does different things based on the target's type.
   *
   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);
   *     expect([]).to.be.an('array').that.is.empty;
   *
   * Add `.not` earlier in the chain to negate `.a`. However, it's often best to
   * assert that the target is the expected type, rather than asserting that it
   * isn't one of many unexpected types.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.an('array'); // Not recommended
   *
   * `.a` accepts an optional `msg` argument which is a custom error message to
   * show when the assertion fails. The message can also be given as the second
   * argument to `expect`.
   *
   *     expect(1).to.be.a('string', 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.a('string');
   *
   * `.a` can also be used as a language chain to improve the readability of
   * your assertions.
   *
   *     expect({b: 2}).to.have.a.property('b');
   *
   * The alias `.an` can be used interchangeably with `.a`.
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function an(type, msg) {
    if (msg) flag(this, 'message', msg);
    type = type.toLowerCase();
    var obj = flag(this, 'object'),
        article = ~['a', 'e', 'i', 'o', 'u'].indexOf(type.charAt(0)) ? 'an ' : 'a ';
    this.assert(type === _.type(obj).toLowerCase(), 'expected #{this} to be ' + article + type, 'expected #{this} not to be ' + article + type);
  }

  Assertion.addChainableMethod('an', an);
  Assertion.addChainableMethod('a', an);
  /**
   * ### .include(val[, msg])
   *
   * When the target is a string, `.include` asserts that the given string `val`
   * is a substring of the target.
   *
   *     expect('foobar').to.include('foo');
   *
   * When the target is an array, `.include` asserts that the given `val` is a
   * member of the target.
   *
   *     expect([1, 2, 3]).to.include(2);
   *
   * When the target is an object, `.include` asserts that the given object
   * `val`'s properties are a subset of the target's properties.
   *
   *     expect({a: 1, b: 2, c: 3}).to.include({a: 1, b: 2});
   *
   * When the target is a Set or WeakSet, `.include` asserts that the given `val` is a
   * member of the target. SameValueZero equality algorithm is used.
   *
   *     expect(new Set([1, 2])).to.include(2);
   *
   * When the target is a Map, `.include` asserts that the given `val` is one of
   * the values of the target. SameValueZero equality algorithm is used.
   *
   *     expect(new Map([['a', 1], ['b', 2]])).to.include(2);
   *
   * Because `.include` does different things based on the target's type, it's
   * important to check the target's type before using `.include`. See the `.a`
   * doc for info on testing a target's type.
   *
   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);
   *
   * By default, strict (`===`) equality is used to compare array members and
   * object properties. Add `.deep` earlier in the chain to use deep equality
   * instead (WeakSet targets are not supported). See the `deep-eql` project
   * page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target array deeply (but not strictly) includes `{a: 1}`
   *     expect([{a: 1}]).to.deep.include({a: 1});
   *     expect([{a: 1}]).to.not.include({a: 1});
   *
   *     // Target object deeply (but not strictly) includes `x: {a: 1}`
   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});
   *
   * By default, all of the target's properties are searched when working with
   * objects. This includes properties that are inherited and/or non-enumerable.
   * Add `.own` earlier in the chain to exclude the target's inherited
   * properties from the search.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.own.include({a: 1});
   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
   *
   * Note that a target object is always only searched for `val`'s own
   * enumerable properties.
   *
   * `.deep` and `.own` can be combined.
   *
   *     expect({a: {b: 2}}).to.deep.own.include({a: {b: 2}});
   *
   * Add `.nested` earlier in the chain to enable dot- and bracket-notation when
   * referencing nested properties.
   *
   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
   *
   * If `.` or `[]` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 2}}).to.nested.include({'\\.a.\\[b\\]': 2});
   *
   * `.deep` and `.nested` can be combined.
   *
   *     expect({a: {b: [{c: 3}]}}).to.deep.nested.include({'a.b[0]': {c: 3}});
   *
   * `.own` and `.nested` cannot be combined.
   *
   * Add `.not` earlier in the chain to negate `.include`.
   *
   *     expect('foobar').to.not.include('taco');
   *     expect([1, 2, 3]).to.not.include(4);
   *
   * However, it's dangerous to negate `.include` when the target is an object.
   * The problem is that it creates uncertain expectations by asserting that the
   * target object doesn't have all of `val`'s key/value pairs but may or may
   * not have some of them. It's often best to identify the exact output that's
   * expected, and then write an assertion that only accepts that exact output.
   *
   * When the target object isn't even expected to have `val`'s keys, it's
   * often best to assert exactly that.
   *
   *     expect({c: 3}).to.not.have.any.keys('a', 'b'); // Recommended
   *     expect({c: 3}).to.not.include({a: 1, b: 2}); // Not recommended
   *
   * When the target object is expected to have `val`'s keys, it's often best to
   * assert that each of the properties has its expected value, rather than
   * asserting that each property doesn't have one of many unexpected values.
   *
   *     expect({a: 3, b: 4}).to.include({a: 3, b: 4}); // Recommended
   *     expect({a: 3, b: 4}).to.not.include({a: 1, b: 2}); // Not recommended
   *
   * `.include` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect([1, 2, 3]).to.include(4, 'nooo why fail??');
   *     expect([1, 2, 3], 'nooo why fail??').to.include(4);
   *
   * `.include` can also be used as a language chain, causing all `.members` and
   * `.keys` assertions that follow in the chain to require the target to be a
   * superset of the expected set, rather than an identical set. Note that
   * `.members` ignores duplicates in the subset when `.include` is added.
   *
   *     // Target object's keys are a superset of ['a', 'b'] but not identical
   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
   *
   *     // Target array is a superset of [1, 2] but not identical
   *     expect([1, 2, 3]).to.include.members([1, 2]);
   *     expect([1, 2, 3]).to.not.have.members([1, 2]);
   *
   *     // Duplicates in the subset are ignored
   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
   *
   * Note that adding `.any` earlier in the chain causes the `.keys` assertion
   * to ignore `.include`.
   *
   *     // Both assertions are identical
   *     expect({a: 1}).to.include.any.keys('a', 'b');
   *     expect({a: 1}).to.have.any.keys('a', 'b');
   *
   * The aliases `.includes`, `.contain`, and `.contains` can be used
   * interchangeably with `.include`.
   *
   * @name include
   * @alias contain
   * @alias includes
   * @alias contains
   * @param {Mixed} val
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function SameValueZero(a, b) {
    return _.isNaN(a) && _.isNaN(b) || a === b;
  }

  function includeChainingBehavior() {
    flag(this, 'contains', true);
  }

  function include(val, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        objType = _.type(obj).toLowerCase(),
        flagMsg = flag(this, 'message'),
        negate = flag(this, 'negate'),
        ssfi = flag(this, 'ssfi'),
        isDeep = flag(this, 'deep'),
        descriptor = isDeep ? 'deep ' : '';

    flagMsg = flagMsg ? flagMsg + ': ' : '';
    var included = false;

    switch (objType) {
      case 'string':
        included = obj.indexOf(val) !== -1;
        break;

      case 'weakset':
        if (isDeep) {
          throw new AssertionError(flagMsg + 'unable to use .deep.include with WeakSet', undefined, ssfi);
        }

        included = obj.has(val);
        break;

      case 'map':
        var isEql = isDeep ? _.eql : SameValueZero;
        obj.forEach(function (item) {
          included = included || isEql(item, val);
        });
        break;

      case 'set':
        if (isDeep) {
          obj.forEach(function (item) {
            included = included || _.eql(item, val);
          });
        } else {
          included = obj.has(val);
        }

        break;

      case 'array':
        if (isDeep) {
          included = obj.some(function (item) {
            return _.eql(item, val);
          });
        } else {
          included = obj.indexOf(val) !== -1;
        }

        break;

      default:
        // This block is for asserting a subset of properties in an object.
        // `_.expectTypes` isn't used here because `.include` should work with
        // objects with a custom `@@toStringTag`.
        if (val !== Object(val)) {
          throw new AssertionError(flagMsg + 'object tested must be an array, a map, an object,' + ' a set, a string, or a weakset, but ' + objType + ' given', undefined, ssfi);
        }

        var props = Object.keys(val),
            firstErr = null,
            numErrs = 0;
        props.forEach(function (prop) {
          var propAssertion = new Assertion(obj);

          _.transferFlags(this, propAssertion, true);

          flag(propAssertion, 'lockSsfi', true);

          if (!negate || props.length === 1) {
            propAssertion.property(prop, val[prop]);
            return;
          }

          try {
            propAssertion.property(prop, val[prop]);
          } catch (err) {
            if (!_.checkError.compatibleConstructor(err, AssertionError)) {
              throw err;
            }

            if (firstErr === null) firstErr = err;
            numErrs++;
          }
        }, this); // When validating .not.include with multiple properties, we only want
        // to throw an assertion error if all of the properties are included,
        // in which case we throw the first property assertion error that we
        // encountered.

        if (negate && props.length > 1 && numErrs === props.length) {
          throw firstErr;
        }

        return;
    } // Assert inclusion in collection or substring in a string.


    this.assert(included, 'expected #{this} to ' + descriptor + 'include ' + _.inspect(val), 'expected #{this} to not ' + descriptor + 'include ' + _.inspect(val));
  }

  Assertion.addChainableMethod('include', include, includeChainingBehavior);
  Assertion.addChainableMethod('contain', include, includeChainingBehavior);
  Assertion.addChainableMethod('contains', include, includeChainingBehavior);
  Assertion.addChainableMethod('includes', include, includeChainingBehavior);
  /**
   * ### .ok
   *
   * Asserts that the target is a truthy value (considered `true` in boolean context).
   * However, it's often best to assert that the target is strictly (`===`) or
   * deeply equal to its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.ok; // Not recommended
   *
   *     expect(true).to.be.true; // Recommended
   *     expect(true).to.be.ok; // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.ok`.
   *
   *     expect(0).to.equal(0); // Recommended
   *     expect(0).to.not.be.ok; // Not recommended
   *
   *     expect(false).to.be.false; // Recommended
   *     expect(false).to.not.be.ok; // Not recommended
   *
   *     expect(null).to.be.null; // Recommended
   *     expect(null).to.not.be.ok; // Not recommended
   *
   *     expect(undefined).to.be.undefined; // Recommended
   *     expect(undefined).to.not.be.ok; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(false, 'nooo why fail??').to.be.ok;
   *
   * @name ok
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('ok', function () {
    this.assert(flag(this, 'object'), 'expected #{this} to be truthy', 'expected #{this} to be falsy');
  });
  /**
   * ### .true
   *
   * Asserts that the target is strictly (`===`) equal to `true`.
   *
   *     expect(true).to.be.true;
   *
   * Add `.not` earlier in the chain to negate `.true`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to `true`.
   *
   *     expect(false).to.be.false; // Recommended
   *     expect(false).to.not.be.true; // Not recommended
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.true; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(false, 'nooo why fail??').to.be.true;
   *
   * @name true
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('true', function () {
    this.assert(true === flag(this, 'object'), 'expected #{this} to be true', 'expected #{this} to be false', flag(this, 'negate') ? false : true);
  });
  /**
   * ### .false
   *
   * Asserts that the target is strictly (`===`) equal to `false`.
   *
   *     expect(false).to.be.false;
   *
   * Add `.not` earlier in the chain to negate `.false`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to `false`.
   *
   *     expect(true).to.be.true; // Recommended
   *     expect(true).to.not.be.false; // Not recommended
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.false; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(true, 'nooo why fail??').to.be.false;
   *
   * @name false
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('false', function () {
    this.assert(false === flag(this, 'object'), 'expected #{this} to be false', 'expected #{this} to be true', flag(this, 'negate') ? true : false);
  });
  /**
   * ### .null
   *
   * Asserts that the target is strictly (`===`) equal to `null`.
   *
   *     expect(null).to.be.null;
   *
   * Add `.not` earlier in the chain to negate `.null`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to `null`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.null; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(42, 'nooo why fail??').to.be.null;
   *
   * @name null
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('null', function () {
    this.assert(null === flag(this, 'object'), 'expected #{this} to be null', 'expected #{this} not to be null');
  });
  /**
   * ### .undefined
   *
   * Asserts that the target is strictly (`===`) equal to `undefined`.
   *
   *     expect(undefined).to.be.undefined;
   *
   * Add `.not` earlier in the chain to negate `.undefined`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to `undefined`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.undefined; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(42, 'nooo why fail??').to.be.undefined;
   *
   * @name undefined
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('undefined', function () {
    this.assert(undefined === flag(this, 'object'), 'expected #{this} to be undefined', 'expected #{this} not to be undefined');
  });
  /**
   * ### .NaN
   *
   * Asserts that the target is exactly `NaN`.
   *
   *     expect(NaN).to.be.NaN;
   *
   * Add `.not` earlier in the chain to negate `.NaN`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to `NaN`.
   *
   *     expect('foo').to.equal('foo'); // Recommended
   *     expect('foo').to.not.be.NaN; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(42, 'nooo why fail??').to.be.NaN;
   *
   * @name NaN
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('NaN', function () {
    this.assert(_.isNaN(flag(this, 'object')), 'expected #{this} to be NaN', 'expected #{this} not to be NaN');
  });
  /**
   * ### .exist
   *
   * Asserts that the target is not strictly (`===`) equal to either `null` or
   * `undefined`. However, it's often best to assert that the target is equal to
   * its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.exist; // Not recommended
   *
   *     expect(0).to.equal(0); // Recommended
   *     expect(0).to.exist; // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.exist`.
   *
   *     expect(null).to.be.null; // Recommended
   *     expect(null).to.not.exist; // Not recommended
   *
   *     expect(undefined).to.be.undefined; // Recommended
   *     expect(undefined).to.not.exist; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(null, 'nooo why fail??').to.exist;
   *
   * @name exist
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('exist', function () {
    var val = flag(this, 'object');
    this.assert(val !== null && val !== undefined, 'expected #{this} to exist', 'expected #{this} to not exist');
  });
  /**
   * ### .empty
   *
   * When the target is a string or array, `.empty` asserts that the target's
   * `length` property is strictly (`===`) equal to `0`.
   *
   *     expect([]).to.be.empty;
   *     expect('').to.be.empty;
   *
   * When the target is a map or set, `.empty` asserts that the target's `size`
   * property is strictly equal to `0`.
   *
   *     expect(new Set()).to.be.empty;
   *     expect(new Map()).to.be.empty;
   *
   * When the target is a non-function object, `.empty` asserts that the target
   * doesn't have any own enumerable properties. Properties with Symbol-based
   * keys are excluded from the count.
   *
   *     expect({}).to.be.empty;
   *
   * Because `.empty` does different things based on the target's type, it's
   * important to check the target's type before using `.empty`. See the `.a`
   * doc for info on testing a target's type.
   *
   *     expect([]).to.be.an('array').that.is.empty;
   *
   * Add `.not` earlier in the chain to negate `.empty`. However, it's often
   * best to assert that the target contains its expected number of values,
   * rather than asserting that it's not empty.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.not.be.empty; // Not recommended
   *
   *     expect(new Set([1, 2, 3])).to.have.property('size', 3); // Recommended
   *     expect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended
   *
   *     expect(Object.keys({a: 1})).to.have.lengthOf(1); // Recommended
   *     expect({a: 1}).to.not.be.empty; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect([1, 2, 3], 'nooo why fail??').to.be.empty;
   *
   * @name empty
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('empty', function () {
    var val = flag(this, 'object'),
        ssfi = flag(this, 'ssfi'),
        flagMsg = flag(this, 'message'),
        itemsCount;
    flagMsg = flagMsg ? flagMsg + ': ' : '';

    switch (_.type(val).toLowerCase()) {
      case 'array':
      case 'string':
        itemsCount = val.length;
        break;

      case 'map':
      case 'set':
        itemsCount = val.size;
        break;

      case 'weakmap':
      case 'weakset':
        throw new AssertionError(flagMsg + '.empty was passed a weak collection', undefined, ssfi);

      case 'function':
        var msg = flagMsg + '.empty was passed a function ' + _.getName(val);

        throw new AssertionError(msg.trim(), undefined, ssfi);

      default:
        if (val !== Object(val)) {
          throw new AssertionError(flagMsg + '.empty was passed non-string primitive ' + _.inspect(val), undefined, ssfi);
        }

        itemsCount = Object.keys(val).length;
    }

    this.assert(0 === itemsCount, 'expected #{this} to be empty', 'expected #{this} not to be empty');
  });
  /**
   * ### .arguments
   *
   * Asserts that the target is an `arguments` object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   *     test();
   *
   * Add `.not` earlier in the chain to negate `.arguments`. However, it's often
   * best to assert which type the target is expected to be, rather than
   * asserting that its not an `arguments` object.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.arguments; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({}, 'nooo why fail??').to.be.arguments;
   *
   * The alias `.Arguments` can be used interchangeably with `.arguments`.
   *
   * @name arguments
   * @alias Arguments
   * @namespace BDD
   * @api public
   */

  function checkArguments() {
    var obj = flag(this, 'object'),
        type = _.type(obj);

    this.assert('Arguments' === type, 'expected #{this} to be arguments but got ' + type, 'expected #{this} to not be arguments');
  }

  Assertion.addProperty('arguments', checkArguments);
  Assertion.addProperty('Arguments', checkArguments);
  /**
   * ### .equal(val[, msg])
   *
   * Asserts that the target is strictly (`===`) equal to the given `val`.
   *
   *     expect(1).to.equal(1);
   *     expect('foo').to.equal('foo');
   *
   * Add `.deep` earlier in the chain to use deep equality instead. See the
   * `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) equals `{a: 1}`
   *     expect({a: 1}).to.deep.equal({a: 1});
   *     expect({a: 1}).to.not.equal({a: 1});
   *
   *     // Target array deeply (but not strictly) equals `[1, 2]`
   *     expect([1, 2]).to.deep.equal([1, 2]);
   *     expect([1, 2]).to.not.equal([1, 2]);
   *
   * Add `.not` earlier in the chain to negate `.equal`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to one of countless unexpected values.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.equal(2); // Not recommended
   *
   * `.equal` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.equal(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.equal(2);
   *
   * The aliases `.equals` and `eq` can be used interchangeably with `.equal`.
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @param {Mixed} val
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertEqual(val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    if (flag(this, 'deep')) {
      var prevLockSsfi = flag(this, 'lockSsfi');
      flag(this, 'lockSsfi', true);
      this.eql(val);
      flag(this, 'lockSsfi', prevLockSsfi);
    } else {
      this.assert(val === obj, 'expected #{this} to equal #{exp}', 'expected #{this} to not equal #{exp}', val, this._obj, true);
    }
  }

  Assertion.addMethod('equal', assertEqual);
  Assertion.addMethod('equals', assertEqual);
  Assertion.addMethod('eq', assertEqual);
  /**
   * ### .eql(obj[, msg])
   *
   * Asserts that the target is deeply equal to the given `obj`. See the
   * `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target object is deeply (but not strictly) equal to {a: 1}
   *     expect({a: 1}).to.eql({a: 1}).but.not.equal({a: 1});
   *
   *     // Target array is deeply (but not strictly) equal to [1, 2]
   *     expect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);
   *
   * Add `.not` earlier in the chain to negate `.eql`. However, it's often best
   * to assert that the target is deeply equal to its expected value, rather
   * than not deeply equal to one of countless unexpected values.
   *
   *     expect({a: 1}).to.eql({a: 1}); // Recommended
   *     expect({a: 1}).to.not.eql({b: 2}); // Not recommended
   *
   * `.eql` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect({a: 1}).to.eql({b: 2}, 'nooo why fail??');
   *     expect({a: 1}, 'nooo why fail??').to.eql({b: 2});
   *
   * The alias `.eqls` can be used interchangeably with `.eql`.
   *
   * The `.deep.equal` assertion is almost identical to `.eql` but with one
   * difference: `.deep.equal` causes deep equality comparisons to also be used
   * for any other assertions that follow in the chain.
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} obj
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertEql(obj, msg) {
    if (msg) flag(this, 'message', msg);
    this.assert(_.eql(obj, flag(this, 'object')), 'expected #{this} to deeply equal #{exp}', 'expected #{this} to not deeply equal #{exp}', obj, this._obj, true);
  }

  Assertion.addMethod('eql', assertEql);
  Assertion.addMethod('eqls', assertEql);
  /**
   * ### .above(n[, msg])
   *
   * Asserts that the target is a number or a date greater than the given number or date `n` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.above(1); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is greater than the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.above(2); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.above`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(1).to.not.be.above(2); // Not recommended
   *
   * `.above` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.be.above(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.above(2);
   *
   * The aliases `.gt` and `.greaterThan` can be used interchangeably with
   * `.above`.
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertAbove(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        nType = _.type(n).toLowerCase(),
        errorMessage,
        shouldThrow = true;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && nType !== 'date') {
      errorMessage = msgPrefix + 'the argument to above must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to above must be a number';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length',
          itemsCount;

      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }

      this.assert(itemsCount > n, 'expected #{this} to have a ' + descriptor + ' above #{exp} but got #{act}', 'expected #{this} to not have a ' + descriptor + ' above #{exp}', n, itemsCount);
    } else {
      this.assert(obj > n, 'expected #{this} to be above #{exp}', 'expected #{this} to be at most #{exp}', n);
    }
  }

  Assertion.addMethod('above', assertAbove);
  Assertion.addMethod('gt', assertAbove);
  Assertion.addMethod('greaterThan', assertAbove);
  /**
   * ### .least(n[, msg])
   *
   * Asserts that the target is a number or a date greater than or equal to the given
   * number or date `n` respectively. However, it's often best to assert that the target is equal to
   * its expected value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.at.least(1); // Not recommended
   *     expect(2).to.be.at.least(2); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is greater than or equal to the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.at.least(2); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.least`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.at.least(2); // Not recommended
   *
   * `.least` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.be.at.least(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.at.least(2);
   *
   * The alias `.gte` can be used interchangeably with `.least`.
   *
   * @name least
   * @alias gte
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertLeast(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        nType = _.type(n).toLowerCase(),
        errorMessage,
        shouldThrow = true;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && nType !== 'date') {
      errorMessage = msgPrefix + 'the argument to least must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to least must be a number';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length',
          itemsCount;

      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }

      this.assert(itemsCount >= n, 'expected #{this} to have a ' + descriptor + ' at least #{exp} but got #{act}', 'expected #{this} to have a ' + descriptor + ' below #{exp}', n, itemsCount);
    } else {
      this.assert(obj >= n, 'expected #{this} to be at least #{exp}', 'expected #{this} to be below #{exp}', n);
    }
  }

  Assertion.addMethod('least', assertLeast);
  Assertion.addMethod('gte', assertLeast);
  /**
   * ### .below(n[, msg])
   *
   * Asserts that the target is a number or a date less than the given number or date `n` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.below(2); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is less than the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.below(4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.length(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.below`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.be.below(1); // Not recommended
   *
   * `.below` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(2).to.be.below(1, 'nooo why fail??');
   *     expect(2, 'nooo why fail??').to.be.below(1);
   *
   * The aliases `.lt` and `.lessThan` can be used interchangeably with
   * `.below`.
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertBelow(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        nType = _.type(n).toLowerCase(),
        errorMessage,
        shouldThrow = true;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && nType !== 'date') {
      errorMessage = msgPrefix + 'the argument to below must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to below must be a number';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length',
          itemsCount;

      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }

      this.assert(itemsCount < n, 'expected #{this} to have a ' + descriptor + ' below #{exp} but got #{act}', 'expected #{this} to not have a ' + descriptor + ' below #{exp}', n, itemsCount);
    } else {
      this.assert(obj < n, 'expected #{this} to be below #{exp}', 'expected #{this} to be at least #{exp}', n);
    }
  }

  Assertion.addMethod('below', assertBelow);
  Assertion.addMethod('lt', assertBelow);
  Assertion.addMethod('lessThan', assertBelow);
  /**
   * ### .most(n[, msg])
   *
   * Asserts that the target is a number or a date less than or equal to the given number
   * or date `n` respectively. However, it's often best to assert that the target is equal to its
   * expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.at.most(2); // Not recommended
   *     expect(1).to.be.at.most(1); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is less than or equal to the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.at.most(4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.most`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.be.at.most(1); // Not recommended
   *
   * `.most` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(2).to.be.at.most(1, 'nooo why fail??');
   *     expect(2, 'nooo why fail??').to.be.at.most(1);
   *
   * The alias `.lte` can be used interchangeably with `.most`.
   *
   * @name most
   * @alias lte
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertMost(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        nType = _.type(n).toLowerCase(),
        errorMessage,
        shouldThrow = true;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && nType !== 'date') {
      errorMessage = msgPrefix + 'the argument to most must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to most must be a number';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length',
          itemsCount;

      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }

      this.assert(itemsCount <= n, 'expected #{this} to have a ' + descriptor + ' at most #{exp} but got #{act}', 'expected #{this} to have a ' + descriptor + ' above #{exp}', n, itemsCount);
    } else {
      this.assert(obj <= n, 'expected #{this} to be at most #{exp}', 'expected #{this} to be above #{exp}', n);
    }
  }

  Assertion.addMethod('most', assertMost);
  Assertion.addMethod('lte', assertMost);
  /**
   * ### .within(start, finish[, msg])
   *
   * Asserts that the target is a number or a date greater than or equal to the given
   * number or date `start`, and less than or equal to the given number or date `finish` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.within(1, 3); // Not recommended
   *     expect(2).to.be.within(2, 3); // Not recommended
   *     expect(2).to.be.within(1, 2); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is greater than or equal to the given number `start`, and less
   * than or equal to the given number `finish`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.within(2, 4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.within`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.within(2, 4); // Not recommended
   *
   * `.within` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(4).to.be.within(1, 3, 'nooo why fail??');
   *     expect(4, 'nooo why fail??').to.be.within(1, 3);
   *
   * @name within
   * @param {Number} start lower bound inclusive
   * @param {Number} finish upper bound inclusive
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('within', function (start, finish, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        startType = _.type(start).toLowerCase(),
        finishType = _.type(finish).toLowerCase(),
        errorMessage,
        shouldThrow = true,
        range = startType === 'date' && finishType === 'date' ? start.toUTCString() + '..' + finish.toUTCString() : start + '..' + finish;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && (startType !== 'date' || finishType !== 'date')) {
      errorMessage = msgPrefix + 'the arguments to within must be dates';
    } else if ((startType !== 'number' || finishType !== 'number') && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the arguments to within must be numbers';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length',
          itemsCount;

      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }

      this.assert(itemsCount >= start && itemsCount <= finish, 'expected #{this} to have a ' + descriptor + ' within ' + range, 'expected #{this} to not have a ' + descriptor + ' within ' + range);
    } else {
      this.assert(obj >= start && obj <= finish, 'expected #{this} to be within ' + range, 'expected #{this} to not be within ' + range);
    }
  });
  /**
   * ### .instanceof(constructor[, msg])
   *
   * Asserts that the target is an instance of the given `constructor`.
   *
   *     function Cat () { }
   *
   *     expect(new Cat()).to.be.an.instanceof(Cat);
   *     expect([1, 2]).to.be.an.instanceof(Array);
   *
   * Add `.not` earlier in the chain to negate `.instanceof`.
   *
   *     expect({a: 1}).to.not.be.an.instanceof(Array);
   *
   * `.instanceof` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(1).to.be.an.instanceof(Array, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.an.instanceof(Array);
   *
   * Due to limitations in ES5, `.instanceof` may not always work as expected
   * when using a transpiler such as Babel or TypeScript. In particular, it may
   * produce unexpected results when subclassing built-in object such as
   * `Array`, `Error`, and `Map`. See your transpiler's docs for details:
   *
   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))
   *
   * The alias `.instanceOf` can be used interchangeably with `.instanceof`.
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} msg _optional_
   * @alias instanceOf
   * @namespace BDD
   * @api public
   */

  function assertInstanceOf(constructor, msg) {
    if (msg) flag(this, 'message', msg);
    var target = flag(this, 'object');
    var ssfi = flag(this, 'ssfi');
    var flagMsg = flag(this, 'message');

    try {
      var isInstanceOf = target instanceof constructor;
    } catch (err) {
      if (err instanceof TypeError) {
        flagMsg = flagMsg ? flagMsg + ': ' : '';
        throw new AssertionError(flagMsg + 'The instanceof assertion needs a constructor but ' + _.type(constructor) + ' was given.', undefined, ssfi);
      }

      throw err;
    }

    var name = _.getName(constructor);

    if (name === null) {
      name = 'an unnamed constructor';
    }

    this.assert(isInstanceOf, 'expected #{this} to be an instance of ' + name, 'expected #{this} to not be an instance of ' + name);
  }

  ;
  Assertion.addMethod('instanceof', assertInstanceOf);
  Assertion.addMethod('instanceOf', assertInstanceOf);
  /**
   * ### .property(name[, val[, msg]])
   *
   * Asserts that the target has a property with the given key `name`.
   *
   *     expect({a: 1}).to.have.property('a');
   *
   * When `val` is provided, `.property` also asserts that the property's value
   * is equal to the given `val`.
   *
   *     expect({a: 1}).to.have.property('a', 1);
   *
   * By default, strict (`===`) equality is used. Add `.deep` earlier in the
   * chain to use deep equality instead. See the `deep-eql` project page for
   * info on the deep equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) has property `x: {a: 1}`
   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
   *
   * The target's enumerable and non-enumerable properties are always included
   * in the search. By default, both own and inherited properties are included.
   * Add `.own` earlier in the chain to exclude inherited properties from the
   * search.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.have.own.property('a');
   *     expect({a: 1}).to.have.own.property('a', 1);
   *     expect({a: 1}).to.have.property('b');
   *     expect({a: 1}).to.not.have.own.property('b');
   *
   * `.deep` and `.own` can be combined.
   *
   *     expect({x: {a: 1}}).to.have.deep.own.property('x', {a: 1});
   *
   * Add `.nested` earlier in the chain to enable dot- and bracket-notation when
   * referencing nested properties.
   *
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]', 'y');
   *
   * If `.` or `[]` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
   *
   * `.deep` and `.nested` can be combined.
   *
   *     expect({a: {b: [{c: 3}]}})
   *       .to.have.deep.nested.property('a.b[0]', {c: 3});
   *
   * `.own` and `.nested` cannot be combined.
   *
   * Add `.not` earlier in the chain to negate `.property`.
   *
   *     expect({a: 1}).to.not.have.property('b');
   *
   * However, it's dangerous to negate `.property` when providing `val`. The
   * problem is that it creates uncertain expectations by asserting that the
   * target either doesn't have a property with the given key `name`, or that it
   * does have a property with the given key `name` but its value isn't equal to
   * the given `val`. It's often best to identify the exact output that's
   * expected, and then write an assertion that only accepts that exact output.
   *
   * When the target isn't expected to have a property with the given key
   * `name`, it's often best to assert exactly that.
   *
   *     expect({b: 2}).to.not.have.property('a'); // Recommended
   *     expect({b: 2}).to.not.have.property('a', 1); // Not recommended
   *
   * When the target is expected to have a property with the given key `name`,
   * it's often best to assert that the property has its expected value, rather
   * than asserting that it doesn't have one of many unexpected values.
   *
   *     expect({a: 3}).to.have.property('a', 3); // Recommended
   *     expect({a: 3}).to.not.have.property('a', 1); // Not recommended
   *
   * `.property` changes the target of any assertions that follow in the chain
   * to be the value of the property from the original target object.
   *
   *     expect({a: 1}).to.have.property('a').that.is.a('number');
   *
   * `.property` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing `val`, only use the
   * second form.
   *
   *     // Recommended
   *     expect({a: 1}).to.have.property('a', 2, 'nooo why fail??');
   *     expect({a: 1}, 'nooo why fail??').to.have.property('a', 2);
   *     expect({a: 1}, 'nooo why fail??').to.have.property('b');
   *
   *     // Not recommended
   *     expect({a: 1}).to.have.property('b', undefined, 'nooo why fail??');
   *
   * The above assertion isn't the same thing as not providing `val`. Instead,
   * it's asserting that the target object has a `b` property that's equal to
   * `undefined`.
   *
   * The assertions `.ownProperty` and `.haveOwnProperty` can be used
   * interchangeably with `.own.property`.
   *
   * @name property
   * @param {String} name
   * @param {Mixed} val (optional)
   * @param {String} msg _optional_
   * @returns value of property for chaining
   * @namespace BDD
   * @api public
   */

  function assertProperty(name, val, msg) {
    if (msg) flag(this, 'message', msg);

    var isNested = flag(this, 'nested'),
        isOwn = flag(this, 'own'),
        flagMsg = flag(this, 'message'),
        obj = flag(this, 'object'),
        ssfi = flag(this, 'ssfi'),
        nameType = _typeof(name);

    flagMsg = flagMsg ? flagMsg + ': ' : '';

    if (isNested) {
      if (nameType !== 'string') {
        throw new AssertionError(flagMsg + 'the argument to property must be a string when using nested syntax', undefined, ssfi);
      }
    } else {
      if (nameType !== 'string' && nameType !== 'number' && nameType !== 'symbol') {
        throw new AssertionError(flagMsg + 'the argument to property must be a string, number, or symbol', undefined, ssfi);
      }
    }

    if (isNested && isOwn) {
      throw new AssertionError(flagMsg + 'The "nested" and "own" flags cannot be combined.', undefined, ssfi);
    }

    if (obj === null || obj === undefined) {
      throw new AssertionError(flagMsg + 'Target cannot be null or undefined.', undefined, ssfi);
    }

    var isDeep = flag(this, 'deep'),
        negate = flag(this, 'negate'),
        pathInfo = isNested ? _.getPathInfo(obj, name) : null,
        value = isNested ? pathInfo.value : obj[name];
    var descriptor = '';
    if (isDeep) descriptor += 'deep ';
    if (isOwn) descriptor += 'own ';
    if (isNested) descriptor += 'nested ';
    descriptor += 'property ';
    var hasProperty;
    if (isOwn) hasProperty = Object.prototype.hasOwnProperty.call(obj, name);else if (isNested) hasProperty = pathInfo.exists;else hasProperty = _.hasProperty(obj, name); // When performing a negated assertion for both name and val, merely having
    // a property with the given name isn't enough to cause the assertion to
    // fail. It must both have a property with the given name, and the value of
    // that property must equal the given val. Therefore, skip this assertion in
    // favor of the next.

    if (!negate || arguments.length === 1) {
      this.assert(hasProperty, 'expected #{this} to have ' + descriptor + _.inspect(name), 'expected #{this} to not have ' + descriptor + _.inspect(name));
    }

    if (arguments.length > 1) {
      this.assert(hasProperty && (isDeep ? _.eql(val, value) : val === value), 'expected #{this} to have ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}', 'expected #{this} to not have ' + descriptor + _.inspect(name) + ' of #{act}', val, value);
    }

    flag(this, 'object', value);
  }

  Assertion.addMethod('property', assertProperty);

  function assertOwnProperty(name, value, msg) {
    flag(this, 'own', true);
    assertProperty.apply(this, arguments);
  }

  Assertion.addMethod('ownProperty', assertOwnProperty);
  Assertion.addMethod('haveOwnProperty', assertOwnProperty);
  /**
   * ### .ownPropertyDescriptor(name[, descriptor[, msg]])
   *
   * Asserts that the target has its own property descriptor with the given key
   * `name`. Enumerable and non-enumerable properties are included in the
   * search.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a');
   *
   * When `descriptor` is provided, `.ownPropertyDescriptor` also asserts that
   * the property's descriptor is deeply equal to the given `descriptor`. See
   * the `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * Add `.not` earlier in the chain to negate `.ownPropertyDescriptor`.
   *
   *     expect({a: 1}).to.not.have.ownPropertyDescriptor('b');
   *
   * However, it's dangerous to negate `.ownPropertyDescriptor` when providing
   * a `descriptor`. The problem is that it creates uncertain expectations by
   * asserting that the target either doesn't have a property descriptor with
   * the given key `name`, or that it does have a property descriptor with the
   * given key `name` but its not deeply equal to the given `descriptor`. It's
   * often best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to have a property descriptor with the given
   * key `name`, it's often best to assert exactly that.
   *
   *     // Recommended
   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a');
   *
   *     // Not recommended
   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * When the target is expected to have a property descriptor with the given
   * key `name`, it's often best to assert that the property has its expected
   * descriptor, rather than asserting that it doesn't have one of many
   * unexpected descriptors.
   *
   *     // Recommended
   *     expect({a: 3}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 3,
   *     });
   *
   *     // Not recommended
   *     expect({a: 3}).to.not.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * `.ownPropertyDescriptor` changes the target of any assertions that follow
   * in the chain to be the value of the property descriptor from the original
   * target object.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a')
   *       .that.has.property('enumerable', true);
   *
   * `.ownPropertyDescriptor` accepts an optional `msg` argument which is a
   * custom error message to show when the assertion fails. The message can also
   * be given as the second argument to `expect`. When not providing
   * `descriptor`, only use the second form.
   *
   *     // Recommended
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 2,
   *     }, 'nooo why fail??');
   *
   *     // Recommended
   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 2,
   *     });
   *
   *     // Recommended
   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('b');
   *
   *     // Not recommended
   *     expect({a: 1})
   *       .to.have.ownPropertyDescriptor('b', undefined, 'nooo why fail??');
   *
   * The above assertion isn't the same thing as not providing `descriptor`.
   * Instead, it's asserting that the target object has a `b` property
   * descriptor that's deeply equal to `undefined`.
   *
   * The alias `.haveOwnPropertyDescriptor` can be used interchangeably with
   * `.ownPropertyDescriptor`.
   *
   * @name ownPropertyDescriptor
   * @alias haveOwnPropertyDescriptor
   * @param {String} name
   * @param {Object} descriptor _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertOwnPropertyDescriptor(name, descriptor, msg) {
    if (typeof descriptor === 'string') {
      msg = descriptor;
      descriptor = null;
    }

    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);

    if (actualDescriptor && descriptor) {
      this.assert(_.eql(descriptor, actualDescriptor), 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor), 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor), descriptor, actualDescriptor, true);
    } else {
      this.assert(actualDescriptor, 'expected #{this} to have an own property descriptor for ' + _.inspect(name), 'expected #{this} to not have an own property descriptor for ' + _.inspect(name));
    }

    flag(this, 'object', actualDescriptor);
  }

  Assertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);
  Assertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);
  /**
   * ### .lengthOf(n[, msg])
   *
   * Asserts that the target's `length` or `size` is equal to the given number
   * `n`.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3);
   *     expect('foo').to.have.lengthOf(3);
   *     expect(new Set([1, 2, 3])).to.have.lengthOf(3);
   *     expect(new Map([['a', 1], ['b', 2], ['c', 3]])).to.have.lengthOf(3);
   *
   * Add `.not` earlier in the chain to negate `.lengthOf`. However, it's often
   * best to assert that the target's `length` property is equal to its expected
   * value, rather than not equal to one of many unexpected values.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.not.have.lengthOf(4); // Not recommended
   *
   * `.lengthOf` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(2, 'nooo why fail??');
   *     expect([1, 2, 3], 'nooo why fail??').to.have.lengthOf(2);
   *
   * `.lengthOf` can also be used as a language chain, causing all `.above`,
   * `.below`, `.least`, `.most`, and `.within` assertions that follow in the
   * chain to use the target's `length` property as the target. However, it's
   * often best to assert that the target's `length` property is equal to its
   * expected length, rather than asserting that its `length` property falls
   * within some range of values.
   *
   *     // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf(3);
   *
   *     // Not recommended
   *     expect([1, 2, 3]).to.have.lengthOf.above(2);
   *     expect([1, 2, 3]).to.have.lengthOf.below(4);
   *     expect([1, 2, 3]).to.have.lengthOf.at.least(3);
   *     expect([1, 2, 3]).to.have.lengthOf.at.most(3);
   *     expect([1, 2, 3]).to.have.lengthOf.within(2,4);
   *
   * Due to a compatibility issue, the alias `.length` can't be chained directly
   * off of an uninvoked method such as `.a`. Therefore, `.length` can't be used
   * interchangeably with `.lengthOf` in every situation. It's recommended to
   * always use `.lengthOf` instead of `.length`.
   *
   *     expect([1, 2, 3]).to.have.a.length(3); // incompatible; throws error
   *     expect([1, 2, 3]).to.have.a.lengthOf(3);  // passes as expected
   *
   * @name lengthOf
   * @alias length
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertLengthChain() {
    flag(this, 'doLength', true);
  }

  function assertLength(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        objType = _.type(obj).toLowerCase(),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi'),
        descriptor = 'length',
        itemsCount;

    switch (objType) {
      case 'map':
      case 'set':
        descriptor = 'size';
        itemsCount = obj.size;
        break;

      default:
        new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
        itemsCount = obj.length;
    }

    this.assert(itemsCount == n, 'expected #{this} to have a ' + descriptor + ' of #{exp} but got #{act}', 'expected #{this} to not have a ' + descriptor + ' of #{act}', n, itemsCount);
  }

  Assertion.addChainableMethod('length', assertLength, assertLengthChain);
  Assertion.addChainableMethod('lengthOf', assertLength, assertLengthChain);
  /**
   * ### .match(re[, msg])
   *
   * Asserts that the target matches the given regular expression `re`.
   *
   *     expect('foobar').to.match(/^foo/);
   *
   * Add `.not` earlier in the chain to negate `.match`.
   *
   *     expect('foobar').to.not.match(/taco/);
   *
   * `.match` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect('foobar').to.match(/taco/, 'nooo why fail??');
   *     expect('foobar', 'nooo why fail??').to.match(/taco/);
   *
   * The alias `.matches` can be used interchangeably with `.match`.
   *
   * @name match
   * @alias matches
   * @param {RegExp} re
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertMatch(re, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(re.exec(obj), 'expected #{this} to match ' + re, 'expected #{this} not to match ' + re);
  }

  Assertion.addMethod('match', assertMatch);
  Assertion.addMethod('matches', assertMatch);
  /**
   * ### .string(str[, msg])
   *
   * Asserts that the target string contains the given substring `str`.
   *
   *     expect('foobar').to.have.string('bar');
   *
   * Add `.not` earlier in the chain to negate `.string`.
   *
   *     expect('foobar').to.not.have.string('taco');
   *
   * `.string` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect('foobar').to.have.string('taco', 'nooo why fail??');
   *     expect('foobar', 'nooo why fail??').to.have.string('taco');
   *
   * @name string
   * @param {String} str
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('string', function (str, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(obj, flagMsg, ssfi, true).is.a('string');
    this.assert(~obj.indexOf(str), 'expected #{this} to contain ' + _.inspect(str), 'expected #{this} to not contain ' + _.inspect(str));
  });
  /**
   * ### .keys(key1[, key2[, ...]])
   *
   * Asserts that the target object, array, map, or set has the given keys. Only
   * the target's own inherited properties are included in the search.
   *
   * When the target is an object or array, keys can be provided as one or more
   * string arguments, a single array argument, or a single object argument. In
   * the latter case, only the keys in the given object matter; the values are
   * ignored.
   *
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *     expect(['x', 'y']).to.have.all.keys(0, 1);
   *
   *     expect({a: 1, b: 2}).to.have.all.keys(['a', 'b']);
   *     expect(['x', 'y']).to.have.all.keys([0, 1]);
   *
   *     expect({a: 1, b: 2}).to.have.all.keys({a: 4, b: 5}); // ignore 4 and 5
   *     expect(['x', 'y']).to.have.all.keys({0: 4, 1: 5}); // ignore 4 and 5
   *
   * When the target is a map or set, each key must be provided as a separate
   * argument.
   *
   *     expect(new Map([['a', 1], ['b', 2]])).to.have.all.keys('a', 'b');
   *     expect(new Set(['a', 'b'])).to.have.all.keys('a', 'b');
   *
   * Because `.keys` does different things based on the target's type, it's
   * important to check the target's type before using `.keys`. See the `.a` doc
   * for info on testing a target's type.
   *
   *     expect({a: 1, b: 2}).to.be.an('object').that.has.all.keys('a', 'b');
   *
   * By default, strict (`===`) equality is used to compare keys of maps and
   * sets. Add `.deep` earlier in the chain to use deep equality instead. See
   * the `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target set deeply (but not strictly) has key `{a: 1}`
   *     expect(new Set([{a: 1}])).to.have.all.deep.keys([{a: 1}]);
   *     expect(new Set([{a: 1}])).to.not.have.all.keys([{a: 1}]);
   *
   * By default, the target must have all of the given keys and no more. Add
   * `.any` earlier in the chain to only require that the target have at least
   * one of the given keys. Also, add `.not` earlier in the chain to negate
   * `.keys`. It's often best to add `.any` when negating `.keys`, and to use
   * `.all` when asserting `.keys` without negation.
   *
   * When negating `.keys`, `.any` is preferred because `.not.any.keys` asserts
   * exactly what's expected of the output, whereas `.not.all.keys` creates
   * uncertain expectations.
   *
   *     // Recommended; asserts that target doesn't have any of the given keys
   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
   *
   *     // Not recommended; asserts that target doesn't have all of the given
   *     // keys but may or may not have some of them
   *     expect({a: 1, b: 2}).to.not.have.all.keys('c', 'd');
   *
   * When asserting `.keys` without negation, `.all` is preferred because
   * `.all.keys` asserts exactly what's expected of the output, whereas
   * `.any.keys` creates uncertain expectations.
   *
   *     // Recommended; asserts that target has all the given keys
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *
   *     // Not recommended; asserts that target has at least one of the given
   *     // keys but may or may not have more of them
   *     expect({a: 1, b: 2}).to.have.any.keys('a', 'b');
   *
   * Note that `.all` is used by default when neither `.all` nor `.any` appear
   * earlier in the chain. However, it's often best to add `.all` anyway because
   * it improves readability.
   *
   *     // Both assertions are identical
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b'); // Recommended
   *     expect({a: 1, b: 2}).to.have.keys('a', 'b'); // Not recommended
   *
   * Add `.include` earlier in the chain to require that the target's keys be a
   * superset of the expected keys, rather than identical sets.
   *
   *     // Target object's keys are a superset of ['a', 'b'] but not identical
   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
   *
   * However, if `.any` and `.include` are combined, only the `.any` takes
   * effect. The `.include` is ignored in this case.
   *
   *     // Both assertions are identical
   *     expect({a: 1}).to.have.any.keys('a', 'b');
   *     expect({a: 1}).to.include.any.keys('a', 'b');
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.have.key('b');
   *
   * The alias `.key` can be used interchangeably with `.keys`.
   *
   * @name keys
   * @alias key
   * @param {...String|Array|Object} keys
   * @namespace BDD
   * @api public
   */

  function assertKeys(keys) {
    var obj = flag(this, 'object'),
        objType = _.type(obj),
        keysType = _.type(keys),
        ssfi = flag(this, 'ssfi'),
        isDeep = flag(this, 'deep'),
        str,
        deepStr = '',
        actual,
        ok = true,
        flagMsg = flag(this, 'message');

    flagMsg = flagMsg ? flagMsg + ': ' : '';
    var mixedArgsMsg = flagMsg + 'when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments';

    if (objType === 'Map' || objType === 'Set') {
      deepStr = isDeep ? 'deeply ' : '';
      actual = []; // Map and Set '.keys' aren't supported in IE 11. Therefore, use .forEach.

      obj.forEach(function (val, key) {
        actual.push(key);
      });

      if (keysType !== 'Array') {
        keys = Array.prototype.slice.call(arguments);
      }
    } else {
      actual = _.getOwnEnumerableProperties(obj);

      switch (keysType) {
        case 'Array':
          if (arguments.length > 1) {
            throw new AssertionError(mixedArgsMsg, undefined, ssfi);
          }

          break;

        case 'Object':
          if (arguments.length > 1) {
            throw new AssertionError(mixedArgsMsg, undefined, ssfi);
          }

          keys = Object.keys(keys);
          break;

        default:
          keys = Array.prototype.slice.call(arguments);
      } // Only stringify non-Symbols because Symbols would become "Symbol()"


      keys = keys.map(function (val) {
        return _typeof(val) === 'symbol' ? val : String(val);
      });
    }

    if (!keys.length) {
      throw new AssertionError(flagMsg + 'keys required', undefined, ssfi);
    }

    var len = keys.length,
        any = flag(this, 'any'),
        all = flag(this, 'all'),
        expected = keys;

    if (!any && !all) {
      all = true;
    } // Has any


    if (any) {
      ok = expected.some(function (expectedKey) {
        return actual.some(function (actualKey) {
          if (isDeep) {
            return _.eql(expectedKey, actualKey);
          } else {
            return expectedKey === actualKey;
          }
        });
      });
    } // Has all


    if (all) {
      ok = expected.every(function (expectedKey) {
        return actual.some(function (actualKey) {
          if (isDeep) {
            return _.eql(expectedKey, actualKey);
          } else {
            return expectedKey === actualKey;
          }
        });
      });

      if (!flag(this, 'contains')) {
        ok = ok && keys.length == actual.length;
      }
    } // Key string


    if (len > 1) {
      keys = keys.map(function (key) {
        return _.inspect(key);
      });
      var last = keys.pop();

      if (all) {
        str = keys.join(', ') + ', and ' + last;
      }

      if (any) {
        str = keys.join(', ') + ', or ' + last;
      }
    } else {
      str = _.inspect(keys[0]);
    } // Form


    str = (len > 1 ? 'keys ' : 'key ') + str; // Have / include

    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str; // Assertion

    this.assert(ok, 'expected #{this} to ' + deepStr + str, 'expected #{this} to not ' + deepStr + str, expected.slice(0).sort(_.compareByInspect), actual.sort(_.compareByInspect), true);
  }

  Assertion.addMethod('keys', assertKeys);
  Assertion.addMethod('key', assertKeys);
  /**
   * ### .throw([errorLike], [errMsgMatcher], [msg])
   *
   * When no arguments are provided, `.throw` invokes the target function and
   * asserts that an error is thrown.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw();
   *
   * When one argument is provided, and it's an error constructor, `.throw`
   * invokes the target function and asserts that an error is thrown that's an
   * instance of that error constructor.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(TypeError);
   *
   * When one argument is provided, and it's an error instance, `.throw` invokes
   * the target function and asserts that an error is thrown that's strictly
   * (`===`) equal to that error instance.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(err);
   *
   * When one argument is provided, and it's a string, `.throw` invokes the
   * target function and asserts that an error is thrown with a message that
   * contains that string.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw('salmon');
   *
   * When one argument is provided, and it's a regular expression, `.throw`
   * invokes the target function and asserts that an error is thrown with a
   * message that matches that regular expression.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(/salmon/);
   *
   * When two arguments are provided, and the first is an error instance or
   * constructor, and the second is a string or regular expression, `.throw`
   * invokes the function and asserts that an error is thrown that fulfills both
   * conditions as described above.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(TypeError, 'salmon');
   *     expect(badFn).to.throw(TypeError, /salmon/);
   *     expect(badFn).to.throw(err, 'salmon');
   *     expect(badFn).to.throw(err, /salmon/);
   *
   * Add `.not` earlier in the chain to negate `.throw`.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.not.throw();
   *
   * However, it's dangerous to negate `.throw` when providing any arguments.
   * The problem is that it creates uncertain expectations by asserting that the
   * target either doesn't throw an error, or that it throws an error but of a
   * different type than the given type, or that it throws an error of the given
   * type but with a message that doesn't include the given string. It's often
   * best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to throw an error, it's often best to assert
   * exactly that.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.not.throw(); // Recommended
   *     expect(goodFn).to.not.throw(ReferenceError, 'x'); // Not recommended
   *
   * When the target is expected to throw an error, it's often best to assert
   * that the error is of its expected type, and has a message that includes an
   * expected string, rather than asserting that it doesn't have one of many
   * unexpected types, and doesn't have a message that includes some string.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(TypeError, 'salmon'); // Recommended
   *     expect(badFn).to.not.throw(ReferenceError, 'x'); // Not recommended
   *
   * `.throw` changes the target of any assertions that follow in the chain to
   * be the error object that's thrown.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     err.code = 42;
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(TypeError).with.property('code', 42);
   *
   * `.throw` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`. When not providing two arguments, always use
   * the second form.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.throw(TypeError, 'x', 'nooo why fail??');
   *     expect(goodFn, 'nooo why fail??').to.throw();
   *
   * Due to limitations in ES5, `.throw` may not always work as expected when
   * using a transpiler such as Babel or TypeScript. In particular, it may
   * produce unexpected results when subclassing the built-in `Error` object and
   * then passing the subclassed constructor to `.throw`. See your transpiler's
   * docs for details:
   *
   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))
   *
   * Beware of some common mistakes when using the `throw` assertion. One common
   * mistake is to accidentally invoke the function yourself instead of letting
   * the `throw` assertion invoke the function for you. For example, when
   * testing if a function named `fn` throws, provide `fn` instead of `fn()` as
   * the target for the assertion.
   *
   *     expect(fn).to.throw();     // Good! Tests `fn` as desired
   *     expect(fn()).to.throw();   // Bad! Tests result of `fn()`, not `fn`
   *
   * If you need to assert that your function `fn` throws when passed certain
   * arguments, then wrap a call to `fn` inside of another function.
   *
   *     expect(function () { fn(42); }).to.throw();  // Function expression
   *     expect(() => fn(42)).to.throw();             // ES6 arrow function
   *
   * Another common mistake is to provide an object method (or any stand-alone
   * function that relies on `this`) as the target of the assertion. Doing so is
   * problematic because the `this` context will be lost when the function is
   * invoked by `.throw`; there's no way for it to know what `this` is supposed
   * to be. There are two ways around this problem. One solution is to wrap the
   * method or function call inside of another function. Another solution is to
   * use `bind`.
   *
   *     expect(function () { cat.meow(); }).to.throw();  // Function expression
   *     expect(() => cat.meow()).to.throw();             // ES6 arrow function
   *     expect(cat.meow.bind(cat)).to.throw();           // Bind
   *
   * Finally, it's worth mentioning that it's a best practice in JavaScript to
   * only throw `Error` and derivatives of `Error` such as `ReferenceError`,
   * `TypeError`, and user-defined objects that extend `Error`. No other type of
   * value will generate a stack trace when initialized. With that said, the
   * `throw` assertion does technically support any type of value being thrown,
   * not just `Error` and its derivatives.
   *
   * The aliases `.throws` and `.Throw` can be used interchangeably with
   * `.throw`.
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {Error|ErrorConstructor} errorLike
   * @param {String|RegExp} errMsgMatcher error message
   * @param {String} msg _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @namespace BDD
   * @api public
   */

  function assertThrows(errorLike, errMsgMatcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        ssfi = flag(this, 'ssfi'),
        flagMsg = flag(this, 'message'),
        negate = flag(this, 'negate') || false;
    new Assertion(obj, flagMsg, ssfi, true).is.a('function');

    if (errorLike instanceof RegExp || typeof errorLike === 'string') {
      errMsgMatcher = errorLike;
      errorLike = null;
    }

    var caughtErr;

    try {
      obj();
    } catch (err) {
      caughtErr = err;
    } // If we have the negate flag enabled and at least one valid argument it means we do expect an error
    // but we want it to match a given set of criteria


    var everyArgIsUndefined = errorLike === undefined && errMsgMatcher === undefined; // If we've got the negate flag enabled and both args, we should only fail if both aren't compatible
    // See Issue #551 and PR #683@GitHub

    var everyArgIsDefined = Boolean(errorLike && errMsgMatcher);
    var errorLikeFail = false;
    var errMsgMatcherFail = false; // Checking if error was thrown

    if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {
      // We need this to display results correctly according to their types
      var errorLikeString = 'an error';

      if (errorLike instanceof Error) {
        errorLikeString = '#{exp}';
      } else if (errorLike) {
        errorLikeString = _.checkError.getConstructorName(errorLike);
      }

      this.assert(caughtErr, 'expected #{this} to throw ' + errorLikeString, 'expected #{this} to not throw an error but #{act} was thrown', errorLike && errorLike.toString(), caughtErr instanceof Error ? caughtErr.toString() : typeof caughtErr === 'string' ? caughtErr : caughtErr && _.checkError.getConstructorName(caughtErr));
    }

    if (errorLike && caughtErr) {
      // We should compare instances only if `errorLike` is an instance of `Error`
      if (errorLike instanceof Error) {
        var isCompatibleInstance = _.checkError.compatibleInstance(caughtErr, errorLike);

        if (isCompatibleInstance === negate) {
          // These checks were created to ensure we won't fail too soon when we've got both args and a negate
          // See Issue #551 and PR #683@GitHub
          if (everyArgIsDefined && negate) {
            errorLikeFail = true;
          } else {
            this.assert(negate, 'expected #{this} to throw #{exp} but #{act} was thrown', 'expected #{this} to not throw #{exp}' + (caughtErr && !negate ? ' but #{act} was thrown' : ''), errorLike.toString(), caughtErr.toString());
          }
        }
      }

      var isCompatibleConstructor = _.checkError.compatibleConstructor(caughtErr, errorLike);

      if (isCompatibleConstructor === negate) {
        if (everyArgIsDefined && negate) {
          errorLikeFail = true;
        } else {
          this.assert(negate, 'expected #{this} to throw #{exp} but #{act} was thrown', 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : ''), errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike), caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr));
        }
      }
    }

    if (caughtErr && errMsgMatcher !== undefined && errMsgMatcher !== null) {
      // Here we check compatible messages
      var placeholder = 'including';

      if (errMsgMatcher instanceof RegExp) {
        placeholder = 'matching';
      }

      var isCompatibleMessage = _.checkError.compatibleMessage(caughtErr, errMsgMatcher);

      if (isCompatibleMessage === negate) {
        if (everyArgIsDefined && negate) {
          errMsgMatcherFail = true;
        } else {
          this.assert(negate, 'expected #{this} to throw error ' + placeholder + ' #{exp} but got #{act}', 'expected #{this} to throw error not ' + placeholder + ' #{exp}', errMsgMatcher, _.checkError.getMessage(caughtErr));
        }
      }
    } // If both assertions failed and both should've matched we throw an error


    if (errorLikeFail && errMsgMatcherFail) {
      this.assert(negate, 'expected #{this} to throw #{exp} but #{act} was thrown', 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : ''), errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike), caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr));
    }

    flag(this, 'object', caughtErr);
  }

  ;
  Assertion.addMethod('throw', assertThrows);
  Assertion.addMethod('throws', assertThrows);
  Assertion.addMethod('Throw', assertThrows);
  /**
   * ### .respondTo(method[, msg])
   *
   * When the target is a non-function object, `.respondTo` asserts that the
   * target has a method with the given name `method`. The method can be own or
   * inherited, and it can be enumerable or non-enumerable.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(new Cat()).to.respondTo('meow');
   *
   * When the target is a function, `.respondTo` asserts that the target's
   * `prototype` property has a method with the given name `method`. Again, the
   * method can be own or inherited, and it can be enumerable or non-enumerable.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(Cat).to.respondTo('meow');
   *
   * Add `.itself` earlier in the chain to force `.respondTo` to treat the
   * target as a non-function object, even if it's a function. Thus, it asserts
   * that the target has a method with the given name `method`, rather than
   * asserting that the target's `prototype` property has a method with the
   * given name `method`.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *     Cat.hiss = function () {};
   *
   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
   *
   * When not adding `.itself`, it's important to check the target's type before
   * using `.respondTo`. See the `.a` doc for info on checking a target's type.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(new Cat()).to.be.an('object').that.respondsTo('meow');
   *
   * Add `.not` earlier in the chain to negate `.respondTo`.
   *
   *     function Dog () {}
   *     Dog.prototype.bark = function () {};
   *
   *     expect(new Dog()).to.not.respondTo('meow');
   *
   * `.respondTo` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect({}).to.respondTo('meow', 'nooo why fail??');
   *     expect({}, 'nooo why fail??').to.respondTo('meow');
   *
   * The alias `.respondsTo` can be used interchangeably with `.respondTo`.
   *
   * @name respondTo
   * @alias respondsTo
   * @param {String} method
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function respondTo(method, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        itself = flag(this, 'itself'),
        context = 'function' === typeof obj && !itself ? obj.prototype[method] : obj[method];
    this.assert('function' === typeof context, 'expected #{this} to respond to ' + _.inspect(method), 'expected #{this} to not respond to ' + _.inspect(method));
  }

  Assertion.addMethod('respondTo', respondTo);
  Assertion.addMethod('respondsTo', respondTo);
  /**
   * ### .itself
   *
   * Forces all `.respondTo` assertions that follow in the chain to behave as if
   * the target is a non-function object, even if it's a function. Thus, it
   * causes `.respondTo` to assert that the target has a method with the given
   * name, rather than asserting that the target's `prototype` property has a
   * method with the given name.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *     Cat.hiss = function () {};
   *
   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
   *
   * @name itself
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('itself', function () {
    flag(this, 'itself', true);
  });
  /**
   * ### .satisfy(matcher[, msg])
   *
   * Invokes the given `matcher` function with the target being passed as the
   * first argument, and asserts that the value returned is truthy.
   *
   *     expect(1).to.satisfy(function(num) {
   *       return num > 0;
   *     });
   *
   * Add `.not` earlier in the chain to negate `.satisfy`.
   *
   *     expect(1).to.not.satisfy(function(num) {
   *       return num > 2;
   *     });
   *
   * `.satisfy` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(1).to.satisfy(function(num) {
   *       return num > 2;
   *     }, 'nooo why fail??');
   *
   *     expect(1, 'nooo why fail??').to.satisfy(function(num) {
   *       return num > 2;
   *     });
   *
   * The alias `.satisfies` can be used interchangeably with `.satisfy`.
   *
   * @name satisfy
   * @alias satisfies
   * @param {Function} matcher
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function satisfy(matcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var result = matcher(obj);
    this.assert(result, 'expected #{this} to satisfy ' + _.objDisplay(matcher), 'expected #{this} to not satisfy' + _.objDisplay(matcher), flag(this, 'negate') ? false : true, result);
  }

  Assertion.addMethod('satisfy', satisfy);
  Assertion.addMethod('satisfies', satisfy);
  /**
   * ### .closeTo(expected, delta[, msg])
   *
   * Asserts that the target is a number that's within a given +/- `delta` range
   * of the given number `expected`. However, it's often best to assert that the
   * target is equal to its expected value.
   *
   *     // Recommended
   *     expect(1.5).to.equal(1.5);
   *
   *     // Not recommended
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *     expect(1.5).to.be.closeTo(2, 0.5);
   *     expect(1.5).to.be.closeTo(1, 1);
   *
   * Add `.not` earlier in the chain to negate `.closeTo`.
   *
   *     expect(1.5).to.equal(1.5); // Recommended
   *     expect(1.5).to.not.be.closeTo(3, 1); // Not recommended
   *
   * `.closeTo` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(1.5).to.be.closeTo(3, 1, 'nooo why fail??');
   *     expect(1.5, 'nooo why fail??').to.be.closeTo(3, 1);
   *
   * The alias `.approximately` can be used interchangeably with `.closeTo`.
   *
   * @name closeTo
   * @alias approximately
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function closeTo(expected, delta, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(obj, flagMsg, ssfi, true).is.a('number');

    if (typeof expected !== 'number' || typeof delta !== 'number') {
      flagMsg = flagMsg ? flagMsg + ': ' : '';
      throw new AssertionError(flagMsg + 'the arguments to closeTo or approximately must be numbers', undefined, ssfi);
    }

    this.assert(Math.abs(obj - expected) <= delta, 'expected #{this} to be close to ' + expected + ' +/- ' + delta, 'expected #{this} not to be close to ' + expected + ' +/- ' + delta);
  }

  Assertion.addMethod('closeTo', closeTo);
  Assertion.addMethod('approximately', closeTo); // Note: Duplicates are ignored if testing for inclusion instead of sameness.

  function isSubsetOf(subset, superset, cmp, contains, ordered) {
    if (!contains) {
      if (subset.length !== superset.length) return false;
      superset = superset.slice();
    }

    return subset.every(function (elem, idx) {
      if (ordered) return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];

      if (!cmp) {
        var matchIdx = superset.indexOf(elem);
        if (matchIdx === -1) return false; // Remove match from superset so not counted twice if duplicate in subset.

        if (!contains) superset.splice(matchIdx, 1);
        return true;
      }

      return superset.some(function (elem2, matchIdx) {
        if (!cmp(elem, elem2)) return false; // Remove match from superset so not counted twice if duplicate in subset.

        if (!contains) superset.splice(matchIdx, 1);
        return true;
      });
    });
  }
  /**
   * ### .members(set[, msg])
   *
   * Asserts that the target array has the same members as the given array
   * `set`.
   *
   *     expect([1, 2, 3]).to.have.members([2, 1, 3]);
   *     expect([1, 2, 2]).to.have.members([2, 1, 2]);
   *
   * By default, members are compared using strict (`===`) equality. Add `.deep`
   * earlier in the chain to use deep equality instead. See the `deep-eql`
   * project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target array deeply (but not strictly) has member `{a: 1}`
   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);
   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);
   *
   * By default, order doesn't matter. Add `.ordered` earlier in the chain to
   * require that members appear in the same order.
   *
   *     expect([1, 2, 3]).to.have.ordered.members([1, 2, 3]);
   *     expect([1, 2, 3]).to.have.members([2, 1, 3])
   *       .but.not.ordered.members([2, 1, 3]);
   *
   * By default, both arrays must be the same size. Add `.include` earlier in
   * the chain to require that the target's members be a superset of the
   * expected members. Note that duplicates are ignored in the subset when
   * `.include` is added.
   *
   *     // Target array is a superset of [1, 2] but not identical
   *     expect([1, 2, 3]).to.include.members([1, 2]);
   *     expect([1, 2, 3]).to.not.have.members([1, 2]);
   *
   *     // Duplicates in the subset are ignored
   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
   *
   * `.deep`, `.ordered`, and `.include` can all be combined. However, if
   * `.include` and `.ordered` are combined, the ordering begins at the start of
   * both arrays.
   *
   *     expect([{a: 1}, {b: 2}, {c: 3}])
   *       .to.include.deep.ordered.members([{a: 1}, {b: 2}])
   *       .but.not.include.deep.ordered.members([{b: 2}, {c: 3}]);
   *
   * Add `.not` earlier in the chain to negate `.members`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the target array doesn't have all of the same members as
   * the given array `set` but may or may not have some of them. It's often best
   * to identify the exact output that's expected, and then write an assertion
   * that only accepts that exact output.
   *
   *     expect([1, 2]).to.not.include(3).and.not.include(4); // Recommended
   *     expect([1, 2]).to.not.have.members([3, 4]); // Not recommended
   *
   * `.members` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect([1, 2]).to.have.members([1, 2, 3], 'nooo why fail??');
   *     expect([1, 2], 'nooo why fail??').to.have.members([1, 2, 3]);
   *
   * @name members
   * @param {Array} set
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */


  Assertion.addMethod('members', function (subset, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(obj, flagMsg, ssfi, true).to.be.an('array');
    new Assertion(subset, flagMsg, ssfi, true).to.be.an('array');
    var contains = flag(this, 'contains');
    var ordered = flag(this, 'ordered');
    var subject, failMsg, failNegateMsg;

    if (contains) {
      subject = ordered ? 'an ordered superset' : 'a superset';
      failMsg = 'expected #{this} to be ' + subject + ' of #{exp}';
      failNegateMsg = 'expected #{this} to not be ' + subject + ' of #{exp}';
    } else {
      subject = ordered ? 'ordered members' : 'members';
      failMsg = 'expected #{this} to have the same ' + subject + ' as #{exp}';
      failNegateMsg = 'expected #{this} to not have the same ' + subject + ' as #{exp}';
    }

    var cmp = flag(this, 'deep') ? _.eql : undefined;
    this.assert(isSubsetOf(subset, obj, cmp, contains, ordered), failMsg, failNegateMsg, subset, obj, true);
  });
  /**
   * ### .oneOf(list[, msg])
   *
   * Asserts that the target is a member of the given array `list`. However,
   * it's often best to assert that the target is equal to its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.oneOf([1, 2, 3]); // Not recommended
   *
   * Comparisons are performed using strict (`===`) equality.
   *
   * Add `.not` earlier in the chain to negate `.oneOf`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.oneOf([2, 3, 4]); // Not recommended
   *
   * `.oneOf` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.be.oneOf([2, 3, 4], 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.oneOf([2, 3, 4]);
   *
   * @name oneOf
   * @param {Array<*>} list
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function oneOf(list, msg) {
    if (msg) flag(this, 'message', msg);
    var expected = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(list, flagMsg, ssfi, true).to.be.an('array');
    this.assert(list.indexOf(expected) > -1, 'expected #{this} to be one of #{exp}', 'expected #{this} to not be one of #{exp}', list, expected);
  }

  Assertion.addMethod('oneOf', oneOf);
  /**
   * ### .change(subject[, prop[, msg]])
   *
   * When one argument is provided, `.change` asserts that the given function
   * `subject` returns a different value when it's invoked before the target
   * function compared to when it's invoked afterward. However, it's often best
   * to assert that `subject` is equal to its expected value.
   *
   *     var dots = ''
   *       , addDot = function () { dots += '.'; }
   *       , getDots = function () { return dots; };
   *
   *     // Recommended
   *     expect(getDots()).to.equal('');
   *     addDot();
   *     expect(getDots()).to.equal('.');
   *
   *     // Not recommended
   *     expect(addDot).to.change(getDots);
   *
   * When two arguments are provided, `.change` asserts that the value of the
   * given object `subject`'s `prop` property is different before invoking the
   * target function compared to afterward.
   *
   *     var myObj = {dots: ''}
   *       , addDot = function () { myObj.dots += '.'; };
   *
   *     // Recommended
   *     expect(myObj).to.have.property('dots', '');
   *     addDot();
   *     expect(myObj).to.have.property('dots', '.');
   *
   *     // Not recommended
   *     expect(addDot).to.change(myObj, 'dots');
   *
   * Strict (`===`) equality is used to compare before and after values.
   *
   * Add `.not` earlier in the chain to negate `.change`.
   *
   *     var dots = ''
   *       , noop = function () {}
   *       , getDots = function () { return dots; };
   *
   *     expect(noop).to.not.change(getDots);
   *
   *     var myObj = {dots: ''}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'dots');
   *
   * `.change` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {dots: ''}
   *       , addDot = function () { myObj.dots += '.'; };
   *
   *     expect(addDot).to.not.change(myObj, 'dots', 'nooo why fail??');
   *
   *     var dots = ''
   *       , addDot = function () { dots += '.'; }
   *       , getDots = function () { return dots; };
   *
   *     expect(addDot, 'nooo why fail??').to.not.change(getDots);
   *
   * `.change` also causes all `.by` assertions that follow in the chain to
   * assert how much a numeric subject was increased or decreased by. However,
   * it's dangerous to use `.change.by`. The problem is that it creates
   * uncertain expectations by asserting that the subject either increases by
   * the given delta, or that it decreases by the given delta. It's often best
   * to identify the exact output that's expected, and then write an assertion
   * that only accepts that exact output.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; }
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   * The alias `.changes` can be used interchangeably with `.change`.
   *
   * @name change
   * @alias changes
   * @param {String} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertChanges(subject, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(fn, flagMsg, ssfi, true).is.a('function');
    var initial;

    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    }

    fn();
    var final = prop === undefined || prop === null ? subject() : subject[prop];
    var msgObj = prop === undefined || prop === null ? initial : '.' + prop; // This gets flagged because of the .by(delta) assertion

    flag(this, 'deltaMsgObj', msgObj);
    flag(this, 'initialDeltaValue', initial);
    flag(this, 'finalDeltaValue', final);
    flag(this, 'deltaBehavior', 'change');
    flag(this, 'realDelta', final !== initial);
    this.assert(initial !== final, 'expected ' + msgObj + ' to change', 'expected ' + msgObj + ' to not change');
  }

  Assertion.addMethod('change', assertChanges);
  Assertion.addMethod('changes', assertChanges);
  /**
   * ### .increase(subject[, prop[, msg]])
   *
   * When one argument is provided, `.increase` asserts that the given function
   * `subject` returns a greater number when it's invoked after invoking the
   * target function compared to when it's invoked beforehand. `.increase` also
   * causes all `.by` assertions that follow in the chain to assert how much
   * greater of a number is returned. It's often best to assert that the return
   * value increased by the expected amount, rather than asserting it increased
   * by any amount.
   *
   *     var val = 1
   *       , addTwo = function () { val += 2; }
   *       , getVal = function () { return val; };
   *
   *     expect(addTwo).to.increase(getVal).by(2); // Recommended
   *     expect(addTwo).to.increase(getVal); // Not recommended
   *
   * When two arguments are provided, `.increase` asserts that the value of the
   * given object `subject`'s `prop` property is greater after invoking the
   * target function compared to beforehand.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.increase(myObj, 'val'); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.increase`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either decreases, or that it stays the same.
   * It's often best to identify the exact output that's expected, and then
   * write an assertion that only accepts that exact output.
   *
   * When the subject is expected to decrease, it's often best to assert that it
   * decreased by the expected amount.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.not.increase(myObj, 'val'); // Not recommended
   *
   * When the subject is expected to stay the same, it's often best to assert
   * exactly that.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'val'); // Recommended
   *     expect(noop).to.not.increase(myObj, 'val'); // Not recommended
   *
   * `.increase` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.increase(myObj, 'val', 'nooo why fail??');
   *
   *     var val = 1
   *       , noop = function () {}
   *       , getVal = function () { return val; };
   *
   *     expect(noop, 'nooo why fail??').to.increase(getVal);
   *
   * The alias `.increases` can be used interchangeably with `.increase`.
   *
   * @name increase
   * @alias increases
   * @param {String|Function} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertIncreases(subject, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(fn, flagMsg, ssfi, true).is.a('function');
    var initial;

    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    } // Make sure that the target is a number


    new Assertion(initial, flagMsg, ssfi, true).is.a('number');
    fn();
    var final = prop === undefined || prop === null ? subject() : subject[prop];
    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;
    flag(this, 'deltaMsgObj', msgObj);
    flag(this, 'initialDeltaValue', initial);
    flag(this, 'finalDeltaValue', final);
    flag(this, 'deltaBehavior', 'increase');
    flag(this, 'realDelta', final - initial);
    this.assert(final - initial > 0, 'expected ' + msgObj + ' to increase', 'expected ' + msgObj + ' to not increase');
  }

  Assertion.addMethod('increase', assertIncreases);
  Assertion.addMethod('increases', assertIncreases);
  /**
   * ### .decrease(subject[, prop[, msg]])
   *
   * When one argument is provided, `.decrease` asserts that the given function
   * `subject` returns a lesser number when it's invoked after invoking the
   * target function compared to when it's invoked beforehand. `.decrease` also
   * causes all `.by` assertions that follow in the chain to assert how much
   * lesser of a number is returned. It's often best to assert that the return
   * value decreased by the expected amount, rather than asserting it decreased
   * by any amount.
   *
   *     var val = 1
   *       , subtractTwo = function () { val -= 2; }
   *       , getVal = function () { return val; };
   *
   *     expect(subtractTwo).to.decrease(getVal).by(2); // Recommended
   *     expect(subtractTwo).to.decrease(getVal); // Not recommended
   *
   * When two arguments are provided, `.decrease` asserts that the value of the
   * given object `subject`'s `prop` property is lesser after invoking the
   * target function compared to beforehand.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.decrease(myObj, 'val'); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.decrease`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either increases, or that it stays the same.
   * It's often best to identify the exact output that's expected, and then
   * write an assertion that only accepts that exact output.
   *
   * When the subject is expected to increase, it's often best to assert that it
   * increased by the expected amount.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.not.decrease(myObj, 'val'); // Not recommended
   *
   * When the subject is expected to stay the same, it's often best to assert
   * exactly that.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'val'); // Recommended
   *     expect(noop).to.not.decrease(myObj, 'val'); // Not recommended
   *
   * `.decrease` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.decrease(myObj, 'val', 'nooo why fail??');
   *
   *     var val = 1
   *       , noop = function () {}
   *       , getVal = function () { return val; };
   *
   *     expect(noop, 'nooo why fail??').to.decrease(getVal);
   *
   * The alias `.decreases` can be used interchangeably with `.decrease`.
   *
   * @name decrease
   * @alias decreases
   * @param {String|Function} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertDecreases(subject, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(fn, flagMsg, ssfi, true).is.a('function');
    var initial;

    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    } // Make sure that the target is a number


    new Assertion(initial, flagMsg, ssfi, true).is.a('number');
    fn();
    var final = prop === undefined || prop === null ? subject() : subject[prop];
    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;
    flag(this, 'deltaMsgObj', msgObj);
    flag(this, 'initialDeltaValue', initial);
    flag(this, 'finalDeltaValue', final);
    flag(this, 'deltaBehavior', 'decrease');
    flag(this, 'realDelta', initial - final);
    this.assert(final - initial < 0, 'expected ' + msgObj + ' to decrease', 'expected ' + msgObj + ' to not decrease');
  }

  Assertion.addMethod('decrease', assertDecreases);
  Assertion.addMethod('decreases', assertDecreases);
  /**
   * ### .by(delta[, msg])
   *
   * When following an `.increase` assertion in the chain, `.by` asserts that
   * the subject of the `.increase` assertion increased by the given `delta`.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2);
   *
   * When following a `.decrease` assertion in the chain, `.by` asserts that the
   * subject of the `.decrease` assertion decreased by the given `delta`.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2);
   *
   * When following a `.change` assertion in the chain, `.by` asserts that the
   * subject of the `.change` assertion either increased or decreased by the
   * given `delta`. However, it's dangerous to use `.change.by`. The problem is
   * that it creates uncertain expectations. It's often best to identify the
   * exact output that's expected, and then write an assertion that only accepts
   * that exact output.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; }
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.by`. However, it's often best
   * to assert that the subject changed by its expected delta, rather than
   * asserting that it didn't change by one of countless unexpected deltas.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     // Recommended
   *     expect(addTwo).to.increase(myObj, 'val').by(2);
   *
   *     // Not recommended
   *     expect(addTwo).to.increase(myObj, 'val').but.not.by(3);
   *
   * `.by` accepts an optional `msg` argument which is a custom error message to
   * show when the assertion fails. The message can also be given as the second
   * argument to `expect`.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(3, 'nooo why fail??');
   *     expect(addTwo, 'nooo why fail??').to.increase(myObj, 'val').by(3);
   *
   * @name by
   * @param {Number} delta
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertDelta(delta, msg) {
    if (msg) flag(this, 'message', msg);
    var msgObj = flag(this, 'deltaMsgObj');
    var initial = flag(this, 'initialDeltaValue');
    var final = flag(this, 'finalDeltaValue');
    var behavior = flag(this, 'deltaBehavior');
    var realDelta = flag(this, 'realDelta');
    var expression;

    if (behavior === 'change') {
      expression = Math.abs(final - initial) === Math.abs(delta);
    } else {
      expression = realDelta === Math.abs(delta);
    }

    this.assert(expression, 'expected ' + msgObj + ' to ' + behavior + ' by ' + delta, 'expected ' + msgObj + ' to not ' + behavior + ' by ' + delta);
  }

  Assertion.addMethod('by', assertDelta);
  /**
   * ### .extensible
   *
   * Asserts that the target is extensible, which means that new properties can
   * be added to it. Primitives are never extensible.
   *
   *     expect({a: 1}).to.be.extensible;
   *
   * Add `.not` earlier in the chain to negate `.extensible`.
   *
   *     var nonExtensibleObject = Object.preventExtensions({})
   *       , sealedObject = Object.seal({})
   *       , frozenObject = Object.freeze({});
   *
   *     expect(nonExtensibleObject).to.not.be.extensible;
   *     expect(sealedObject).to.not.be.extensible;
   *     expect(frozenObject).to.not.be.extensible;
   *     expect(1).to.not.be.extensible;
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(1, 'nooo why fail??').to.be.extensible;
   *
   * @name extensible
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('extensible', function () {
    var obj = flag(this, 'object'); // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible
    // The following provides ES6 behavior for ES5 environments.

    var isExtensible = obj === Object(obj) && Object.isExtensible(obj);
    this.assert(isExtensible, 'expected #{this} to be extensible', 'expected #{this} to not be extensible');
  });
  /**
   * ### .sealed
   *
   * Asserts that the target is sealed, which means that new properties can't be
   * added to it, and its existing properties can't be reconfigured or deleted.
   * However, it's possible that its existing properties can still be reassigned
   * to different values. Primitives are always sealed.
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect(sealedObject).to.be.sealed;
   *     expect(frozenObject).to.be.sealed;
   *     expect(1).to.be.sealed;
   *
   * Add `.not` earlier in the chain to negate `.sealed`.
   *
   *     expect({a: 1}).to.not.be.sealed;
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.be.sealed;
   *
   * @name sealed
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('sealed', function () {
    var obj = flag(this, 'object'); // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed
    // The following provides ES6 behavior for ES5 environments.

    var isSealed = obj === Object(obj) ? Object.isSealed(obj) : true;
    this.assert(isSealed, 'expected #{this} to be sealed', 'expected #{this} to not be sealed');
  });
  /**
   * ### .frozen
   *
   * Asserts that the target is frozen, which means that new properties can't be
   * added to it, and its existing properties can't be reassigned to different
   * values, reconfigured, or deleted. Primitives are always frozen.
   *
   *     var frozenObject = Object.freeze({});
   *
   *     expect(frozenObject).to.be.frozen;
   *     expect(1).to.be.frozen;
   *
   * Add `.not` earlier in the chain to negate `.frozen`.
   *
   *     expect({a: 1}).to.not.be.frozen;
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.be.frozen;
   *
   * @name frozen
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('frozen', function () {
    var obj = flag(this, 'object'); // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen
    // The following provides ES6 behavior for ES5 environments.

    var isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : true;
    this.assert(isFrozen, 'expected #{this} to be frozen', 'expected #{this} to not be frozen');
  });
  /**
   * ### .finite
   *
   * Asserts that the target is a number, and isn't `NaN` or positive/negative
   * `Infinity`.
   *
   *     expect(1).to.be.finite;
   *
   * Add `.not` earlier in the chain to negate `.finite`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either isn't a number, or that it's `NaN`, or
   * that it's positive `Infinity`, or that it's negative `Infinity`. It's often
   * best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to be a number, it's often best to assert
   * that it's the expected type, rather than asserting that it isn't one of
   * many unexpected types.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.finite; // Not recommended
   *
   * When the target is expected to be `NaN`, it's often best to assert exactly
   * that.
   *
   *     expect(NaN).to.be.NaN; // Recommended
   *     expect(NaN).to.not.be.finite; // Not recommended
   *
   * When the target is expected to be positive infinity, it's often best to
   * assert exactly that.
   *
   *     expect(Infinity).to.equal(Infinity); // Recommended
   *     expect(Infinity).to.not.be.finite; // Not recommended
   *
   * When the target is expected to be negative infinity, it's often best to
   * assert exactly that.
   *
   *     expect(-Infinity).to.equal(-Infinity); // Recommended
   *     expect(-Infinity).to.not.be.finite; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect('foo', 'nooo why fail??').to.be.finite;
   *
   * @name finite
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('finite', function (msg) {
    var obj = flag(this, 'object');
    this.assert(typeof obj === 'number' && isFinite(obj), 'expected #{this} to be a finite number', 'expected #{this} to not be a finite number');
  });
};
},{}],"../node_modules/chai/lib/chai/interface/expect.js":[function(require,module,exports) {
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
module.exports = function (chai, util) {
  chai.expect = function (val, message) {
    return new chai.Assertion(val, message);
  };
  /**
   * ### .fail([message])
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure.
   *
   *     expect.fail();
   *     expect.fail("custom error message");
   *     expect.fail(1, 2);
   *     expect.fail(1, 2, "custom error message");
   *     expect.fail(1, 2, "custom error message", ">");
   *     expect.fail(1, 2, undefined, ">");
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace BDD
   * @api public
   */


  chai.expect.fail = function (actual, expected, message, operator) {
    if (arguments.length < 2) {
      message = actual;
      actual = undefined;
    }

    message = message || 'expect.fail()';
    throw new chai.AssertionError(message, {
      actual: actual,
      expected: expected,
      operator: operator
    }, chai.expect.fail);
  };
};
},{}],"../node_modules/chai/lib/chai/interface/should.js":[function(require,module,exports) {
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
module.exports = function (chai, util) {
  var Assertion = chai.Assertion;

  function loadShould() {
    // explicitly define this method as function as to have it's name to include as `ssfi`
    function shouldGetter() {
      if (this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol === 'function' && this instanceof Symbol) {
        return new Assertion(this.valueOf(), null, shouldGetter);
      }

      return new Assertion(this, null, shouldGetter);
    }

    function shouldSetter(value) {
      // See https://github.com/chaijs/chai/issues/86: this makes
      // `whatever.should = someValue` actually set `someValue`, which is
      // especially useful for `global.should = require('chai').should()`.
      //
      // Note that we have to use [[DefineProperty]] instead of [[Put]]
      // since otherwise we would trigger this very setter!
      Object.defineProperty(this, 'should', {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } // modify Object.prototype to have `should`


    Object.defineProperty(Object.prototype, 'should', {
      set: shouldSetter,
      get: shouldGetter,
      configurable: true
    });
    var should = {};
    /**
     * ### .fail([message])
     * ### .fail(actual, expected, [message], [operator])
     *
     * Throw a failure.
     *
     *     should.fail();
     *     should.fail("custom error message");
     *     should.fail(1, 2);
     *     should.fail(1, 2, "custom error message");
     *     should.fail(1, 2, "custom error message", ">");
     *     should.fail(1, 2, undefined, ">");
     *
     *
     * @name fail
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @param {String} operator
     * @namespace BDD
     * @api public
     */

    should.fail = function (actual, expected, message, operator) {
      if (arguments.length < 2) {
        message = actual;
        actual = undefined;
      }

      message = message || 'should.fail()';
      throw new chai.AssertionError(message, {
        actual: actual,
        expected: expected,
        operator: operator
      }, should.fail);
    };
    /**
     * ### .equal(actual, expected, [message])
     *
     * Asserts non-strict equality (`==`) of `actual` and `expected`.
     *
     *     should.equal(3, '3', '== coerces values to strings');
     *
     * @name equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */


    should.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.equal(val2);
    };
    /**
     * ### .throw(function, [constructor/string/regexp], [string/regexp], [message])
     *
     * Asserts that `function` will throw an error that is an instance of
     * `constructor`, or alternately that it will throw an error with message
     * matching `regexp`.
     *
     *     should.throw(fn, 'function throws a reference error');
     *     should.throw(fn, /function throws a reference error/);
     *     should.throw(fn, ReferenceError);
     *     should.throw(fn, ReferenceError, 'function throws a reference error');
     *     should.throw(fn, ReferenceError, /function throws a reference error/);
     *
     * @name throw
     * @alias Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */


    should.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.Throw(errt, errs);
    };
    /**
     * ### .exist
     *
     * Asserts that the target is neither `null` nor `undefined`.
     *
     *     var foo = 'hi';
     *
     *     should.exist(foo, 'foo exists');
     *
     * @name exist
     * @namespace Should
     * @api public
     */


    should.exist = function (val, msg) {
      new Assertion(val, msg).to.exist;
    }; // negation


    should.not = {};
    /**
     * ### .not.equal(actual, expected, [message])
     *
     * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
     *
     *     should.not.equal(3, 4, 'these numbers are not equal');
     *
     * @name not.equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */

    should.not.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.not.equal(val2);
    };
    /**
     * ### .throw(function, [constructor/regexp], [message])
     *
     * Asserts that `function` will _not_ throw an error that is an instance of
     * `constructor`, or alternately that it will not throw an error with message
     * matching `regexp`.
     *
     *     should.not.throw(fn, Error, 'function does not throw');
     *
     * @name not.throw
     * @alias not.Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */


    should.not.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.not.Throw(errt, errs);
    };
    /**
     * ### .not.exist
     *
     * Asserts that the target is neither `null` nor `undefined`.
     *
     *     var bar = null;
     *
     *     should.not.exist(bar, 'bar does not exist');
     *
     * @name not.exist
     * @namespace Should
     * @api public
     */


    should.not.exist = function (val, msg) {
      new Assertion(val, msg).to.not.exist;
    };

    should['throw'] = should['Throw'];
    should.not['throw'] = should.not['Throw'];
    return should;
  }

  ;
  chai.should = loadShould;
  chai.Should = loadShould;
};
},{}],"../node_modules/chai/lib/chai/interface/assert.js":[function(require,module,exports) {
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
module.exports = function (chai, util) {
  /*!
   * Chai dependencies.
   */
  var Assertion = chai.Assertion,
      flag = util.flag;
  /*!
   * Module export.
   */

  /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert('foo' !== 'bar', 'foo is not bar');
   *     assert(Array.isArray([]), 'empty arrays are arrays');
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @namespace Assert
   * @api public
   */

  var assert = chai.assert = function (express, errmsg) {
    var test = new Assertion(null, null, chai.assert, true);
    test.assert(express, errmsg, '[ negation message unavailable ]');
  };
  /**
   * ### .fail([message])
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js `assert` module-compatible.
   *
   *     assert.fail();
   *     assert.fail("custom error message");
   *     assert.fail(1, 2);
   *     assert.fail(1, 2, "custom error message");
   *     assert.fail(1, 2, "custom error message", ">");
   *     assert.fail(1, 2, undefined, ">");
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace Assert
   * @api public
   */


  assert.fail = function (actual, expected, message, operator) {
    if (arguments.length < 2) {
      // Comply with Node's fail([message]) interface
      message = actual;
      actual = undefined;
    }

    message = message || 'assert.fail()';
    throw new chai.AssertionError(message, {
      actual: actual,
      expected: expected,
      operator: operator
    }, assert.fail);
  };
  /**
   * ### .isOk(object, [message])
   *
   * Asserts that `object` is truthy.
   *
   *     assert.isOk('everything', 'everything is ok');
   *     assert.isOk(false, 'this will fail');
   *
   * @name isOk
   * @alias ok
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isOk = function (val, msg) {
    new Assertion(val, msg, assert.isOk, true).is.ok;
  };
  /**
   * ### .isNotOk(object, [message])
   *
   * Asserts that `object` is falsy.
   *
   *     assert.isNotOk('everything', 'this will fail');
   *     assert.isNotOk(false, 'this will pass');
   *
   * @name isNotOk
   * @alias notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotOk = function (val, msg) {
    new Assertion(val, msg, assert.isNotOk, true).is.not.ok;
  };
  /**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (`==`) of `actual` and `expected`.
   *
   *     assert.equal(3, '3', '== coerces values to strings');
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.equal = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.equal, true);
    test.assert(exp == flag(test, 'object'), 'expected #{this} to equal #{exp}', 'expected #{this} to not equal #{act}', exp, act, true);
  };
  /**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
   *
   *     assert.notEqual(3, 4, 'these numbers are not equal');
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notEqual = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.notEqual, true);
    test.assert(exp != flag(test, 'object'), 'expected #{this} to not equal #{exp}', 'expected #{this} to equal #{act}', exp, act, true);
  };
  /**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (`===`) of `actual` and `expected`.
   *
   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.strictEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.strictEqual, true).to.equal(exp);
  };
  /**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (`!==`) of `actual` and `expected`.
   *
   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.notStrictEqual, true).to.not.equal(exp);
  };
  /**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that `actual` is deeply equal to `expected`.
   *
   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @alias deepStrictEqual
   * @namespace Assert
   * @api public
   */


  assert.deepEqual = assert.deepStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.deepEqual, true).to.eql(exp);
  };
  /**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that `actual` is not deeply equal to `expected`.
   *
   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.notDeepEqual, true).to.not.eql(exp);
  };
  /**
  * ### .isAbove(valueToCheck, valueToBeAbove, [message])
  *
  * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`.
  *
  *     assert.isAbove(5, 2, '5 is strictly greater than 2');
  *
  * @name isAbove
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeAbove
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isAbove = function (val, abv, msg) {
    new Assertion(val, msg, assert.isAbove, true).to.be.above(abv);
  };
  /**
  * ### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])
  *
  * Asserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`.
  *
  *     assert.isAtLeast(5, 2, '5 is greater or equal to 2');
  *     assert.isAtLeast(3, 3, '3 is greater or equal to 3');
  *
  * @name isAtLeast
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeAtLeast
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isAtLeast = function (val, atlst, msg) {
    new Assertion(val, msg, assert.isAtLeast, true).to.be.least(atlst);
  };
  /**
  * ### .isBelow(valueToCheck, valueToBeBelow, [message])
  *
  * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`.
  *
  *     assert.isBelow(3, 6, '3 is strictly less than 6');
  *
  * @name isBelow
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeBelow
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isBelow = function (val, blw, msg) {
    new Assertion(val, msg, assert.isBelow, true).to.be.below(blw);
  };
  /**
  * ### .isAtMost(valueToCheck, valueToBeAtMost, [message])
  *
  * Asserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`.
  *
  *     assert.isAtMost(3, 6, '3 is less than or equal to 6');
  *     assert.isAtMost(4, 4, '4 is less than or equal to 4');
  *
  * @name isAtMost
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeAtMost
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isAtMost = function (val, atmst, msg) {
    new Assertion(val, msg, assert.isAtMost, true).to.be.most(atmst);
  };
  /**
   * ### .isTrue(value, [message])
   *
   * Asserts that `value` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, 'the tea has been served');
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isTrue = function (val, msg) {
    new Assertion(val, msg, assert.isTrue, true).is['true'];
  };
  /**
   * ### .isNotTrue(value, [message])
   *
   * Asserts that `value` is not true.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotTrue(tea, 'great, time for tea!');
   *
   * @name isNotTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotTrue = function (val, msg) {
    new Assertion(val, msg, assert.isNotTrue, true).to.not.equal(true);
  };
  /**
   * ### .isFalse(value, [message])
   *
   * Asserts that `value` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isFalse = function (val, msg) {
    new Assertion(val, msg, assert.isFalse, true).is['false'];
  };
  /**
   * ### .isNotFalse(value, [message])
   *
   * Asserts that `value` is not false.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotFalse(tea, 'great, time for tea!');
   *
   * @name isNotFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotFalse = function (val, msg) {
    new Assertion(val, msg, assert.isNotFalse, true).to.not.equal(false);
  };
  /**
   * ### .isNull(value, [message])
   *
   * Asserts that `value` is null.
   *
   *     assert.isNull(err, 'there was no error');
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNull = function (val, msg) {
    new Assertion(val, msg, assert.isNull, true).to.equal(null);
  };
  /**
   * ### .isNotNull(value, [message])
   *
   * Asserts that `value` is not null.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotNull(tea, 'great, time for tea!');
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotNull = function (val, msg) {
    new Assertion(val, msg, assert.isNotNull, true).to.not.equal(null);
  };
  /**
   * ### .isNaN
   *
   * Asserts that value is NaN.
   *
   *     assert.isNaN(NaN, 'NaN is NaN');
   *
   * @name isNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNaN = function (val, msg) {
    new Assertion(val, msg, assert.isNaN, true).to.be.NaN;
  };
  /**
   * ### .isNotNaN
   *
   * Asserts that value is not NaN.
   *
   *     assert.isNotNaN(4, '4 is not NaN');
   *
   * @name isNotNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotNaN = function (val, msg) {
    new Assertion(val, msg, assert.isNotNaN, true).not.to.be.NaN;
  };
  /**
   * ### .exists
   *
   * Asserts that the target is neither `null` nor `undefined`.
   *
   *     var foo = 'hi';
   *
   *     assert.exists(foo, 'foo is neither `null` nor `undefined`');
   *
   * @name exists
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.exists = function (val, msg) {
    new Assertion(val, msg, assert.exists, true).to.exist;
  };
  /**
   * ### .notExists
   *
   * Asserts that the target is either `null` or `undefined`.
   *
   *     var bar = null
   *       , baz;
   *
   *     assert.notExists(bar);
   *     assert.notExists(baz, 'baz is either null or undefined');
   *
   * @name notExists
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notExists = function (val, msg) {
    new Assertion(val, msg, assert.notExists, true).to.not.exist;
  };
  /**
   * ### .isUndefined(value, [message])
   *
   * Asserts that `value` is `undefined`.
   *
   *     var tea;
   *     assert.isUndefined(tea, 'no tea defined');
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isUndefined = function (val, msg) {
    new Assertion(val, msg, assert.isUndefined, true).to.equal(undefined);
  };
  /**
   * ### .isDefined(value, [message])
   *
   * Asserts that `value` is not `undefined`.
   *
   *     var tea = 'cup of chai';
   *     assert.isDefined(tea, 'tea has been defined');
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isDefined = function (val, msg) {
    new Assertion(val, msg, assert.isDefined, true).to.not.equal(undefined);
  };
  /**
   * ### .isFunction(value, [message])
   *
   * Asserts that `value` is a function.
   *
   *     function serveTea() { return 'cup of tea'; };
   *     assert.isFunction(serveTea, 'great, we can have tea now');
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isFunction = function (val, msg) {
    new Assertion(val, msg, assert.isFunction, true).to.be.a('function');
  };
  /**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that `value` is _not_ a function.
   *
   *     var serveTea = [ 'heat', 'pour', 'sip' ];
   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotFunction = function (val, msg) {
    new Assertion(val, msg, assert.isNotFunction, true).to.not.be.a('function');
  };
  /**
   * ### .isObject(value, [message])
   *
   * Asserts that `value` is an object of type 'Object' (as revealed by `Object.prototype.toString`).
   * _The assertion does not match subclassed objects._
   *
   *     var selection = { name: 'Chai', serve: 'with spices' };
   *     assert.isObject(selection, 'tea selection is an object');
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isObject = function (val, msg) {
    new Assertion(val, msg, assert.isObject, true).to.be.a('object');
  };
  /**
   * ### .isNotObject(value, [message])
   *
   * Asserts that `value` is _not_ an object of type 'Object' (as revealed by `Object.prototype.toString`).
   *
   *     var selection = 'chai'
   *     assert.isNotObject(selection, 'tea selection is not an object');
   *     assert.isNotObject(null, 'null is not an object');
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotObject = function (val, msg) {
    new Assertion(val, msg, assert.isNotObject, true).to.not.be.a('object');
  };
  /**
   * ### .isArray(value, [message])
   *
   * Asserts that `value` is an array.
   *
   *     var menu = [ 'green', 'chai', 'oolong' ];
   *     assert.isArray(menu, 'what kind of tea do we want?');
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isArray = function (val, msg) {
    new Assertion(val, msg, assert.isArray, true).to.be.an('array');
  };
  /**
   * ### .isNotArray(value, [message])
   *
   * Asserts that `value` is _not_ an array.
   *
   *     var menu = 'green|chai|oolong';
   *     assert.isNotArray(menu, 'what kind of tea do we want?');
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotArray = function (val, msg) {
    new Assertion(val, msg, assert.isNotArray, true).to.not.be.an('array');
  };
  /**
   * ### .isString(value, [message])
   *
   * Asserts that `value` is a string.
   *
   *     var teaOrder = 'chai';
   *     assert.isString(teaOrder, 'order placed');
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isString = function (val, msg) {
    new Assertion(val, msg, assert.isString, true).to.be.a('string');
  };
  /**
   * ### .isNotString(value, [message])
   *
   * Asserts that `value` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, 'order placed');
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotString = function (val, msg) {
    new Assertion(val, msg, assert.isNotString, true).to.not.be.a('string');
  };
  /**
   * ### .isNumber(value, [message])
   *
   * Asserts that `value` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, 'how many cups');
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNumber = function (val, msg) {
    new Assertion(val, msg, assert.isNumber, true).to.be.a('number');
  };
  /**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that `value` is _not_ a number.
   *
   *     var cups = '2 cups please';
   *     assert.isNotNumber(cups, 'how many cups');
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotNumber = function (val, msg) {
    new Assertion(val, msg, assert.isNotNumber, true).to.not.be.a('number');
  };
  /**
  * ### .isFinite(value, [message])
  *
  * Asserts that `value` is a finite number. Unlike `.isNumber`, this will fail for `NaN` and `Infinity`.
  *
  *     var cups = 2;
  *     assert.isFinite(cups, 'how many cups');
  *
  *     assert.isFinite(NaN); // throws
  *
  * @name isFinite
  * @param {Number} value
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isFinite = function (val, msg) {
    new Assertion(val, msg, assert.isFinite, true).to.be.finite;
  };
  /**
   * ### .isBoolean(value, [message])
   *
   * Asserts that `value` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, 'is the tea ready');
   *     assert.isBoolean(teaServed, 'has tea been served');
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isBoolean = function (val, msg) {
    new Assertion(val, msg, assert.isBoolean, true).to.be.a('boolean');
  };
  /**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that `value` is _not_ a boolean.
   *
   *     var teaReady = 'yep'
   *       , teaServed = 'nope';
   *
   *     assert.isNotBoolean(teaReady, 'is the tea ready');
   *     assert.isNotBoolean(teaServed, 'has tea been served');
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotBoolean = function (val, msg) {
    new Assertion(val, msg, assert.isNotBoolean, true).to.not.be.a('boolean');
  };
  /**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that `value`'s type is `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
   *     assert.typeOf('tea', 'string', 'we have a string');
   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
   *     assert.typeOf(null, 'null', 'we have a null');
   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.typeOf = function (val, type, msg) {
    new Assertion(val, msg, assert.typeOf, true).to.be.a(type);
  };
  /**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that `value`'s type is _not_ `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notTypeOf = function (val, type, msg) {
    new Assertion(val, msg, assert.notTypeOf, true).to.not.be.a(type);
  };
  /**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that `value` is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea('chai');
   *
   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.instanceOf = function (val, type, msg) {
    new Assertion(val, msg, assert.instanceOf, true).to.be.instanceOf(type);
  };
  /**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts `value` is not an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String('chai');
   *
   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notInstanceOf = function (val, type, msg) {
    new Assertion(val, msg, assert.notInstanceOf, true).to.not.be.instanceOf(type);
  };
  /**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Can be used to assert the
   * inclusion of a value in an array, a substring in a string, or a subset of
   * properties in an object.
   *
   *     assert.include([1,2,3], 2, 'array contains value');
   *     assert.include('foobar', 'foo', 'string contains substring');
   *     assert.include({ foo: 'bar', hello: 'universe' }, { foo: 'bar' }, 'object contains property');
   *
   * Strict equality (===) is used. When asserting the inclusion of a value in
   * an array, the array is searched for an element that's strictly equal to the
   * given value. When asserting a subset of properties in an object, the object
   * is searched for the given property keys, checking that each one is present
   * and strictly equal to the given property value. For instance:
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.include([obj1, obj2], obj1);
   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1});
   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1, bar: obj2});
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.include = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.include, true).include(inc);
  };
  /**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Can be used to assert
   * the absence of a value in an array, a substring in a string, or a subset of
   * properties in an object.
   *
   *     assert.notInclude([1,2,3], 4, "array doesn't contain value");
   *     assert.notInclude('foobar', 'baz', "string doesn't contain substring");
   *     assert.notInclude({ foo: 'bar', hello: 'universe' }, { foo: 'baz' }, 'object doesn't contain property');
   *
   * Strict equality (===) is used. When asserting the absence of a value in an
   * array, the array is searched to confirm the absence of an element that's
   * strictly equal to the given value. When asserting a subset of properties in
   * an object, the object is searched to confirm that at least one of the given
   * property keys is either not present or not strictly equal to the given
   * property value. For instance:
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.notInclude([obj1, obj2], {a: 1});
   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: obj1, bar: {b: 2}});
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notInclude, true).not.include(inc);
  };
  /**
   * ### .deepInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Can be used to assert the
   * inclusion of a value in an array or a subset of properties in an object.
   * Deep equality is used.
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.deepInclude([obj1, obj2], {a: 1});
   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 2}});
   *
   * @name deepInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.deepInclude, true).deep.include(inc);
  };
  /**
   * ### .notDeepInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Can be used to assert
   * the absence of a value in an array or a subset of properties in an object.
   * Deep equality is used.
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.notDeepInclude([obj1, obj2], {a: 9});
   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 9}});
   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 9}});
   *
   * @name notDeepInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notDeepInclude, true).not.deep.include(inc);
  };
  /**
   * ### .nestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.nestedInclude({'.a': {'b': 'x'}}, {'\\.a.[b]': 'x'});
   *     assert.nestedInclude({'a': {'[b]': 'x'}}, {'a.\\[b\\]': 'x'});
   *
   * @name nestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.nestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.nestedInclude, true).nested.include(inc);
  };
  /**
   * ### .notNestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' does not include 'needle'.
   * Can be used to assert the absence of a subset of properties in an
   * object.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.notNestedInclude({'.a': {'b': 'x'}}, {'\\.a.b': 'y'});
   *     assert.notNestedInclude({'a': {'[b]': 'x'}}, {'a.\\[b\\]': 'y'});
   *
   * @name notNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notNestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notNestedInclude, true).not.nested.include(inc);
  };
  /**
   * ### .deepNestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object while checking for deep equality.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.deepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {x: 1}});
   *     assert.deepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\.a.\\[b\\]': {x: 1}});
   *
   * @name deepNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepNestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.deepNestedInclude, true).deep.nested.include(inc);
  };
  /**
   * ### .notDeepNestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' does not include 'needle'.
   * Can be used to assert the absence of a subset of properties in an
   * object while checking for deep equality.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.notDeepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {y: 1}})
   *     assert.notDeepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\.a.\\[b\\]': {y: 2}});
   *
   * @name notDeepNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepNestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notDeepNestedInclude, true).not.deep.nested.include(inc);
  };
  /**
   * ### .ownInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object while ignoring inherited properties.
   *
   *     assert.ownInclude({ a: 1 }, { a: 1 });
   *
   * @name ownInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.ownInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.ownInclude, true).own.include(inc);
  };
  /**
   * ### .notOwnInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the absence of a subset of properties in an
   * object while ignoring inherited properties.
   *
   *     Object.prototype.b = 2;
   *
   *     assert.notOwnInclude({ a: 1 }, { b: 2 });
   *
   * @name notOwnInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notOwnInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notOwnInclude, true).not.own.include(inc);
  };
  /**
   * ### .deepOwnInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object while ignoring inherited properties and checking for deep equality.
   *
   *      assert.deepOwnInclude({a: {b: 2}}, {a: {b: 2}});
   *
   * @name deepOwnInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepOwnInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.deepOwnInclude, true).deep.own.include(inc);
  };
  /**
  * ### .notDeepOwnInclude(haystack, needle, [message])
  *
  * Asserts that 'haystack' includes 'needle'.
  * Can be used to assert the absence of a subset of properties in an
  * object while ignoring inherited properties and checking for deep equality.
  *
  *      assert.notDeepOwnInclude({a: {b: 2}}, {a: {c: 3}});
  *
  * @name notDeepOwnInclude
  * @param {Object} haystack
  * @param {Object} needle
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.notDeepOwnInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notDeepOwnInclude, true).not.deep.own.include(inc);
  };
  /**
   * ### .match(value, regexp, [message])
   *
   * Asserts that `value` matches the regular expression `regexp`.
   *
   *     assert.match('foobar', /^foo/, 'regexp matches');
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.match = function (exp, re, msg) {
    new Assertion(exp, msg, assert.match, true).to.match(re);
  };
  /**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that `value` does not match the regular expression `regexp`.
   *
   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notMatch = function (exp, re, msg) {
    new Assertion(exp, msg, assert.notMatch, true).to.not.match(re);
  };
  /**
   * ### .property(object, property, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property`.
   *
   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
   *     assert.property({ tea: { green: 'matcha' }}, 'toString');
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.property = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.property, true).to.have.property(prop);
  };
  /**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a direct or inherited property named
   * by `property`.
   *
   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.notProperty, true).to.not.have.property(prop);
  };
  /**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property` with a value given by `value`. Uses a strict equality check
   * (===).
   *
   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.propertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.propertyVal, true).to.have.property(prop, val);
  };
  /**
   * ### .notPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct or inherited property named
   * by `property` with value given by `value`. Uses a strict equality check
   * (===).
   *
   *     assert.notPropertyVal({ tea: 'is good' }, 'tea', 'is bad');
   *     assert.notPropertyVal({ tea: 'is good' }, 'coffee', 'is good');
   *
   * @name notPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notPropertyVal, true).to.not.have.property(prop, val);
  };
  /**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property` with a value given by `value`. Uses a deep equality check.
   *
   *     assert.deepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.deepPropertyVal, true).to.have.deep.property(prop, val);
  };
  /**
   * ### .notDeepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct or inherited property named
   * by `property` with value given by `value`. Uses a deep equality check.
   *
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
   *
   * @name notDeepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notDeepPropertyVal, true).to.not.have.deep.property(prop, val);
  };
  /**
   * ### .ownProperty(object, property, [message])
   *
   * Asserts that `object` has a direct property named by `property`. Inherited
   * properties aren't checked.
   *
   *     assert.ownProperty({ tea: { green: 'matcha' }}, 'tea');
   *
   * @name ownProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */


  assert.ownProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.ownProperty, true).to.have.own.property(prop);
  };
  /**
   * ### .notOwnProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a direct property named by
   * `property`. Inherited properties aren't checked.
   *
   *     assert.notOwnProperty({ tea: { green: 'matcha' }}, 'coffee');
   *     assert.notOwnProperty({}, 'toString');
   *
   * @name notOwnProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */


  assert.notOwnProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.notOwnProperty, true).to.not.have.own.property(prop);
  };
  /**
   * ### .ownPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct property named by `property` and a value
   * equal to the provided `value`. Uses a strict equality check (===).
   * Inherited properties aren't checked.
   *
   *     assert.ownPropertyVal({ coffee: 'is good'}, 'coffee', 'is good');
   *
   * @name ownPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */


  assert.ownPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.ownPropertyVal, true).to.have.own.property(prop, value);
  };
  /**
   * ### .notOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct property named by `property`
   * with a value equal to the provided `value`. Uses a strict equality check
   * (===). Inherited properties aren't checked.
   *
   *     assert.notOwnPropertyVal({ tea: 'is better'}, 'tea', 'is worse');
   *     assert.notOwnPropertyVal({}, 'toString', Object.prototype.toString);
   *
   * @name notOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */


  assert.notOwnPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.notOwnPropertyVal, true).to.not.have.own.property(prop, value);
  };
  /**
   * ### .deepOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct property named by `property` and a value
   * equal to the provided `value`. Uses a deep equality check. Inherited
   * properties aren't checked.
   *
   *     assert.deepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
   *
   * @name deepOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */


  assert.deepOwnPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.deepOwnPropertyVal, true).to.have.deep.own.property(prop, value);
  };
  /**
   * ### .notDeepOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct property named by `property`
   * with a value equal to the provided `value`. Uses a deep equality check.
   * Inherited properties aren't checked.
   *
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
   *     assert.notDeepOwnPropertyVal({}, 'toString', Object.prototype.toString);
   *
   * @name notDeepOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */


  assert.notDeepOwnPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.notDeepOwnPropertyVal, true).to.not.have.deep.own.property(prop, value);
  };
  /**
   * ### .nestedProperty(object, property, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property`, which can be a string using dot- and bracket-notation for
   * nested reference.
   *
   *     assert.nestedProperty({ tea: { green: 'matcha' }}, 'tea.green');
   *
   * @name nestedProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.nestedProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.nestedProperty, true).to.have.nested.property(prop);
  };
  /**
   * ### .notNestedProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`, which
   * can be a string using dot- and bracket-notation for nested reference. The
   * property cannot exist on the object nor anywhere in its prototype chain.
   *
   *     assert.notNestedProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
   *
   * @name notNestedProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notNestedProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.notNestedProperty, true).to.not.have.nested.property(prop);
  };
  /**
   * ### .nestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`. `property` can use dot- and bracket-notation for nested
   * reference. Uses a strict equality check (===).
   *
   *     assert.nestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
   *
   * @name nestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.nestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.nestedPropertyVal, true).to.have.nested.property(prop, val);
  };
  /**
   * ### .notNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property` with
   * value given by `value`. `property` can use dot- and bracket-notation for
   * nested reference. Uses a strict equality check (===).
   *
   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'coffee.green', 'matcha');
   *
   * @name notNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notNestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notNestedPropertyVal, true).to.not.have.nested.property(prop, val);
  };
  /**
   * ### .deepNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with a value given
   * by `value`. `property` can use dot- and bracket-notation for nested
   * reference. Uses a deep equality check.
   *
   *     assert.deepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yum' });
   *
   * @name deepNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepNestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.deepNestedPropertyVal, true).to.have.deep.nested.property(prop, val);
  };
  /**
   * ### .notDeepNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property` with
   * value given by `value`. `property` can use dot- and bracket-notation for
   * nested reference. Uses a deep equality check.
   *
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { oolong: 'yum' });
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yuck' });
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.black', { matcha: 'yum' });
   *
   * @name notDeepNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepNestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notDeepNestedPropertyVal, true).to.not.have.deep.nested.property(prop, val);
  };
  /**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that `object` has a `length` or `size` with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
   *     assert.lengthOf('foobar', 6, 'string has length of 6');
   *     assert.lengthOf(new Set([1,2,3]), 3, 'set has size of 3');
   *     assert.lengthOf(new Map([['a',1],['b',2],['c',3]]), 3, 'map has size of 3');
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.lengthOf = function (exp, len, msg) {
    new Assertion(exp, msg, assert.lengthOf, true).to.have.lengthOf(len);
  };
  /**
   * ### .hasAnyKeys(object, [keys], [message])
   *
   * Asserts that `object` has at least one of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'iDontExist', 'baz']);
   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, iDontExist: 99, baz: 1337});
   *     assert.hasAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.hasAnyKeys(new Set([{foo: 'bar'}, 'anotherKey']), [{foo: 'bar'}, 'anotherKey']);
   *
   * @name hasAnyKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.hasAnyKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAnyKeys, true).to.have.any.keys(keys);
  };
  /**
   * ### .hasAllKeys(object, [keys], [message])
   *
   * Asserts that `object` has all and only all of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337]);
   *     assert.hasAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.hasAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
   *
   * @name hasAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.hasAllKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAllKeys, true).to.have.all.keys(keys);
  };
  /**
   * ### .containsAllKeys(object, [keys], [message])
   *
   * Asserts that `object` has all of the `keys` provided but may have more keys not listed.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'baz']);
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, baz: 1337});
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337});
   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}]);
   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}]);
   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
   *
   * @name containsAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.containsAllKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.containsAllKeys, true).to.contain.all.keys(keys);
  };
  /**
   * ### .doesNotHaveAnyKeys(object, [keys], [message])
   *
   * Asserts that `object` has none of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
   *     assert.doesNotHaveAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
   *     assert.doesNotHaveAnyKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
   *
   * @name doesNotHaveAnyKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.doesNotHaveAnyKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAnyKeys, true).to.not.have.any.keys(keys);
  };
  /**
   * ### .doesNotHaveAllKeys(object, [keys], [message])
   *
   * Asserts that `object` does not have at least one of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
   *     assert.doesNotHaveAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
   *     assert.doesNotHaveAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
   *
   * @name doesNotHaveAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.doesNotHaveAllKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAllKeys, true).to.not.have.all.keys(keys);
  };
  /**
   * ### .hasAnyDeepKeys(object, [keys], [message])
   *
   * Asserts that `object` has at least one of the `keys` provided.
   * Since Sets and Maps can have objects as keys you can use this assertion to perform
   * a deep comparison.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), [{one: 'one'}, {two: 'two'}]);
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {three: 'three'}]);
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
   *
   * @name doesNotHaveAllKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.hasAnyDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAnyDeepKeys, true).to.have.any.deep.keys(keys);
  };
  /**
    * ### .hasAllDeepKeys(object, [keys], [message])
    *
    * Asserts that `object` has all and only all of the `keys` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a `keys` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne']]), {one: 'one'});
    *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
    *     assert.hasAllDeepKeys(new Set([{one: 'one'}]), {one: 'one'});
    *     assert.hasAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
    *
    * @name hasAllDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */


  assert.hasAllDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAllDeepKeys, true).to.have.all.deep.keys(keys);
  };
  /**
    * ### .containsAllDeepKeys(object, [keys], [message])
    *
    * Asserts that `object` contains all of the `keys` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a `keys` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
    *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
    *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
    *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
    *
    * @name containsAllDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */


  assert.containsAllDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.containsAllDeepKeys, true).to.contain.all.deep.keys(keys);
  };
  /**
    * ### .doesNotHaveAnyDeepKeys(object, [keys], [message])
    *
    * Asserts that `object` has none of the `keys` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a `keys` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
    *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
    *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
    *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
    *
    * @name doesNotHaveAnyDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */


  assert.doesNotHaveAnyDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAnyDeepKeys, true).to.not.have.any.deep.keys(keys);
  };
  /**
    * ### .doesNotHaveAllDeepKeys(object, [keys], [message])
    *
    * Asserts that `object` does not have at least one of the `keys` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a `keys` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
    *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {one: 'one'}]);
    *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
    *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {fifty: 'fifty'}]);
    *
    * @name doesNotHaveAllDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */


  assert.doesNotHaveAllDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAllDeepKeys, true).to.not.have.all.deep.keys(keys);
  };
  /**
    * ### .throws(fn, [errorLike/string/regexp], [string/regexp], [message])
    *
    * If `errorLike` is an `Error` constructor, asserts that `fn` will throw an error that is an
    * instance of `errorLike`.
    * If `errorLike` is an `Error` instance, asserts that the error thrown is the same
    * instance as `errorLike`.
    * If `errMsgMatcher` is provided, it also asserts that the error thrown will have a
    * message matching `errMsgMatcher`.
    *
    *     assert.throws(fn, 'Error thrown must have this msg');
    *     assert.throws(fn, /Error thrown must have a msg that matches this/);
    *     assert.throws(fn, ReferenceError);
    *     assert.throws(fn, errorInstance);
    *     assert.throws(fn, ReferenceError, 'Error thrown must be a ReferenceError and have this msg');
    *     assert.throws(fn, errorInstance, 'Error thrown must be the same errorInstance and have this msg');
    *     assert.throws(fn, ReferenceError, /Error thrown must be a ReferenceError and match this/);
    *     assert.throws(fn, errorInstance, /Error thrown must be the same errorInstance and match this/);
    *
    * @name throws
    * @alias throw
    * @alias Throw
    * @param {Function} fn
    * @param {ErrorConstructor|Error} errorLike
    * @param {RegExp|String} errMsgMatcher
    * @param {String} message
    * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
    * @namespace Assert
    * @api public
    */


  assert.throws = function (fn, errorLike, errMsgMatcher, msg) {
    if ('string' === typeof errorLike || errorLike instanceof RegExp) {
      errMsgMatcher = errorLike;
      errorLike = null;
    }

    var assertErr = new Assertion(fn, msg, assert.throws, true).to.throw(errorLike, errMsgMatcher);
    return flag(assertErr, 'object');
  };
  /**
   * ### .doesNotThrow(fn, [errorLike/string/regexp], [string/regexp], [message])
   *
   * If `errorLike` is an `Error` constructor, asserts that `fn` will _not_ throw an error that is an
   * instance of `errorLike`.
   * If `errorLike` is an `Error` instance, asserts that the error thrown is _not_ the same
   * instance as `errorLike`.
   * If `errMsgMatcher` is provided, it also asserts that the error thrown will _not_ have a
   * message matching `errMsgMatcher`.
   *
   *     assert.doesNotThrow(fn, 'Any Error thrown must not have this message');
   *     assert.doesNotThrow(fn, /Any Error thrown must not match this/);
   *     assert.doesNotThrow(fn, Error);
   *     assert.doesNotThrow(fn, errorInstance);
   *     assert.doesNotThrow(fn, Error, 'Error must not have this message');
   *     assert.doesNotThrow(fn, errorInstance, 'Error must not have this message');
   *     assert.doesNotThrow(fn, Error, /Error must not match this/);
   *     assert.doesNotThrow(fn, errorInstance, /Error must not match this/);
   *
   * @name doesNotThrow
   * @param {Function} fn
   * @param {ErrorConstructor} errorLike
   * @param {RegExp|String} errMsgMatcher
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @namespace Assert
   * @api public
   */


  assert.doesNotThrow = function (fn, errorLike, errMsgMatcher, msg) {
    if ('string' === typeof errorLike || errorLike instanceof RegExp) {
      errMsgMatcher = errorLike;
      errorLike = null;
    }

    new Assertion(fn, msg, assert.doesNotThrow, true).to.not.throw(errorLike, errMsgMatcher);
  };
  /**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using `operator`.
   *
   *     assert.operator(1, '<', 2, 'everything is ok');
   *     assert.operator(1, '>', 2, 'this will fail');
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.operator = function (val, operator, val2, msg) {
    var ok;

    switch (operator) {
      case '==':
        ok = val == val2;
        break;

      case '===':
        ok = val === val2;
        break;

      case '>':
        ok = val > val2;
        break;

      case '>=':
        ok = val >= val2;
        break;

      case '<':
        ok = val < val2;
        break;

      case '<=':
        ok = val <= val2;
        break;

      case '!=':
        ok = val != val2;
        break;

      case '!==':
        ok = val !== val2;
        break;

      default:
        msg = msg ? msg + ': ' : msg;
        throw new chai.AssertionError(msg + 'Invalid operator "' + operator + '"', undefined, assert.operator);
    }

    var test = new Assertion(ok, msg, assert.operator, true);
    test.assert(true === flag(test, 'object'), 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2), 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2));
  };
  /**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.closeTo = function (act, exp, delta, msg) {
    new Assertion(act, msg, assert.closeTo, true).to.be.closeTo(exp, delta);
  };
  /**
   * ### .approximately(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.approximately(1.5, 1, 0.5, 'numbers are close');
   *
   * @name approximately
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.approximately = function (act, exp, delta, msg) {
    new Assertion(act, msg, assert.approximately, true).to.be.approximately(exp, delta);
  };
  /**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in any order. Uses a
   * strict equality check (===).
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
   *
   * @name sameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.sameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameMembers, true).to.have.same.members(set2);
  };
  /**
   * ### .notSameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in any order.
   * Uses a strict equality check (===).
   *
   *     assert.notSameMembers([ 1, 2, 3 ], [ 5, 1, 3 ], 'not same members');
   *
   * @name notSameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notSameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameMembers, true).to.not.have.same.members(set2);
  };
  /**
   * ### .sameDeepMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in any order. Uses a
   * deep equality check.
   *
   *     assert.sameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members');
   *
   * @name sameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.sameDeepMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameDeepMembers, true).to.have.same.deep.members(set2);
  };
  /**
   * ### .notSameDeepMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in any order.
   * Uses a deep equality check.
   *
   *     assert.notSameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { f: 5 }], 'not same deep members');
   *
   * @name notSameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notSameDeepMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameDeepMembers, true).to.not.have.same.deep.members(set2);
  };
  /**
   * ### .sameOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in the same order.
   * Uses a strict equality check (===).
   *
   *     assert.sameOrderedMembers([ 1, 2, 3 ], [ 1, 2, 3 ], 'same ordered members');
   *
   * @name sameOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.sameOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameOrderedMembers, true).to.have.same.ordered.members(set2);
  };
  /**
   * ### .notSameOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in the same
   * order. Uses a strict equality check (===).
   *
   *     assert.notSameOrderedMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'not same ordered members');
   *
   * @name notSameOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notSameOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameOrderedMembers, true).to.not.have.same.ordered.members(set2);
  };
  /**
   * ### .sameDeepOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in the same order.
   * Uses a deep equality check.
   *
   * assert.sameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { c: 3 } ], 'same deep ordered members');
   *
   * @name sameDeepOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.sameDeepOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameDeepOrderedMembers, true).to.have.same.deep.ordered.members(set2);
  };
  /**
   * ### .notSameDeepOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in the same
   * order. Uses a deep equality check.
   *
   * assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { z: 5 } ], 'not same deep ordered members');
   * assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { c: 3 } ], 'not same deep ordered members');
   *
   * @name notSameDeepOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notSameDeepOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameDeepOrderedMembers, true).to.not.have.same.deep.ordered.members(set2);
  };
  /**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in any order. Uses a
   * strict equality check (===). Duplicates are ignored.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1, 2 ], 'include members');
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.includeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeMembers, true).to.include.members(subset);
  };
  /**
   * ### .notIncludeMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in any order. Uses a
   * strict equality check (===). Duplicates are ignored.
   *
   *     assert.notIncludeMembers([ 1, 2, 3 ], [ 5, 1 ], 'not include members');
   *
   * @name notIncludeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notIncludeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeMembers, true).to.not.include.members(subset);
  };
  /**
   * ### .includeDeepMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in any order. Uses a deep
   * equality check. Duplicates are ignored.
   *
   *     assert.includeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { b: 2 } ], 'include deep members');
   *
   * @name includeDeepMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.includeDeepMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeDeepMembers, true).to.include.deep.members(subset);
  };
  /**
   * ### .notIncludeDeepMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in any order. Uses a
   * deep equality check. Duplicates are ignored.
   *
   *     assert.notIncludeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { f: 5 } ], 'not include deep members');
   *
   * @name notIncludeDeepMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notIncludeDeepMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeDeepMembers, true).to.not.include.deep.members(subset);
  };
  /**
   * ### .includeOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a strict equality
   * check (===).
   *
   *     assert.includeOrderedMembers([ 1, 2, 3 ], [ 1, 2 ], 'include ordered members');
   *
   * @name includeOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.includeOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeOrderedMembers, true).to.include.ordered.members(subset);
  };
  /**
   * ### .notIncludeOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a strict equality
   * check (===).
   *
   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 1 ], 'not include ordered members');
   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 3 ], 'not include ordered members');
   *
   * @name notIncludeOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notIncludeOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeOrderedMembers, true).to.not.include.ordered.members(subset);
  };
  /**
   * ### .includeDeepOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a deep equality
   * check.
   *
   *     assert.includeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 } ], 'include deep ordered members');
   *
   * @name includeDeepOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.includeDeepOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeDeepOrderedMembers, true).to.include.deep.ordered.members(subset);
  };
  /**
   * ### .notIncludeDeepOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a deep equality
   * check.
   *
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { f: 5 } ], 'not include deep ordered members');
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 } ], 'not include deep ordered members');
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { c: 3 } ], 'not include deep ordered members');
   *
   * @name notIncludeDeepOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notIncludeDeepOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeDeepOrderedMembers, true).to.not.include.deep.ordered.members(subset);
  };
  /**
   * ### .oneOf(inList, list, [message])
   *
   * Asserts that non-object, non-array value `inList` appears in the flat array `list`.
   *
   *     assert.oneOf(1, [ 2, 1 ], 'Not found in list');
   *
   * @name oneOf
   * @param {*} inList
   * @param {Array<*>} list
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.oneOf = function (inList, list, msg) {
    new Assertion(inList, msg, assert.oneOf, true).to.be.oneOf(list);
  };
  /**
   * ### .changes(function, object, property, [message])
   *
   * Asserts that a function changes the value of a property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 22 };
   *     assert.changes(fn, obj, 'val');
   *
   * @name changes
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.changes = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.changes, true).to.change(obj, prop);
  };
  /**
  * ### .changesBy(function, object, property, delta, [message])
  *
  * Asserts that a function changes the value of a property by an amount (delta).
  *
  *     var obj = { val: 10 };
  *     var fn = function() { obj.val += 2 };
  *     assert.changesBy(fn, obj, 'val', 2);
  *
  * @name changesBy
  * @param {Function} modifier function
  * @param {Object} object or getter function
  * @param {String} property name _optional_
  * @param {Number} change amount (delta)
  * @param {String} message _optional_
  * @namespace Assert
  * @api public
  */


  assert.changesBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.changesBy, true).to.change(obj, prop).by(delta);
  };
  /**
  * ### .doesNotChange(function, object, property, [message])
  *
  * Asserts that a function does not change the value of a property.
  *
  *     var obj = { val: 10 };
  *     var fn = function() { console.log('foo'); };
  *     assert.doesNotChange(fn, obj, 'val');
  *
  * @name doesNotChange
  * @param {Function} modifier function
  * @param {Object} object or getter function
  * @param {String} property name _optional_
  * @param {String} message _optional_
  * @namespace Assert
  * @api public
  */


  assert.doesNotChange = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotChange, true).to.not.change(obj, prop);
  };
  /**
   * ### .changesButNotBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not change the value of a property or of a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 10 };
   *     assert.changesButNotBy(fn, obj, 'val', 5);
   *
   * @name changesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.changesButNotBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.changesButNotBy, true).to.change(obj, prop).but.not.by(delta);
  };
  /**
   * ### .increases(function, object, property, [message])
   *
   * Asserts that a function increases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 13 };
   *     assert.increases(fn, obj, 'val');
   *
   * @name increases
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.increases = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.increases, true).to.increase(obj, prop);
  };
  /**
   * ### .increasesBy(function, object, property, delta, [message])
   *
   * Asserts that a function increases a numeric object property or a function's return value by an amount (delta).
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 10 };
   *     assert.increasesBy(fn, obj, 'val', 10);
   *
   * @name increasesBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.increasesBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.increasesBy, true).to.increase(obj, prop).by(delta);
  };
  /**
   * ### .doesNotIncrease(function, object, property, [message])
   *
   * Asserts that a function does not increase a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 8 };
   *     assert.doesNotIncrease(fn, obj, 'val');
   *
   * @name doesNotIncrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.doesNotIncrease = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotIncrease, true).to.not.increase(obj, prop);
  };
  /**
   * ### .increasesButNotBy(function, object, property, [message])
   *
   * Asserts that a function does not increase a numeric object property or function's return value by an amount (delta).
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.increasesButNotBy(fn, obj, 'val', 10);
   *
   * @name increasesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.increasesButNotBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.increasesButNotBy, true).to.increase(obj, prop).but.not.by(delta);
  };
  /**
   * ### .decreases(function, object, property, [message])
   *
   * Asserts that a function decreases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreases(fn, obj, 'val');
   *
   * @name decreases
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.decreases = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.decreases, true).to.decrease(obj, prop);
  };
  /**
   * ### .decreasesBy(function, object, property, delta, [message])
   *
   * Asserts that a function decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val -= 5 };
   *     assert.decreasesBy(fn, obj, 'val', 5);
   *
   * @name decreasesBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.decreasesBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.decreasesBy, true).to.decrease(obj, prop).by(delta);
  };
  /**
   * ### .doesNotDecrease(function, object, property, [message])
   *
   * Asserts that a function does not decreases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.doesNotDecrease(fn, obj, 'val');
   *
   * @name doesNotDecrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.doesNotDecrease = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotDecrease, true).to.not.decrease(obj, prop);
  };
  /**
   * ### .doesNotDecreaseBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.doesNotDecreaseBy(fn, obj, 'val', 1);
   *
   * @name doesNotDecrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.doesNotDecreaseBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotDecreaseBy, true).to.not.decrease(obj, prop).by(delta);
  };
  /**
   * ### .decreasesButNotBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreasesButNotBy(fn, obj, 'val', 1);
   *
   * @name decreasesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.decreasesButNotBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.decreasesButNotBy, true).to.decrease(obj, prop).but.not.by(delta);
  };
  /*!
   * ### .ifError(object)
   *
   * Asserts if value is not a false value, and throws if it is a true value.
   * This is added to allow for chai to be a drop-in replacement for Node's
   * assert class.
   *
   *     var err = new Error('I am a custom error');
   *     assert.ifError(err); // Rethrows err!
   *
   * @name ifError
   * @param {Object} object
   * @namespace Assert
   * @api public
   */


  assert.ifError = function (val) {
    if (val) {
      throw val;
    }
  };
  /**
   * ### .isExtensible(object)
   *
   * Asserts that `object` is extensible (can have new properties added to it).
   *
   *     assert.isExtensible({});
   *
   * @name isExtensible
   * @alias extensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isExtensible = function (obj, msg) {
    new Assertion(obj, msg, assert.isExtensible, true).to.be.extensible;
  };
  /**
   * ### .isNotExtensible(object)
   *
   * Asserts that `object` is _not_ extensible.
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     assert.isNotExtensible(nonExtensibleObject);
   *     assert.isNotExtensible(sealedObject);
   *     assert.isNotExtensible(frozenObject);
   *
   * @name isNotExtensible
   * @alias notExtensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isNotExtensible = function (obj, msg) {
    new Assertion(obj, msg, assert.isNotExtensible, true).to.not.be.extensible;
  };
  /**
   * ### .isSealed(object)
   *
   * Asserts that `object` is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.seal({});
   *
   *     assert.isSealed(sealedObject);
   *     assert.isSealed(frozenObject);
   *
   * @name isSealed
   * @alias sealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isSealed = function (obj, msg) {
    new Assertion(obj, msg, assert.isSealed, true).to.be.sealed;
  };
  /**
   * ### .isNotSealed(object)
   *
   * Asserts that `object` is _not_ sealed.
   *
   *     assert.isNotSealed({});
   *
   * @name isNotSealed
   * @alias notSealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isNotSealed = function (obj, msg) {
    new Assertion(obj, msg, assert.isNotSealed, true).to.not.be.sealed;
  };
  /**
   * ### .isFrozen(object)
   *
   * Asserts that `object` is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *     assert.frozen(frozenObject);
   *
   * @name isFrozen
   * @alias frozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isFrozen = function (obj, msg) {
    new Assertion(obj, msg, assert.isFrozen, true).to.be.frozen;
  };
  /**
   * ### .isNotFrozen(object)
   *
   * Asserts that `object` is _not_ frozen.
   *
   *     assert.isNotFrozen({});
   *
   * @name isNotFrozen
   * @alias notFrozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isNotFrozen = function (obj, msg) {
    new Assertion(obj, msg, assert.isNotFrozen, true).to.not.be.frozen;
  };
  /**
   * ### .isEmpty(target)
   *
   * Asserts that the target does not contain any values.
   * For arrays and strings, it checks the `length` property.
   * For `Map` and `Set` instances, it checks the `size` property.
   * For non-function objects, it gets the count of own
   * enumerable string keys.
   *
   *     assert.isEmpty([]);
   *     assert.isEmpty('');
   *     assert.isEmpty(new Map);
   *     assert.isEmpty({});
   *
   * @name isEmpty
   * @alias empty
   * @param {Object|Array|String|Map|Set} target
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isEmpty = function (val, msg) {
    new Assertion(val, msg, assert.isEmpty, true).to.be.empty;
  };
  /**
   * ### .isNotEmpty(target)
   *
   * Asserts that the target contains values.
   * For arrays and strings, it checks the `length` property.
   * For `Map` and `Set` instances, it checks the `size` property.
   * For non-function objects, it gets the count of own
   * enumerable string keys.
   *
   *     assert.isNotEmpty([1, 2]);
   *     assert.isNotEmpty('34');
   *     assert.isNotEmpty(new Set([5, 6]));
   *     assert.isNotEmpty({ key: 7 });
   *
   * @name isNotEmpty
   * @alias notEmpty
   * @param {Object|Array|String|Map|Set} target
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isNotEmpty = function (val, msg) {
    new Assertion(val, msg, assert.isNotEmpty, true).to.not.be.empty;
  };
  /*!
   * Aliases.
   */


  (function alias(name, as) {
    assert[as] = assert[name];
    return alias;
  })('isOk', 'ok')('isNotOk', 'notOk')('throws', 'throw')('throws', 'Throw')('isExtensible', 'extensible')('isNotExtensible', 'notExtensible')('isSealed', 'sealed')('isNotSealed', 'notSealed')('isFrozen', 'frozen')('isNotFrozen', 'notFrozen')('isEmpty', 'empty')('isNotEmpty', 'notEmpty');
};
},{}],"../node_modules/chai/lib/chai.js":[function(require,module,exports) {
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var used = [];
/*!
 * Chai version
 */

exports.version = '4.2.0';
/*!
 * Assertion Error
 */

exports.AssertionError = require('assertion-error');
/*!
 * Utils for plugins (not exported)
 */

var util = require('./chai/utils');
/**
 * # .use(function)
 *
 * Provides a way to extend the internals of Chai.
 *
 * @param {Function}
 * @returns {this} for chaining
 * @api public
 */


exports.use = function (fn) {
  if (!~used.indexOf(fn)) {
    fn(exports, util);
    used.push(fn);
  }

  return exports;
};
/*!
 * Utility Functions
 */


exports.util = util;
/*!
 * Configuration
 */

var config = require('./chai/config');

exports.config = config;
/*!
 * Primary `Assertion` prototype
 */

var assertion = require('./chai/assertion');

exports.use(assertion);
/*!
 * Core Assertions
 */

var core = require('./chai/core/assertions');

exports.use(core);
/*!
 * Expect interface
 */

var expect = require('./chai/interface/expect');

exports.use(expect);
/*!
 * Should interface
 */

var should = require('./chai/interface/should');

exports.use(should);
/*!
 * Assert interface
 */

var assert = require('./chai/interface/assert');

exports.use(assert);
},{"assertion-error":"../node_modules/assertion-error/index.js","./chai/utils":"../node_modules/chai/lib/chai/utils/index.js","./chai/config":"../node_modules/chai/lib/chai/config.js","./chai/assertion":"../node_modules/chai/lib/chai/assertion.js","./chai/core/assertions":"../node_modules/chai/lib/chai/core/assertions.js","./chai/interface/expect":"../node_modules/chai/lib/chai/interface/expect.js","./chai/interface/should":"../node_modules/chai/lib/chai/interface/should.js","./chai/interface/assert":"../node_modules/chai/lib/chai/interface/assert.js"}],"../node_modules/chai/index.js":[function(require,module,exports) {
module.exports = require('./lib/chai');
},{"./lib/chai":"../node_modules/chai/lib/chai.js"}],"../../test/fixtures.json":[function(require,module,exports) {
module.exports = {
  "hck0": {
    "correct": [["HcKciDds5OiogymxbnHKEabQ8iavqs8dwdVaGdJW76Vp4gx47tQDfGW4OWc9w5i", "0c71db50d35d760b0ea2002ff20147c7c3a8e8030d35ef28ed1adaec9e329aba"], ["HcKcJAYWKF7xpsddq6ojeqbIVCp837fpcNz77479pND7KzBmH7nUcV4u4sN3vpr", "82f5517b6744637f1a923c28a09decf4ae1331deebbf7307d5602b3f59315353"], ["HcKCjV6zmkIPz9w9zwFcFRxm8SGvxzv39sGNPGRIenp9yzryYDScjDvJraz3bbz", "d3985a90ec7ebfc54a22c2cbf44d4b6299fc4cc71a08231dfbe217b8e2248e89"], ["HcKCjjt9OTf7Fk3wc3qH3bHsEKkcwb7gzY8SudxIvWxedi4iThtj4jE9fn8cpvz", "a65f6c8bd2ab35165e7c84f122942a87a6c5fd198ec8a56c41a34891e49d249f"], ["HcKcIiYN3okO6gtc9egtaufqK68Nr9r59QG6SO9p6SvfejjtJw9bOq7FKsv7jjr", "22eccb54de1a42f90d204caf573cc87e1bfbcdc8b7eee4685225324d7e16bfa5"], ["HcKcjt5FWUa9qfvjwfRJVbq8rDbbjdiwtxgd3Xjoc57R6vo4WN9BWWMi3Mtmakr", "cb65acc1f79689a9609a05fe80c2148d15958c3cd92d16fb0e51baab3e1ad568"], ["HcKcIeYSAnBbjshvjb5qw7z5GT96d59yd8u3RzdtQITjfnwnfe7K4GvU563pvxr", "12f1030214c4f44876faf71b34bfc1eff71fa79860727a2492b2ac293aad1a93"], ["HcKCIy6WeyDFtcbqkeKY7Wrkoo53hoxx6xJxdq5y6kJww43rubIOzOiKsg8ec4i", "5f9525c659082f51157ed60a6b7793b6d6e59361bf77e2935aeb309850dc350a"]],
    "correctable": [["HcKciDds_OiogymxbnHKEabQ8iavqs8dwdVaGdJW76Vp4gx47tQDfGW4OWc9w5i", "0c71db50d35d760b0ea2002ff20147c7c3a8e8030d35ef28ed1adaec9e329aba", "HcKciDds5OiogymxbnHKEabQ8iavqs8dwdVaGdJW76Vp4gx47tQDfGW4OWc9w5i"], ["HcKciDds_Oiogymxb_HKEabQ8iavqs8dwdVaGdJW76Vp4gx47tQDfGW4OWc9w5i", "0c71db50d35d760b0ea2002ff20147c7c3a8e8030d35ef28ed1adaec9e329aba", "HcKciDds5OiogymxbnHKEabQ8iavqs8dwdVaGdJW76Vp4gx47tQDfGW4OWc9w5i"], ["HcKciDdsjOiogymxbnHKEabQ8iavqs8dwdVaGdJW76Vp4gx47tQDfGW4OWc9w5i", "0c71db50d35d760b0ea2002ff20147c7c3a8e8030d35ef28ed1adaec9e329aba", "HcKciDds5OiogymxbnHKEabQ8iavqs8dwdVaGdJW76Vp4gx47tQDfGW4OWc9w5i"], ["hckciy6weydftcbqkeky7wrkoo53hoxx6xjxdq5y6kjww43rubiozoiksg8ec4i", "5f9525c659082f51157ed60a6b7793b6d6e59361bf77e2935aeb309850dc350a", "HcKCIy6WeyDFtcbqkeKY7Wrkoo53hoxx6xJxdq5y6kJww43rubIOzOiKsg8ec4i"], ["HCKCIY6WEYDFTCBQKEKY7WRKOO53HOXX6XJXDQ5Y6KJWW43RUBIOZOIKSG8EC4I", "5f9525c659082f51157ed60a6b7793b6d6e59361bf77e2935aeb309850dc350a", "HcKCIy6WeyDFtcbqkeKY7Wrkoo53hoxx6xJxdq5y6kJww43rubIOzOiKsg8ec4i"]],
    "errantId": [["HcKciDds_Oiog_mxb_HKEabQ8iavqs8dwdVaGdJW76Vp4gx47tQDfGW4O_c9w5i", "HcidError(\"TooManyErrors\")"], ["HcKciDdsjjjjjjjjjnHKEabQ8iavqs8dwdVaGdJW76Vp4gx47tQDfGW4OWc9w5i", "HcidError(\"TooManyErrors\")"], ["HdKciDds5OiogymxbnHKEabQ8iavqs8dwdVaGdJW76Vp4gx47tQDfGW4OWc9w5i", "HcidError(\"PrefixMismatch\")"], ["HcKciDds5OiogymxbnHKEabQ8iavqs8dwdVaGdJW76Vp4gx47tQDfGW4OWc9w5id", "HcidError(\"BadIdLen:64,Expected:63\")"], ["HCKCI_6WEYDFTCBQKEKY7WRKOO53HOXX6XJXDQ5Y6KJWW43RUBIOZOIKSG8EC4I", "HcidError(\"TooManyErrors\")"]],
    "errantData": [["0c71db50d35d760b0ea2002ff20147c7c3a8e8030d35ef28ed1adaec9e329a", "HcidError(\"BadDataLen:31,Expected:32\")"]]
  },
  "hca0": {
    "correct": [["HcAciDds5OiogymxbnHKEabQ8iavqs8dwdVaGdJW76Vp4gx47tQDfGW4OWc9w5i", "0c71db50d35d760b0ea2002ff20147c7c3a8e8030d35ef28ed1adaec9e329aba"]],
    "correctable": [["HcAciDds_OiogymxbnHKEabQ8iavqs8dwdVaGdJW76Vp4gx47tQDfGW4OWc9w5i", "0c71db50d35d760b0ea2002ff20147c7c3a8e8030d35ef28ed1adaec9e329aba", "HcAciDds5OiogymxbnHKEabQ8iavqs8dwdVaGdJW76Vp4gx47tQDfGW4OWc9w5i"]],
    "errantId": [["HcAciDds_Oiog_mxb_HKEabQ8iavqs8dwdVaGdJW76Vp4gx47tQDfGW4O_c9w5i", "HcidError(\"TooManyErrors\")"]],
    "errantData": [["0c71db50d35d760b0ea2002ff20147c7c3a8e8030d35ef28ed1adaec9e329a", "HcidError(\"BadDataLen:31,Expected:32\")"]]
  },
  "hcs0": {
    "correct": [["HcSciDds5OiogymxbnHKEabQ8iavqs8dwdVaGdJW76Vp4gx47tQDfGW4OWc9w5i", "0c71db50d35d760b0ea2002ff20147c7c3a8e8030d35ef28ed1adaec9e329aba"]],
    "correctable": [["HcSciDds_OiogymxbnHKEabQ8iavqs8dwdVaGdJW76Vp4gx47tQDfGW4OWc9w5i", "0c71db50d35d760b0ea2002ff20147c7c3a8e8030d35ef28ed1adaec9e329aba", "HcSciDds5OiogymxbnHKEabQ8iavqs8dwdVaGdJW76Vp4gx47tQDfGW4OWc9w5i"]],
    "errantId": [["HcSciDds_Oiog_mxb_HKEabQ8iavqs8dwdVaGdJW76Vp4gx47tQDfGW4O_c9w5i", "HcidError(\"TooManyErrors\")"]],
    "errantData": [["0c71db50d35d760b0ea2002ff20147c7c3a8e8030d35ef28ed1adaec9e329a", "HcidError(\"BadDataLen:31,Expected:32\")"]]
  }
};
},{}],"../lib/encoding.test.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint no-new:0 */
var _require = require('..'),
    Encoding = _require.Encoding;

var _require2 = require('chai'),
    expect = _require2.expect;

var fixtures = require('../../test/fixtures');

var TEST_HEX_1 = '0c71db50d35d760b0ea2002ff20147c7c3a8e8030d35ef28ed1adaec9e329aba';
var TEST_ID_1 = 'HcKciDds5OiogymxbnHKEabQ8iavqs8dwdVaGdJW76Vp4gx47tQDfGW4OWc9w5i';
describe('Encoding Suite', function () {
  describe('fixtures', function () {
    var _loop = function _loop(type) {
      var f = fixtures[type];
      describe(type, function () {
        var enc = null;
        beforeEach(
        /*#__PURE__*/
        (0, _asyncToGenerator2.default)(
        /*#__PURE__*/
        _regenerator.default.mark(function _callee() {
          return _regenerator.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return new Encoding(type);

                case 2:
                  enc = _context.sent;

                case 3:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        })));
        afterEach(function () {
          enc = null;
        });
        describe('correct', function () {
          var _loop2 = function _loop2(i) {
            var t = f.correct[i];
            it('' + i, function () {
              var id = t[0];
              var data = t[1];
              expect(enc.is_corrupt(id)).equals(false);
              expect(enc.encode(Buffer.from(data, 'hex'))).equals(id);
              expect(Buffer.from(enc.decode(id)).toString('hex')).equals(data);
            });
          };

          for (var i = 0; i < f.correct.length; ++i) {
            _loop2(i);
          }
        });
        describe('correctable', function () {
          var _loop3 = function _loop3(i) {
            var t = f.correctable[i];
            it('' + i, function () {
              var id = t[0];
              var data = t[1];
              var correctId = t[2];
              expect(enc.is_corrupt(id)).equals(true);
              expect(enc.encode(Buffer.from(data, 'hex'))).equals(correctId);
              expect(Buffer.from(enc.decode(id)).toString('hex')).equals(data);
            });
          };

          for (var i = 0; i < f.correctable.length; ++i) {
            _loop3(i);
          }
        });
        describe('errantId', function () {
          var _loop4 = function _loop4(i) {
            var t = f.errantId[i];
            it('' + i, function () {
              var id = t[0];
              var err = t[1];
              expect(enc.is_corrupt(id)).equals(true);

              try {
                enc.decode(id);
              } catch (e) {
                expect(e.toString()).equals('Error: ' + err);
                return;
              }

              throw new Error('expected exception, got success');
            });
          };

          for (var i = 0; i < f.errantId.length; ++i) {
            _loop4(i);
          }
        });
        describe('errantData', function () {
          var _loop5 = function _loop5(i) {
            var t = f.errantData[i];
            it('' + i, function () {
              var data = t[0];
              var err = t[1];

              try {
                enc.encode(Buffer.from(data, 'hex'));
              } catch (e) {
                expect(e.toString()).equals('Error: ' + err);
                return;
              }

              throw new Error('expected exception, got success');
            });
          };

          for (var i = 0; i < f.errantData.length; ++i) {
            _loop5(i);
          }
        });
      });
    };

    for (var type in fixtures) {
      _loop(type);
    }
  });
  describe('basic', function () {
    var enc = null;
    beforeEach(
    /*#__PURE__*/
    (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee2() {
      return _regenerator.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return new Encoding('hck0');

            case 2:
              enc = _context2.sent;

            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })));
    afterEach(function () {
      enc = null;
    });
    it('should encode', function () {
      var buf = Buffer.from(TEST_HEX_1, 'hex');
      expect(enc.encode(buf)).equals(TEST_ID_1);
    });
    it('should decode', function () {
      expect(Buffer.from(enc.decode(TEST_ID_1)).toString('hex')).equals(TEST_HEX_1);
    });
    it('should determine not is_corrupt', function () {
      expect(enc.is_corrupt(TEST_ID_1)).equals(false);
    });
    it('should determine is_corrupt', function () {
      expect(enc.is_corrupt(TEST_ID_1.substr(0, 10) + 'A' + TEST_ID_1.substr(11))).equals(true);
    });
  });
});
},{"@babel/runtime/regenerator":"../node_modules/@babel/runtime/regenerator/index.js","@babel/runtime/helpers/asyncToGenerator":"../node_modules/@babel/runtime/helpers/asyncToGenerator.js","..":"../lib/browser/index.js","chai":"../node_modules/chai/index.js","../../test/fixtures":"../../test/fixtures.json","buffer":"../node_modules/buffer/index.js"}],"entry.js":[function(require,module,exports) {
"use strict";

require("../lib/encoding.test.js");
},{"../lib/encoding.test.js":"../lib/encoding.test.js"}]},{},["entry.js"], null)
//# sourceMappingURL=/karma-parcel/index.js.map