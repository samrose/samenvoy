"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

/**
 * The javascript library for making your web UI Holo enabled!
 *
 * It handles:
 * - Key management and generation
 *   - Generating temporary readonly keys for browsing
 *   - Detecting when authorization is required and prompting the user to signup/login to generate read/write keys
 * - Signing calls and responses
 * - Setting up a websocket connection to the interceptor to sign commits on request
 * - Wrapping and unwrapping calls to and from the interceptor such that they look like regular holochain calls
 *
 * Using this library to make a Holochain web UI Holo compatible is very easy provide you are already using hc-web-client
 * to connect to holochain. In this case an app can be converted by adding the following lines to a page load function
 * ```javascript
 * let holochainclient = require('@holochain/hc-web-client') // this should already be part of your web UI
 * const hClient = require('hClient')
 *
 * holochainclient = hClient.makeWebClient(holochainclient) // overwrite the holochain client with the holo version
 * hClient.installLoginDialog() // add the optional login dialog (strongly reccomended)
 * ```
 *
 * The login dialog is required because for Holo the user must manage their own keys in the browser. This is unlike Holochain where they
 * are managed by the conductor. If the login dialog is installed hClient will automatically detect when a user is trying to take an action that
 * requires a keypair (such as making a commit) and modally display the login page. Completing the login will generate/regenerate the users keypair
 * that is stored in the browser.
 *
 * ![holo-login-dialog](./sign-in-to-holo-screen.png?raw=true "Login Dialog")
 *
 * @module hClient
 */
var hClient = function () {
  var keypair;
  var websocket;

  var _happId;

  var _require = require('./keyManagement'),
      generateReadonlyKeypair = _require.generateReadonlyKeypair,
      generateNewReadwriteKeypair = _require.generateNewReadwriteKeypair,
      regenerateReadwriteKeypair = _require.regenerateReadwriteKeypair;

  var _require2 = require('./login'),
      showLoginDialog = _require2.showLoginDialog,
      insertLoginHtml = _require2.insertLoginHtml,
      registerLoginCallbacks = _require2.registerLoginCallbacks;

  var _require3 = require('./resolver'),
      getDnaForUrl = _require3.getDnaForUrl,
      getHostsForUrl = _require3.getHostsForUrl;

  var _require4 = require('./dpki-ultralite'),
      toBase64 = _require4.toBase64;

  var _require5 = require('@holochain/hcid-js'),
      Encoding = _require5.Encoding;
  /* ============================================
  =            Public API Functions            =
  ============================================ */

  /**
   * Insert the HTML for the login dialog into the current document and register the callbacks
   * @method
   * @memberof module:hClient
   *
   * @return     {(Function|Object)}  { description_of_the_return_value }
   */


  var installLoginDialog = function installLoginDialog() {
    insertLoginHtml();
    registerLoginCallbacks();
  };
  /**
   * Displays the login dialog and generates a new read/write key with the email/password
   * This will overwrite the current key
   * @memberof module:hClient
   */


  var triggerLoginPrompt =
  /*#__PURE__*/
  function () {
    var _ref = (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee() {
      var _ref2, email, password, newRegistration;

      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return showLoginDialog();

            case 2:
              _ref2 = _context.sent;
              email = _ref2.email;
              password = _ref2.password;
              newRegistration = _ref2.newRegistration;
              return _context.abrupt("return", startLoginProcess(email, password, newRegistration));

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function triggerLoginPrompt() {
      return _ref.apply(this, arguments);
    };
  }();
  /**
   * Start the local key generation/regeneration process with an email and password
   *
   * @param      {string}           email     The email
   * @param      {string}           password  The password
   * @param      {boolean}          newRegistration If true then register new salt with the saltservice otherwise try and regenerate existing keys
   * @memberof module:hClient
   */


  var startLoginProcess =
  /*#__PURE__*/
  function () {
    var _ref3 = (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee2(email, password, newRegistration) {
      var kp;
      return _regenerator.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!newRegistration) {
                _context2.next = 7;
                break;
              }

              console.log('registering new email with salt service');
              _context2.next = 4;
              return generateNewReadwriteKeypair(email, password);

            case 4:
              kp = _context2.sent;
              _context2.next = 11;
              break;

            case 7:
              console.log('restoring keys from existing registration');
              _context2.next = 10;
              return regenerateReadwriteKeypair(email, password);

            case 10:
              kp = _context2.sent;

            case 11:
              console.log('keypair is ', kp);
              _context2.next = 14;
              return setKeypair(kp);

            case 14:
              _context2.next = 16;
              return requestHosting();

            case 16:
              return _context2.abrupt("return", true);

            case 17:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function startLoginProcess(_x, _x2, _x3) {
      return _ref3.apply(this, arguments);
    };
  }();
  /**
     * Wraps and returns a holochainClient module.
     * Keeps the same functionaltiy but adds preCall and postCall hooks and also forces
     * connect to go to a given URL. This is the essential requirement to holo-fy any holochain web UI.
     * @memberof module:hClient
     *
     * @param      {Object}    holochainClient A hc-web-client module to wrap
     * @param      {string}    {happId}              The hApp identifier that Holo has linked to this application
     * @param      {Object}    [optionals]           Non-required arguments
     * @param      {string}    [optionals.url]       The url to direct websocket calls. Defaults to the same location serving the UI but with the websocket protocol.
     * @param      {string}    [optionals.dnaHash]   Override the hash of the DNA that would usually be provided by the loader. Mostly for testing purposes
     * @param      {Function}  [optionals.preCall]   The pre call funciton. Takes the callString and params and returns new callString and params.
     * Leave as default unless you know what you are doing.
     *
     * @param      {Function}  [optionals.postCall]  The post call function. Takes the response and returns the new response.
     * Leave as default unless you know what you are doing.
     *
     * @param      {Function}  [optionals.postConnect]  The post connect function.
     * Takes a RPC-websockets object and returns it preCall=preCall, postCall=postCall, postConnect=postConnect.
     * Leave as default unless you know what you are doing.
     */


  var makeWebClient =
  /*#__PURE__*/
  function () {
    var _ref4 = (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee5(holochainClient, happId) {
      var optionals,
          url,
          dnaHash,
          preCall,
          postCall,
          postConnect,
          _args5 = arguments;
      return _regenerator.default.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              optionals = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : {};
              _happId = happId;
              _context5.t0 = optionals.url;

              if (_context5.t0) {
                _context5.next = 7;
                break;
              }

              _context5.next = 6;
              return getDefaultWebsocketUrl();

            case 6:
              _context5.t0 = _context5.sent;

            case 7:
              url = _context5.t0;
              _context5.t1 = optionals.dnaHash;

              if (_context5.t1) {
                _context5.next = 13;
                break;
              }

              _context5.next = 12;
              return getDnaForUrl(window.location.origin);

            case 12:
              _context5.t1 = _context5.sent;

            case 13:
              dnaHash = _context5.t1;
              preCall = optionals.preCall || _preCall;
              postCall = optionals.postCall || _postCall;
              postConnect = optionals.postConnect || _postConnect;
              return _context5.abrupt("return", {
                connect: function connect() {
                  return holochainClient.connect(url).then(
                  /*#__PURE__*/
                  function () {
                    var _ref6 = (0, _asyncToGenerator2.default)(
                    /*#__PURE__*/
                    _regenerator.default.mark(function _callee4(_ref5) {
                      var _call, close, ws;

                      return _regenerator.default.wrap(function _callee4$(_context4) {
                        while (1) {
                          switch (_context4.prev = _context4.next) {
                            case 0:
                              _call = _ref5.call, close = _ref5.close, ws = _ref5.ws;
                              _context4.next = 3;
                              return postConnect(ws);

                            case 3:
                              ws = _context4.sent;
                              return _context4.abrupt("return", {
                                call: function call() {
                                  for (var _len = arguments.length, callStringSegments = new Array(_len), _key = 0; _key < _len; _key++) {
                                    callStringSegments[_key] = arguments[_key];
                                  }

                                  return (
                                    /*#__PURE__*/
                                    function () {
                                      var _ref7 = (0, _asyncToGenerator2.default)(
                                      /*#__PURE__*/
                                      _regenerator.default.mark(function _callee3(params) {
                                        var callString, _ref8, newCallString, newParams;

                                        return _regenerator.default.wrap(function _callee3$(_context3) {
                                          while (1) {
                                            switch (_context3.prev = _context3.next) {
                                              case 0:
                                                callString = callStringSegments.length === 1 ? callStringSegments[0] : callStringSegments.join('/');
                                                _context3.next = 3;
                                                return preCall(dnaHash, callString, params);

                                              case 3:
                                                _ref8 = _context3.sent;
                                                newCallString = _ref8.callString;
                                                newParams = _ref8.params;
                                                return _context3.abrupt("return", _call(newCallString)(newParams).then(postCall));

                                              case 7:
                                              case "end":
                                                return _context3.stop();
                                            }
                                          }
                                        }, _callee3);
                                      }));

                                      return function (_x7) {
                                        return _ref7.apply(this, arguments);
                                      };
                                    }()
                                  );
                                },
                                close: close,
                                ws: ws
                              });

                            case 5:
                            case "end":
                              return _context4.stop();
                          }
                        }
                      }, _callee4);
                    }));

                    return function (_x6) {
                      return _ref6.apply(this, arguments);
                    };
                  }());
                }
              });

            case 18:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    return function makeWebClient(_x4, _x5) {
      return _ref4.apply(this, arguments);
    };
  }();
  /**
     * Gets the current agent identifier from the current key pair
     * @memberof module:hClient
     *
     * @return     {(Encoding|Object)}  The current agent identifier.
     */


  var getCurrentAgentId =
  /*#__PURE__*/
  function () {
    var _ref9 = (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee6() {
      var enc;
      return _regenerator.default.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (!keypair) {
                _context6.next = 7;
                break;
              }

              _context6.next = 3;
              return new Encoding('hcs0');

            case 3:
              enc = _context6.sent;
              return _context6.abrupt("return", enc.encode(keypair._signPub));

            case 7:
              return _context6.abrupt("return", undefined);

            case 8:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));

    return function getCurrentAgentId() {
      return _ref9.apply(this, arguments);
    };
  }();
  /**
   * Request that the Holo host currently serving the page sets up a local chain for the current keypair
   * @memberof module:hClient
   *
   */


  var requestHosting =
  /*#__PURE__*/
  function () {
    var _ref10 = (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee7() {
      return _regenerator.default.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (!websocket) {
                _context7.next = 11;
                break;
              }

              _context7.t0 = websocket;
              _context7.next = 4;
              return getCurrentAgentId();

            case 4:
              _context7.t1 = _context7.sent;
              _context7.t2 = _happId;
              _context7.t3 = {
                agentId: _context7.t1,
                happId: _context7.t2
              };
              _context7.next = 9;
              return _context7.t0.call.call(_context7.t0, 'holo/agents/new', _context7.t3);

            case 9:
              _context7.next = 12;
              break;

            case 11:
              throw Error('Cannot request registration with no websocket');

            case 12:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    }));

    return function requestHosting() {
      return _ref10.apply(this, arguments);
    };
  }();
  /* =====  End of Public API Functions  ====== */

  /**
   * Gets the default websocket url.
   *
   * @return     {Object}  The default websocket url.
   */


  var getDefaultWebsocketUrl =
  /*#__PURE__*/
  function () {
    var _ref11 = (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee8() {
      var hosts;
      return _regenerator.default.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return getHostsForUrl(window.location.origin);

            case 2:
              hosts = _context8.sent;
              return _context8.abrupt("return", 'ws://' + hosts[0]);

            case 4:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8);
    }));

    return function getDefaultWebsocketUrl() {
      return _ref11.apply(this, arguments);
    };
  }(); // const getDefaultWebsocketUrl = () => document.getElementsByTagName('base')[0].href.replace('http', 'ws')

  /**
   * Setter for the keypair
   * Attaches a new event listener on the websocket for the new agentID
   *
   * @param      {Keypair}  kp      dpki-lite keypair object to attach to the instance
   */


  var setKeypair =
  /*#__PURE__*/
  function () {
    var _ref12 = (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee10(kp) {
      var agentId, event;
      return _regenerator.default.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              keypair = kp;

              if (!websocket) {
                _context10.next = 13;
                break;
              }

              _context10.next = 4;
              return getCurrentAgentId();

            case 4:
              agentId = _context10.sent;
              _context10.next = 7;
              return websocket.call('holo/identify', {
                agentId: agentId
              });

            case 7:
              // set up the websocket to sign on request
              event = "agent/".concat(agentId, "/sign");
              console.log('subscribing to event', event);
              websocket.subscribe(event);
              websocket.on(event,
              /*#__PURE__*/
              function () {
                var _ref14 = (0, _asyncToGenerator2.default)(
                /*#__PURE__*/
                _regenerator.default.mark(function _callee9(_ref13) {
                  var entry, id, signature, signatureBase64;
                  return _regenerator.default.wrap(function _callee9$(_context9) {
                    while (1) {
                      switch (_context9.prev = _context9.next) {
                        case 0:
                          entry = _ref13.entry, id = _ref13.id;
                          _context9.next = 3;
                          return keypair.sign(entry);

                        case 3:
                          signature = _context9.sent;
                          _context9.next = 6;
                          return toBase64(signature);

                        case 6:
                          signatureBase64 = _context9.sent;
                          websocket.call('holo/clientSignature', {
                            signature: signatureBase64,
                            requestId: id
                          });

                        case 8:
                        case "end":
                          return _context9.stop();
                      }
                    }
                  }, _callee9);
                }));

                return function (_x9) {
                  return _ref14.apply(this, arguments);
                };
              }());
              _context10.next = 14;
              break;

            case 13:
              throw Error('Could not register callback as no valid websocket instance found');

            case 14:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10);
    }));

    return function setKeypair(_x8) {
      return _ref12.apply(this, arguments);
    };
  }();
  /**
     * Preprocesses the callString and params before making a call
     *
     * @param      {string}  callString  The call string e.g. dna/zome/function
     * @param      {Object}  params      The parameters
     * @return     {Object}  The updated callString and params passed to call
     */


  var _preCall =
  /*#__PURE__*/
  function () {
    var _ref15 = (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee11(dnaHash, callString, params) {
      var _callString$split, _callString$split2, instanceId, zome, funcName, call, signature, callParams;

      return _regenerator.default.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              if (keypair) {
                _context11.next = 4;
                break;
              }

              throw new Error('trying to call with no keys');

            case 4:
              console.log('call will be signed with', keypair); // this expects old style zome calls from hc-web-client. Fix later.

              _callString$split = callString.split('/'), _callString$split2 = (0, _slicedToArray2.default)(_callString$split, 3), instanceId = _callString$split2[0], zome = _callString$split2[1], funcName = _callString$split2[2];
              console.log(instanceId);
              call = {
                method: callString,
                params: params
              };
              _context11.next = 10;
              return keypair.sign(JSON.stringify(call));

            case 10:
              signature = _context11.sent;
              _context11.next = 13;
              return getCurrentAgentId();

            case 13:
              _context11.t0 = _context11.sent;
              _context11.t1 = _happId;
              _context11.t2 = dnaHash;
              _context11.t3 = zome;
              _context11.t4 = funcName;
              _context11.t5 = params;
              _context11.t6 = signature;
              callParams = {
                agentId: _context11.t0,
                happId: _context11.t1,
                dnaHash: _context11.t2,
                zome: _context11.t3,
                function: _context11.t4,
                params: _context11.t5,
                signature: _context11.t6
              };
              return _context11.abrupt("return", {
                callString: 'holo/call',
                params: callParams
              });

            case 22:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11);
    }));

    return function _preCall(_x10, _x11, _x12) {
      return _ref15.apply(this, arguments);
    };
  }();
  /**
     * Postprocess the response of a call before returning it to the UI
     *
     * @param      {string}  response  The response of the call
     * @return     {string}  Updated response
     */


  var _postCall = function _postCall(response) {
    console.log(response); // Check response for authentication error to see if login is required

    try {
      var responseJson = JSON.parse(response);

      if (responseJson.Err && responseJson.Err.code === 401) {
        triggerLoginPrompt();
      }
    } catch (e) {
      console.log(e);
    } // TODO: Sign the response and sent it back to the interceptor (check this is still required)
    // const responseSig = keypair.sign()


    return response;
  };
  /**
     * Add any new callbacks to the websocket object or make calls immediatly after connecting
     *
     * @param      {Object}  ws      { rpc=websockets object }
     */


  var _postConnect =
  /*#__PURE__*/
  function () {
    var _ref16 = (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee12(ws) {
      var kp;
      return _regenerator.default.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              websocket = ws;
              console.log('generating readonly keypair');
              _context12.next = 4;
              return generateReadonlyKeypair();

            case 4:
              kp = _context12.sent;
              _context12.next = 7;
              return setKeypair(kp);

            case 7:
              return _context12.abrupt("return", ws);

            case 8:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12);
    }));

    return function _postConnect(_x13) {
      return _ref16.apply(this, arguments);
    };
  }();

  return {
    installLoginDialog: installLoginDialog,
    triggerLoginPrompt: triggerLoginPrompt,
    startLoginProcess: startLoginProcess,
    makeWebClient: makeWebClient,
    getCurrentAgentId: getCurrentAgentId,
    requestHosting: requestHosting,
    getDnaForUrl: getDnaForUrl,
    getHostsForUrl: getHostsForUrl
  };
}();

module.exports = hClient;