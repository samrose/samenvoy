"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

/**
 * keyManagement.js
 *
 * Deals with managing how keys generated with the salt server
 *
 */
var _require = require('./dpki-ultralite'),
    Keypair = _require.Keypair,
    randomBytes = _require.randomBytes,
    pwHash = _require.pwHash,
    fromBase64 = _require.fromBase64,
    toBase64 = _require.toBase64;

var saltmineUrl = '//saltmine.holohost.net';
/**
 * Make a call to the saltmine API
 *
 * @param      {string}      method  The HTTP method e.g. "POST"
 * @param      {Object}      params  Parameter to pass in the body
 * @return     {Promise}     Promise that resolves to the reponse
 */

var callSaltmine = function callSaltmine(method, params) {
  var body;

  if (method === 'GET') {
    body = undefined;
  } else {
    body = Object.keys(params).map(function (key) {
      return encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);
    }).join('&');
  }

  return fetch(saltmineUrl, {
    method: method,
    // mode: 'no-cors',
    cache: 'no-cache',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded' // Do not change or CORS will come and eat you alive (it does anyway!)

    },
    body: body
  });
};
/**
 * Use the saltmine to retrieve 32 bytes of entropy
 *
 * @return     {Uint8Array}  The remote entropy.
 */


var getRemoteEntropy = function getRemoteEntropy() {
  return callSaltmine('GET').then(function (r) {
    return r.text();
  }).then(fromBase64).then(function (buffer) {
    return new Uint8Array(buffer).slice(0, 32);
  });
};
/**
 * Register some salt with a given email address
 *
 * @param      {string}      email   The email
 * @param      {Uint8Array}  salt    The salt
 * @return     {Promise}     If successful will resolve to the same salt again
 */


var registerSalt = function registerSalt(email, salt) {
  return callSaltmine('POST', {
    email: email,
    salt: salt
  }).then(function (r) {
    return r.text();
  }).then(fromBase64).then(function (buffer) {
    return new Uint8Array(buffer).slice(0, 32);
  });
};
/**
 * Gets the registered salt.
 *
 * @param      {string}      email   The email
 * @return     {Promise}  If successful will resolve to previously registered salt
 */


var getRegisteredSalt = function getRegisteredSalt(email) {
  return callSaltmine('POST', {
    email: email
  }).then(function (r) {
    return r.text();
  }).then(fromBase64).then(function (buffer) {
    return new Uint8Array(buffer).slice(0, 32);
  });
};
/**
 * Generate 32 bytes of entropy locally using either webcrypto (preferred, unimplemented) or libsodium
 *
 * @return     {Uint8Array}  The local entropy.
 */


var getLocalEntropy =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee() {
    var array;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(typeof window !== 'undefined' && window.crypto)) {
              _context.next = 6;
              break;
            }

            array = new Uint8Array(32);
            window.crypto.getRandomValues(array);
            return _context.abrupt("return", array);

          case 6:
            console.log('Browser does not provide webcrypto. Falling back to libsodium (Warning: this may be less secure)');
            return _context.abrupt("return", randomBytes(32));

          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function getLocalEntropy() {
    return _ref.apply(this, arguments);
  };
}();
/**
 * XOR two Uint8 arrays together.
 * Surely there is a better way to do this? This is the best I could find
 */


var XorUint8Array = function XorUint8Array(a, b) {
  var r = new Uint8Array(a.length);

  for (var i = 0; i < a.length; i++) {
    r[i] = a[i] ^ b[i];
  }

  return r;
};
/**
 * Full workflow for generating a new readonly key pair
 *
 * @param    {function}    remoteEntropyGenerator
 * @param    {function}    localEntropyGenerator
 * @return     {Object}  The generated keypair object
 */


var generateReadonlyKeypair =
/*#__PURE__*/
function () {
  var _ref2 = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee2() {
    var remoteEntropyGenerator,
        localEntropyGenerator,
        remoteEntropy,
        localEntropy,
        seed,
        keypair,
        _args2 = arguments;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            remoteEntropyGenerator = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : getRemoteEntropy;
            localEntropyGenerator = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : getLocalEntropy;
            _context2.next = 4;
            return remoteEntropyGenerator();

          case 4:
            remoteEntropy = _context2.sent;
            _context2.next = 7;
            return localEntropyGenerator();

          case 7:
            localEntropy = _context2.sent;
            seed = XorUint8Array(remoteEntropy, localEntropy);
            _context2.next = 11;
            return Keypair.newFromSeed(seed);

          case 11:
            keypair = _context2.sent;
            return _context2.abrupt("return", keypair);

          case 13:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function generateReadonlyKeypair() {
    return _ref2.apply(this, arguments);
  };
}();
/**
 * Full workflow for generating a new readwrite keypair given an email and password
 *
 * @param      {string}  email     The email
 * @param      {string}  password  The password
 * @param    {function}    remoteEntropyGenerator
 * @param    {function}    localEntropyGenerator
 * @param      {function} saltRegistrationCallback
 */


var generateNewReadwriteKeypair =
/*#__PURE__*/
function () {
  var _ref3 = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee3(email, password) {
    var remoteEntropyGenerator,
        localEntropyGenerator,
        saltRegistrationCallback,
        remoteEntropy,
        localEntropy,
        saltBytes,
        saltString,
        registeredSalt,
        _ref4,
        hash,
        keypair,
        _args3 = arguments;

    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            remoteEntropyGenerator = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : getRemoteEntropy;
            localEntropyGenerator = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : getLocalEntropy;
            saltRegistrationCallback = _args3.length > 4 && _args3[4] !== undefined ? _args3[4] : registerSalt;
            _context3.next = 5;
            return remoteEntropyGenerator();

          case 5:
            remoteEntropy = _context3.sent;
            _context3.next = 8;
            return localEntropyGenerator();

          case 8:
            localEntropy = _context3.sent;
            saltBytes = XorUint8Array(remoteEntropy, localEntropy);
            _context3.next = 12;
            return toBase64(saltBytes);

          case 12:
            saltString = _context3.sent;
            _context3.prev = 13;
            _context3.next = 16;
            return saltRegistrationCallback(email, saltString);

          case 16:
            registeredSalt = _context3.sent;
            _context3.next = 23;
            break;

          case 19:
            _context3.prev = 19;
            _context3.t0 = _context3["catch"](13);
            console.error('could not register salt. Proceeding unregistered', _context3.t0);
            registeredSalt = saltString;

          case 23:
            _context3.next = 25;
            return pwHash(password, registeredSalt.slice(0, 16));

          case 25:
            _ref4 = _context3.sent;
            hash = _ref4.hash;
            _context3.next = 29;
            return Keypair.newFromSeed(hash);

          case 29:
            keypair = _context3.sent;
            return _context3.abrupt("return", keypair);

          case 31:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[13, 19]]);
  }));

  return function generateNewReadwriteKeypair(_x, _x2) {
    return _ref3.apply(this, arguments);
  };
}();
/**
 * Full workflow for restoring a keypair given a user has already registered salt for
 * the given email address
 *
 * @param      {string}  email     The email
 * @param      {string}  password  The password
 * @param      {function} getRegisteredSaltCallback
 * @return     {function}  The generated keypair object
 */


var regenerateReadwriteKeypair =
/*#__PURE__*/
function () {
  var _ref5 = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee4(email, password) {
    var getRegisteredSaltCallback,
        registeredSalt,
        _ref6,
        hash,
        keypair,
        _args4 = arguments;

    return _regenerator.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            getRegisteredSaltCallback = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : getRegisteredSalt;
            _context4.next = 3;
            return getRegisteredSaltCallback(email);

          case 3:
            registeredSalt = _context4.sent;
            _context4.next = 6;
            return pwHash(password, registeredSalt.slice(0, 16));

          case 6:
            _ref6 = _context4.sent;
            hash = _ref6.hash;
            _context4.next = 10;
            return Keypair.newFromSeed(hash);

          case 10:
            keypair = _context4.sent;
            return _context4.abrupt("return", keypair);

          case 12:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function regenerateReadwriteKeypair(_x3, _x4) {
    return _ref5.apply(this, arguments);
  };
}();

module.exports = {
  getRemoteEntropy: getRemoteEntropy,
  getLocalEntropy: getLocalEntropy,
  generateReadonlyKeypair: generateReadonlyKeypair,
  generateNewReadwriteKeypair: generateNewReadwriteKeypair,
  regenerateReadwriteKeypair: regenerateReadwriteKeypair
};