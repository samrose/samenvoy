"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

/* eslint-disable */
var _sodium = require('libsodium-wrappers-sumo');

var msgpack = require('msgpack-lite');

var util = require('./util');

var NONCEBYTES = 24;
/**
 * Represents two asymmetric cryptography keypairs
 * - a signing keypair
 * - an encryption keypair
 *
 * base64url encoded identity string to represent the public sides
 *
 * can optionally be initialized without the private halves of the pairs
 */

var Keypair =
/*#__PURE__*/
function () {
  /**
   * keypair constructor (you probably want one of the static functions above)
   * @param {object} opt
   * @param {string} opt.pubkeys - the keypair identity string
   * @param {Buffer} [opt.signPriv] - private signature key
   * @param {Buffer} [opt.encPriv] - private encryption key
   */
  function Keypair(opt) {
    (0, _classCallCheck2.default)(this, Keypair);

    if ((0, _typeof2.default)(opt) !== 'object' || typeof opt.pubkeys !== 'string') {
      throw new Error('opt.pubkeys must be a base64 encoded pubkey pair (sign / enc)');
    } // console.log("CHECK: ",Buffer.isBuffer(opt.encPriv));


    if (opt.signPub) {
      if (opt.signPub.constructor !== Uint8Array) {
        throw new Error('if opt.signPub is specified, it must be a Buffer');
      }
    }

    if (opt.signPriv) {
      if (opt.signPriv.constructor !== Uint8Array) {
        throw new Error('if opt.signPriv is specified, it must be a Buffer');
      }
    }

    if (opt.encPub) {
      if (opt.encPub.constructor !== Uint8Array) {
        throw new Error('if opt.encPub is specified, it must be a Buffer');
      }
    }

    if (opt.encPriv) {
      if (opt.encPriv.constructor !== Uint8Array) {
        throw new Error('if opt.encPriv is specified, it must be a Buffer');
      }
    }

    this._pubkeys = opt.pubkeys;
    this._signPub = opt.signPub;
    this._encPub = opt.encPub;
    this._signPriv = opt.signPriv;
    this._encPriv = opt.encPriv;
  }
  /**
   * derive the pairs from a 32 byte seed buffer
   * @param {Buffer} seed - the seed buffer
   */


  (0, _createClass2.default)(Keypair, [{
    key: "getId",

    /**
     * get the keypair identifier string
     * @return {string}
     */
    value: function getId() {
      return this._pubkeys;
    }
    /**
     * sign some arbitrary data with the signing private key
     * @param {Buffer} data - the data to sign
     */

  }, {
    key: "sign",
    value: function sign(data) {
      var _this2 = this;

      if (!this._signPriv) {
        throw new Error('no signPriv - cannot sign data');
      }

      return new Promise(function (resolve, reject) {
        _sodium.ready.then(function (_) {
          resolve(_sodium.crypto_sign_detached(data, _this2._signPriv));
          reject('failure reason'); // rejected
        });
      });
    }
    /**
     * verify data that was signed with our private signing key
     * @param {Buffer} signature
     * @param {Buffer} data
     */

  }, {
    key: "verify",
    value: function verify(signature, data) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        util.verify(signature, data, _this3._pubkeys).then(function (_) {
          resolve(_);
          reject('failure reason'); // rejected
        });
      });
    }
    /**
     * encrypt arbitrary data to be readale by potentially multiple recipients
     * @param {array<string>} recipientIds - multiple recipient identifier strings
     * @param {Buffer} data - the data to encrypt
     * @return {Buffer}
     */

  }, {
    key: "encrypt",
    value: function encrypt(recipientIds, data, adata) {
      var _this = this;

      data = Buffer.from(data);
      return new Promise(function (resolve, reject) {
        _sodium.ready.then(function (_) {
          util.randomBytes(32).then(function (symSecret) {
            var out = [];
            var flag = false;
            return new Promise(function (resolve, reject) {
              var _loop = function _loop(i, p) {
                util.decodeId(recipientIds[i]).then(function (key) {
                  return key.encPub;
                }).then(function (recipPub) {
                  // console.log("REC:: ",recipPub);
                  var _sodium$crypto_kx_ser = _sodium.crypto_kx_server_session_keys(_this._encPub, _this._encPriv, recipPub);

                  var tx = _sodium$crypto_kx_ser.sharedTx;

                  var nonce = _sodium.randombytes_buf(NONCEBYTES);

                  var cipher = _sodium.crypto_aead_xchacha20poly1305_ietf_encrypt(symSecret, adata || null, null, nonce, tx);

                  out.push(nonce);
                  out.push(cipher);

                  if (i == recipientIds.length - 1) {
                    flag = true;
                    resolve({
                      out: out,
                      symSecret: symSecret
                    });
                  }
                }); // XXX lru cache these so we don't have to re-gen every time?
              };

              for (var i = 0, p = Promise.resolve(); i < recipientIds.length; i++) {
                _loop(i, p);
              }
            });
          }).then(function (r) {
            var out = r.out;
            var symSecret = r.symSecret;

            var nonce = _sodium.randombytes_buf(NONCEBYTES);

            var cipher = _sodium.crypto_aead_xchacha20poly1305_ietf_encrypt(data, adata || null, null, nonce, symSecret);

            out.push(nonce);
            out.push(cipher);
            resolve(msgpack.encode(out));
            reject('failure reason'); // rejected
          });
        });
      });
    }
    /**
     * attempt to decrypt the cipher buffer (assuming it was targeting us)
     * @param {string} sourceId - identifier string of who encrypted this data
     * @param {Buffer} cipher - the encrypted data
     * @return {Buffer} - the decrypted data
     */

  }, {
    key: "decrypt",
    value: function decrypt(sId, cipher, adata) {
      var _this4 = this;

      cipher = msgpack.decode(cipher);
      return new Promise(function (resolve, reject) {
        _sodium.ready.then(function (_) {
          util.decodeId(sId).then(function (id) {
            // we will call the encryptor the "server"
            // and the recipient (us) the "client"
            // XXX cache?
            var sourceId = id.encPub;

            var _sodium$crypto_kx_cli = _sodium.crypto_kx_client_session_keys(_this4._encPub, _this4._encPriv, sourceId),
                rx = _sodium$crypto_kx_cli.sharedRx;

            var symSecret = null;

            for (var i = 0; i < cipher.length - 2; i += 2) {
              var n = cipher[i];
              var c = cipher[i + 1];

              try {
                symSecret = _sodium.crypto_aead_xchacha20poly1305_ietf_decrypt(null, c, adata || null, n, rx);
              } catch (e) {
                /* pass */
              }
            }

            if (!symSecret) {
              reject(new Error('could not decrypt - not a recipient?'));
            } else {
              resolve(_sodium.to_string(_sodium.crypto_aead_xchacha20poly1305_ietf_decrypt(null, cipher[cipher.length - 1], adata || null, cipher[cipher.length - 2], symSecret)));
              reject('failure reason'); // rejected
            }
          });
        });
      });
    }
    /**
     * generate an encrypted persistence bundle
     * @param {string} passphrase - the encryption passphrase
     * @param {string} hint - additional info / description for the bundle
     */

  }, {
    key: "getBundle",
    value: function getBundle(passphrase, hint) {
      var _this5 = this;

      if (typeof hint !== 'string') {
        throw new Error('hint must be a string');
      }

      return new Promise(function (resolve, reject) {
        util.pwEnc(msgpack.encode([_this5._signPub, _this5._encPub, _this5._signPriv, _this5._encPriv]), passphrase).then(function (data) {
          resolve({
            type: 'hcKeypair',
            hint: hint,
            data: data
          });
          reject('failure reason'); // rejected
        });
      });
    }
    /**
     * initialize the pairs from an encrypted persistence bundle
     * @param {object} bundle - persistence info
     * @param {string} passphrase - decryption passphrase
     */

  }], [{
    key: "newFromSeed",
    value: function newFromSeed(seed) {
      return new Promise(function (resolve, reject) {
        _sodium.ready.then(function (_) {
          var _sodium$crypto_sign_s = _sodium.crypto_sign_seed_keypair(seed),
              signPub = _sodium$crypto_sign_s.publicKey,
              signPriv = _sodium$crypto_sign_s.privateKey;

          var _sodium$crypto_kx_see = _sodium.crypto_kx_seed_keypair(seed),
              encPub = _sodium$crypto_kx_see.publicKey,
              encPriv = _sodium$crypto_kx_see.privateKey;

          util.encodeId(signPub, encPub).then(function (pubkeys) {
            resolve(new Keypair({
              pubkeys: pubkeys,
              signPub: signPub,
              signPriv: signPriv,
              encPub: encPub,
              encPriv: encPriv
            }));
            reject('failure reason');
          });
        });
      });
    }
  }, {
    key: "fromBundle",
    value: function fromBundle(bundle, passphrase) {
      return new Promise(function (resolve, reject) {
        util.pwDec(bundle.data, passphrase).then(function (encoded_bundle) {
          bundle = msgpack.decode(encoded_bundle);
          util.encodeId(bundle[0], bundle[1]).then(function (pubkeys) {
            resolve(new Keypair({
              pubkeys: pubkeys,
              signPub: bundle[0],
              signPriv: bundle[2],
              encPub: bundle[1],
              encPriv: bundle[3]
            }));
            reject('failure reason');
          });
        });
      });
    }
  }]);
  return Keypair;
}();

exports.Keypair = Keypair;